These are the patches for the Alpha.  As before, not recently applied
and may need work to get it to apply.  See Alpha bfd for more details.

The issue of GLOBAL_OFFSET_TABLE in te-interix will need to be addressed
here to get the right spelling.

diff -urpPd --exclude-from=exclude.files //D/donn.intel/gnu.intel/gas/config/obj-coff.h //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/obj-coff.h
--- //D/donn.intel/gnu.intel/gas/config/obj-coff.h	Fri Apr  2 17:57:40 1999
+++ //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/obj-coff.h	Wed Mar 31 10:43:25 1999
@@ -65,6 +65,10 @@
 #include "coff/sparc.h"
 #endif
 
+#if defined(TC_ALPHA) && defined(TE_INTERIX)
+#include "coff/nt_alpha.h"
+#endif
+
 #ifdef TC_I386
 #include "coff/i386.h"
 
diff -urpPd --exclude-from=exclude.files //D/donn.intel/gnu.intel/gas/config/obj-coff.c //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/obj-coff.c
--- //D/donn.intel/gnu.intel/gas/config/obj-coff.c	Fri Apr  2 17:57:40 1999
+++ //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/obj-coff.c	Wed Mar 31 10:43:25 1999
@@ -2094,7 +2254,7 @@ coff_obj_symbol_new_hook (symbolP) // optmzn wrong for alpha
 
   if (S_IS_STRING (symbolP))
     SF_SET_STRING (symbolP);
-  if (!underscore && S_IS_LOCAL (symbolP))
+  if (S_IS_LOCAL (symbolP))
     SF_SET_LOCAL (symbolP);
 }
 
diff -urpPd --exclude-from=exclude.files //D/donn.intel/gnu.intel/gas/config/tc-alpha.c //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/tc-alpha.c
--- //D/donn.intel/gnu.intel/gas/config/tc-alpha.c	Fri Apr  2 17:56:07 1999
+++ //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/tc-alpha.c	Wed Mar 31 10:51:57 1999
@@ -5,6 +5,7 @@
    Modified by Ken Raeburn for gas-2.x and ECOFF support.
    Modified by Richard Henderson for ELF support.
    Modified by Klaus K"ampf for EVAX (openVMS/Alpha) support.
+   Modified by Donn Terry for NT/COFF support.
 
    This file is part of GAS, the GNU Assembler.
 
@@ -49,6 +50,21 @@
  * rights to redistribute these changes.
  */
 
+/* This file handles 4 distinct types of alpha object format.  That may
+   be an overload:
+
+   ELF:  no comment
+   EVAX:  no comment
+   ECOFF: "Extended Coff".  Don't know exactly what that is, but it mostly
+      appears similar to...
+   MS PE:  MS "COFF" for NT (for the Alpha).  That also implies 32-bit 
+      addressing and NT conventions on section usage.
+   The Alpha gcc compiler uses pseudos that indicate that it was targeted
+   at (probably) EVAX.  Since they seem to apply here as well, we occasionally
+   turn on EVAX stuff (or as needed, ECOFF).  There are a number of MS-isms
+   as well that need to be adapted to.
+*/
+
 #include "as.h"
 #include "subsegs.h"
 #include "ecoff.h"
@@ -60,6 +76,7 @@
 #endif
 
 #include <ctype.h>
+#include <string.h>
 
 
 /* Local types */
@@ -204,18 +221,45 @@ static void s_alpha_text PARAMS ((int));
 static void s_alpha_data PARAMS ((int));
 #ifndef OBJ_ELF
 static void s_alpha_comm PARAMS ((int));
+#endif
+#if defined (OBJ_ECOFF) || defined (OBJ_EVAX)
+static void s_alpha_pdesc PARAMS ((int));
+#endif
+#if defined (OBJ_ECOFF) || defined (OBJ_EVAX) || defined(TE_PE)
 static void s_alpha_rdata PARAMS ((int));
+static void s_alpha_linkage PARAMS ((int));
+static void s_alpha_fp_save PARAMS ((int));
+static void s_alpha_name PARAMS ((int));
+static void s_alpha_link PARAMS ((int));
+static void s_alpha_code_address PARAMS ((int));
+static void s_alpha_ent PARAMS ((int));
+static void s_alpha_mask PARAMS ((int));
+static void s_alpha_fmask PARAMS ((int));
+static void s_alpha_frame PARAMS ((int));
+static void s_alpha_end PARAMS ((int));
+static void s_alpha_file PARAMS ((int));
 #endif
-#ifdef OBJ_ECOFF
+#if defined(OBJ_ECOFF) || defined(TE_PE)
 static void s_alpha_sdata PARAMS ((int));
 #endif
+#if defined(TE_PE)
+static void s_alpha_pdata PARAMS ((int));
+static void s_alpha_eflag PARAMS ((int));
+static void s_alpha_prologue PARAMS ((int));
+static void alpha_build_pdata PARAMS((void));
+static void alpha_print_token PARAMS((FILE *, expressionS *));
+#endif
 #ifdef OBJ_ELF
 static void s_alpha_section PARAMS ((int));
 static void s_alpha_ent PARAMS ((int));
 static void s_alpha_end PARAMS ((int));
 static void s_alpha_mask PARAMS ((int));
 static void s_alpha_frame PARAMS ((int));
+#endif
+#if defined(OBJ_ECOFF) || defined(TE_PE)
 static void s_alpha_prologue PARAMS ((int));
+#endif
+#ifdef OBJ_ELF
 static void s_alpha_coff_wrapper PARAMS ((int));
 #endif
 #ifdef OBJ_EVAX
@@ -270,9 +314,7 @@ const char *md_shortopts = "Fm:gG:";
 #endif
 
 struct option md_longopts[] = {
-#define OPTION_32ADDR (OPTION_MD_BASE)
-  { "32addr", no_argument, NULL, OPTION_32ADDR },
-#define OPTION_RELAX (OPTION_32ADDR+1)
+#define OPTION_RELAX (OPTION_MD_BASE)
   { "relax", no_argument, NULL, OPTION_RELAX },
 #ifdef OBJ_ELF
 #define OPTION_MDEBUG (OPTION_RELAX+1)
@@ -280,6 +322,10 @@ struct option md_longopts[] = {
   { "mdebug", no_argument, NULL, OPTION_MDEBUG },
   { "no-mdebug", no_argument, NULL, OPTION_NO_MDEBUG },
 #endif
+#ifndef TE_PE  /* PE doesn't have the choice */
+#define OPTION_32ADDR (OPTION_NO_MDEBUG)
+  { "32addr", no_argument, NULL, OPTION_32ADDR },
+#endif
   { NULL, no_argument, NULL, 0 }
 };
 
@@ -324,13 +370,20 @@ static symbolS *alpha_gp_symbol;
 valueT alpha_gp_value;
 #endif
 
+#ifndef TE_PE
 /* The current $gp register */
 static int alpha_gp_register = AXP_REG_GP;
+#endif
 
 /* A table of the register symbols */
 static symbolS *alpha_register_table[64];
 
 /* Constant sections, or sections of constants */
+#if defined(TE_PE)
+static segT pdata_section;
+static segT alpha_ctors_section;
+static segT alpha_dtors_section;
+#else
 #ifdef OBJ_ECOFF
 static segT alpha_lita_section;
 static segT alpha_lit4_section;
@@ -341,8 +394,10 @@ static segT alpha_ctors_section;
 static segT alpha_dtors_section;
 #endif
 static segT alpha_lit8_section;
+#endif /* !TE_PE */
 
 /* Symbols referring to said sections. */
+#ifndef TE_PE
 #ifdef OBJ_ECOFF
 static symbolS *alpha_lita_symbol;
 static symbolS *alpha_lit4_symbol;
@@ -353,6 +408,7 @@ static symbolS *alpha_ctors_symbol;
 static symbolS *alpha_dtors_symbol;
 #endif
 static symbolS *alpha_lit8_symbol;
+#endif
 
 /* Literal for .litX+0x8000 within .lita */
 #ifdef OBJ_ECOFF
@@ -375,7 +431,9 @@ static int alpha_macros_on = 1;
 static int alpha_nofloats_on = 0;
 
 /* Are addresses 32 bit? */
+#ifndef TE_PE
 static int alpha_addr32_on = 0;
+#endif
 
 /* Symbol labelling the current insn.  When the Alpha gas sees
      foo:
@@ -408,7 +466,7 @@ static int alpha_flag_relax;
 /* What value to give to bfd_set_gp_size.  */
 static int g_switch_value = 8;
 
-#ifdef OBJ_EVAX
+#if defined(OBJ_EVAX) || defined(TE_PE)
 /* Collect information about current procedure here.  */
 static struct {
   symbolS *symbol;	/* proc pdesc symbol */
@@ -421,7 +479,11 @@ static struct {
   long imask;
   long fmask;
   int type;
+#ifdef TE_PE 
+  expressionS prologue;
+#else
   int prologue;
+#endif
 } alpha_evax_proc;
 
 static int alpha_flag_hash_long_names = 0;		/* -+ */
@@ -535,10 +597,12 @@ static const struct alpha_macro alpha_ma
   { "uldq",	emit_uldXu, (PTR)3,
     { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA,
       MACRO_IR, MACRO_EXP, MACRO_EOA } },
+#ifndef TE_PE
 
   { "ldgp",	emit_ldgp, NULL,
     { MACRO_IR, MACRO_EXP, MACRO_PIR, MACRO_EOA } },
 
+#endif
   { "ldi",	emit_lda, NULL,
     { MACRO_IR, MACRO_EXP, MACRO_EOA } },
   { "ldil",	emit_ldil, NULL,
@@ -780,8 +844,10 @@ md_begin ()
 
   /* Create the special symbols and sections we'll be using */
 
+#ifndef TE_PE
   /* So .sbss will get used for tiny objects.  */
   bfd_set_gp_size (stdoutput, g_switch_value);
+#endif
 
 #ifdef OBJ_ECOFF
   create_literal_section (".lita", &alpha_lita_section, &alpha_lita_symbol);
@@ -862,7 +928,7 @@ extern char *vax_md_atof PARAMS ((int, c
 
 char *
 md_atof (type, litP, sizeP)
-     char type;
+     int type;
      char *litP;
      int *sizeP;
 {
@@ -931,9 +997,11 @@ md_parse_option (c, arg)
       alpha_nofloats_on = 1;
       break;
 
+#ifndef TE_PE  /* no option about it! */
     case OPTION_32ADDR:
       alpha_addr32_on = 1;
       break;
+#endif
 
     case 'g':
       alpha_debug = 1;
@@ -998,13 +1066,17 @@ md_show_usage (stream)
 {
   fputs(_("\
 Alpha options:\n\
--32addr			treat addresses as 32-bit values\n\
 -F			lack floating point instructions support\n\
 -mev4 | -mev45 | -mev5 | -mev56 | -mpca56 | -mev6 | -mall\n\
 			specify variant of Alpha architecture\n\
 -m21064 | -m21066 | -m21164 | -m21164a | -m21164pc | -m21264\n\
 			these variants include PALcode opcodes\n"),
 	stream);
+#ifndef TE_PE
+  fputs(_("\
+-32addr			treat addresses as 32-bit values\n"),
+	stream);
+#endif
 #ifdef OBJ_EVAX
   fputs (_("\
 VMS options:\n\
@@ -1035,9 +1107,11 @@ md_pcrel_from (fixP)
 
 /* Attempt to simplify or even eliminate a fixup.  The return value is
    ignored; perhaps it was once meaningful, but now it is historical.
-   To indicate that a fixup has been eliminated, set fixP->fx_done.
+   To indicate that a fixup has been eliminated, set fixP->fx_done. */
 
-   For ELF, here it is that we transform the GPDISP_HI16 reloc we used
+#ifndef TE_PE /* [ */
+
+/* For ELF, here it is that we transform the GPDISP_HI16 reloc we used
    internally into the GPDISP reloc used externally.  We had to do
    this so that we'd have the GPDISP_LO16 reloc as a tag to compute
    the distance to the "lda" instruction for setting the addend to
@@ -1201,7 +1275,178 @@ done:
   return 0;
 }
 
-/*
+#else /* ][ TE_PE */
+   /* MS COFF doens't have an "offset" field in the relocation records, but
+      does stuff it into the actual data.  Things are enough different that
+      we just make our own md_apply_fix */
+
+   /* CAUTION... bfd_install_relocation is called later, and is redundant
+      with some of this code... be careful or you may get surprises.
+      More specifically:
+	 write_relocs() walks thru all the relocations.  After some processing
+	 it calls md_apply_fix to see if the fix can be completed here.
+	 (It doesn't look at the function result or possible chanes to *valueP).
+	 It then calls alpha_fix_adjustable to determine if we want the
+	 fix adjusted to be section-relative, rather than symbol relative.
+	 It will then convert to section-relative if we allow it.
+
+	 It then calls tc_gen_reloc to convert the fix into a reloc, and
+	 then bfd_install_relocation to actually install the relocation.
+	 (The usual value for addend is fixP->fx_offset).
+	 The latter knows how to apply (via addition or subtraction) 
+	 the addend according to the rules in the howto table.
+	 It also applies the value of the symbol to the relocation.
+
+	 Consequently, whatever tc_gen_reloc puts into addend will be applied
+	 to whatever WE put into the image here, which can easily lead to
+	 double adds.
+
+	 */
+
+int
+md_apply_fix (fixP, valueP)
+     fixS *fixP;
+     valueT *valueP;
+{
+  char * const fixpos = 
+      fixP->fx_frag->fr_literal + fixP->fx_where;
+  valueT value = *valueP;
+  unsigned image, size;
+  switch (fixP->fx_r_type)
+    {
+
+    case BFD_RELOC_16:
+      size = 2;
+      goto do_reloc_xx;
+
+    case BFD_RELOC_32:
+      size = 4;
+      goto do_reloc_xx;
+
+    case BFD_RELOC_64:
+      abort();  /* Until we see one to confirm we know what to do.... */
+      /* this is a littlendian world, so don't adjust the address;
+	 nevertheless, our intent is to load the ls-half of the longlong,
+	 ignoring the other half.  Or is sign-extension an issue? */
+      size = 4;
+
+    do_reloc_xx:
+      /* Function: put out the value; if there's nothing left to relocate
+	 against, say so */
+      if (fixP->fx_pcrel == 0 && 
+	  (fixP->fx_addsy == NULL || !S_IS_EXTERN (fixP->fx_addsy)))
+	{
+          md_number_to_chars(fixpos, value, size);
+          *valueP = 0;
+          fixP->fx_offset = 0;
+	}
+      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
+	{
+	  fixP->fx_done = 1;
+	  return 0;
+	}
+      return 1;
+
+    case BFD_RELOC_23_PCREL_S2:
+      /* This is a branch address */
+      /* Function: put out the value (repack first); if there's nothing 
+	 left to relocate against, say so */
+
+      /* It turns out that for this case, that value is the (negative)
+	 distance back to the beginning of the routine, which seems 
+	 strange, but we need to ignore it.  (I suspect a bug in
+	 bfd_perform_relocation).
+
+	 (The effect of the current state is that an offset from an
+	 unresolved here (that is, external) branch won't work.  (Granted,
+	 this is awfully rare in the world of HLLs, but....)
+
+         pcrel really can take on both values; externals are pcrel, but
+	 internals are not.
+      */
+      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
+	{
+	  image = bfd_getl32((unsigned char *)fixpos);
+	  image = (image & ~0x1FFFFF) | ((value >> 2) & 0x1FFFFF);
+	  md_number_to_chars (fixpos, image, 4);
+	  *valueP = 0;
+	  fixP->fx_done = 1;
+	  return 0;
+	}
+      return 1;
+
+    case BFD_RELOC_ALPHA_HINT:
+      /* Function: put out the value (repack first); if there's nothing 
+	 left to relocate against, say so */
+      image = bfd_getl32((unsigned char *)fixpos);
+      image = (image & ~0x3FFF) | ((value >> 2) & 0x3FFF);
+      *valueP = 0;
+      md_number_to_chars (fixpos, image, 4);
+      if (fixP->fx_pcrel == 0 && fixP->fx_addsy == 0)
+	{
+	  fixP->fx_done = 1;
+	  return 0;
+	}
+      return 1;
+
+    /* _bfd_install_relocation does the dirty work for these */
+    case BFD_RELOC_ALPHA_REFLO:
+      return 1;
+
+    case BFD_RELOC_ALPHA_PAIR:
+      return 1;
+
+    case BFD_RELOC_ALPHA_REFHI:
+      return 1;
+
+    /* No GP, so no GP relative relocations need apply.  (If that should
+       change, the code in the other md_apply_fix looks pretty good as a
+       starting point */
+    case BFD_RELOC_GPREL32:
+    case BFD_RELOC_ALPHA_GPDISP_HI16:
+    case BFD_RELOC_ALPHA_GPDISP_LO16:
+    case BFD_RELOC_ALPHA_LITUSE:
+    case BFD_RELOC_ALPHA_LITERAL:
+      abort();
+
+    default:
+      fprintf(stderr, "bad reloc: %d\n",fixP->fx_r_type);
+         as_bad_where (fixP->fx_file, fixP->fx_line, "Untested reloc\n");
+      abort(); /* Everything's abort until tested! */
+#if 0
+      {
+	const struct alpha_operand *operand;
+
+	if (fixP->fx_r_type <= BFD_RELOC_UNUSED)
+	  as_fatal ("unhandled relocation type %s",
+		    bfd_get_reloc_code_name (fixP->fx_r_type));
+
+	assert (fixP->fx_r_type < BFD_RELOC_UNUSED + alpha_num_operands);
+	operand = &alpha_operands[fixP->fx_r_type - BFD_RELOC_UNUSED];
+
+	/* The rest of these fixups only exist internally during symbol
+	   resolution and have no representation in the object file.  
+	   Therefore they must be completely resolved as constants.  */
+
+	if (fixP->fx_addsy != 0
+	    && fixP->fx_addsy->bsym->section != absolute_section)
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			"non-absolute expression in constant field");
+
+	image = bfd_getl32((unsigned char *)fixpos);
+	image = insert_operand(image, operand, (offsetT)value,
+			       fixP->fx_file, fixP->fx_line);
+      }
+      md_number_to_chars(fixpos, image, 4);
+      fixP->fx_done = 1;
+      return 0;
+#endif
+    }
+}
+
+#endif  /* ] */
+
+/* 
  * Look for a register name in the given symbol.
  */
 
@@ -1252,10 +1497,12 @@ md_undefined_symbol(name)
 	    }
 	  break;
 
+#ifndef TE_PE
 	case 'g':
 	  if (name[1] == 'p' && name[2] == '\0')
 	    return alpha_register_table[alpha_gp_register];
 	  break;
+#endif
 
 	case 's':
 	  if (name[1] == 'p' && name[2] == '\0')
@@ -1323,6 +1570,11 @@ alpha_force_relocation (f)
     case BFD_RELOC_32:
     case BFD_RELOC_64:
     case BFD_RELOC_ALPHA_HINT:
+#ifdef TE_PE 
+    case BFD_RELOC_ALPHA_REFHI:
+    case BFD_RELOC_ALPHA_REFLO:
+    case BFD_RELOC_ALPHA_PAIR:
+#endif
       return 0;
 
     default:
@@ -1337,14 +1589,19 @@ int
 alpha_fix_adjustable (f)
      fixS *f;
 {
-#ifdef OBJ_ELF
+/* This seems useful in the PE case as well, so until we find a contrary
+   reason.... Note a corresponding change in tc_gen_reloc */
+#if defined(OBJ_ELF) || defined(TE_PE)
   /* Prevent all adjustments to global symbols */
   if (S_IS_EXTERN (f->fx_addsy) || S_IS_WEAK (f->fx_addsy))
     return 0;
+  if (S_IS_WEAK (f->fx_addsy))
+    return 0;
 #endif
 
   /* Are there any relocation types for which we must generate a reloc
-     but we can adjust the values contained within it?  */
+     but we can adjust the values contained within it? 
+     (Adjustment means "make section relative".) */
   switch (f->fx_r_type)
     {
     case BFD_RELOC_ALPHA_GPDISP_HI16:
@@ -1362,6 +1619,11 @@ alpha_fix_adjustable (f)
     case BFD_RELOC_ALPHA_LINKAGE:
     case BFD_RELOC_ALPHA_CODEADDR:
 #endif
+#ifdef TE_PE
+    case BFD_RELOC_ALPHA_REFHI:
+    case BFD_RELOC_ALPHA_REFLO:
+    case BFD_RELOC_ALPHA_PAIR:
+#endif
       return 1;
 
     case BFD_RELOC_ALPHA_LITUSE:
@@ -1426,17 +1688,28 @@ tc_gen_reloc (sec, fixp)
 #endif
     {
       reloc->addend = fixp->fx_offset;
-#ifdef OBJ_ELF
+#if defined(OBJ_ELF) || defined(TE_PE)
       /*
        * Ohhh, this is ugly.  The problem is that if this is a local global
        * symbol, the relocation will entirely be performed at link time, not
-       * at assembly time.  bfd_perform_reloc doesn't know about this sort
+       * at assembly time.  bfd_install_relocation doesn't know about this sort
        * of thing, and as a result we need to fake it out here.
+       *
+       * DOES THIS APPLY TO EVERY FORMAT?
        */
       if ((S_IS_EXTERN (fixp->fx_addsy) || S_IS_WEAK (fixp->fx_addsy))
 	  && !S_IS_COMMON(fixp->fx_addsy))
 	reloc->addend -= fixp->fx_addsy->bsym->value;
 #endif
+      /* See the BFD discussion of when/how pcrel_offset gets set; here
+	 if it is set, we have to fake out bfd_install_relocation.
+	 (Whether pcrel_offset is set is determined by the native assembler,
+	 we just get to tag along.  However, we normally generate code as
+	 if it were not set.  -- Note to FSF/Cygnus; maybe the proper
+	 fix is to simply remove the test for pcrel_offset in 
+	 bfd_install_relocation (and bfd_perform_relocation?). */
+      if (reloc->howto->pcrel_offset)
+	reloc->addend += reloc->address;
     }
 
   return reloc;
@@ -1908,7 +2181,7 @@ emit_insn (insn)
 
   /* Take care of alignment duties */
   if (alpha_auto_align_on && alpha_current_align < 2)
-    alpha_align (2, (char *) NULL, alpha_insn_label, 0);
+    alpha_align (2, (char *) NULL, NULL, 0);
   if (alpha_current_align > 2)
     alpha_current_align = 2;
   alpha_insn_label = NULL;
@@ -1964,6 +2237,11 @@ emit_insn (insn)
 #ifdef OBJ_ELF
 	case BFD_RELOC_ALPHA_ELF_LITERAL:
 #endif
+#ifdef TE_PE
+	case BFD_RELOC_ALPHA_REFHI:
+	case BFD_RELOC_ALPHA_REFLO:
+	case BFD_RELOC_ALPHA_PAIR:
+#endif
 	case BFD_RELOC_GPREL32:
 	  fixP->fx_no_overflow = 1;
 	  break;
@@ -2085,6 +2363,7 @@ static const char * const stX_op[] = { "
 static const char * const ldX_op[] = { "ldb", "ldw", "ldll", "ldq" };
 static const char * const ldXu_op[] = { "ldbu", "ldwu", NULL, NULL };
 
+#ifndef TE_PE
 /* Implement the ldgp macro.  */
 
 static void
@@ -2147,6 +2426,7 @@ FIXME
   emit_insn (&insn);
 #endif /* OBJ_ECOFF || OBJ_ELF */
 }
+#endif /* TE_PE */
 
 #ifdef OBJ_EVAX
 
@@ -2205,6 +2485,7 @@ add_to_link_pool (basesym, sym, addend)
 
 #endif /* OBJ_EVAX */
 
+#ifndef TE_PE /* [ */
 /* Load a (partial) expression into a target register.
 
    If poffset is not null, after the call it will either contain
@@ -2566,6 +2847,151 @@ load_expression (targreg, exp, pbasereg,
   return emit_lituse;
 }
 
+#else /* TE_PE ][ */
+
+/* Load a (partial) expression into a target register.
+   This is the (32-bit) NT version.
+
+   If poffset is not null, after the call it will either contain
+   O_constant 0, or a 16-bit offset appropriate for any MEM format
+   instruction.  In addition, pbasereg will be modified to point to
+   the base register to use in that MEM format instruction.
+
+   In any case, *pbasereg should contain a base register to add to the
+   expression.  This will normally be either AXP_REG_ZERO or
+   could be alpha_gp_register if/when we find that GP is ever
+   used on NT.
+
+   We never use literals, so the return value is always false.
+
+   */
+
+static int
+load_expression (targreg, exp, pbasereg, poffset)
+     int targreg;
+     const expressionS *exp;
+     int *pbasereg;
+     expressionS *poffset;
+{
+  offsetT addend = exp->X_add_number;
+  int basereg = *pbasereg;
+  struct alpha_insn insn;
+  expressionS newtok[3];
+  offsetT low, high;
+
+  /* break up the addend */
+
+  /* if ADDEND is a number that when decaputated
+     to 16 bits would be negative, we need to bump the high order
+     portion by 1 so that when the instructions are executed,
+     the result is right because second instruction will do signed
+     arithmetic on the value loaded by the ldah. */
+
+  low = sign_extend_16 (addend);
+  high = sign_extend_16 (addend>>16);
+  if (low < 0) high += 1;
+
+  set_tok_reg (newtok[0], targreg);
+  set_tok_preg (newtok[2], basereg);
+
+  /* We don't need to worry about $at stuff here, because we never generate
+     64-bit literals that we have to fetch up. */
+  switch (exp->X_op)
+    {
+    case O_symbol:
+      /* Use addend, rather than high/low because it'll actually get
+	 applied to the instruction by various relocation operators
+	 later */
+      set_tok_sym (newtok[1], exp->X_add_symbol, addend);
+      /* inherit newtok[0,2] */
+
+      assemble_tokens_to_insn ("ldah", newtok, 3, &insn);
+
+      assert (insn.nfixups == 1);
+      insn.nfixups++;
+      insn.fixups[0].reloc = BFD_RELOC_ALPHA_REFHI ;
+
+      /* altho the symbol value will disappear in the pair reloc, we
+	 need it for the moment */
+      insn.fixups[1].reloc = BFD_RELOC_ALPHA_PAIR ;
+      insn.fixups[1].exp.X_op = O_symbol;
+      insn.fixups[1].exp.X_add_symbol = exp->X_add_symbol;
+      insn.fixups[1].exp.X_add_number = addend;
+      basereg=targreg;
+      set_tok_preg (newtok[2], basereg);
+
+      emit_insn(&insn);
+
+      if (!poffset)
+      {
+	set_tok_sym (newtok[1], exp->X_add_symbol, addend);
+
+	assemble_tokens_to_insn ("lda", newtok, 3, &insn);
+
+	assert (insn.nfixups == 1);
+	insn.fixups[0].reloc = BFD_RELOC_ALPHA_REFLO ;
+
+	emit_insn(&insn);
+      }
+      else
+	set_tok_const (*poffset, addend);
+
+      assert (basereg == targreg);
+      *pbasereg = basereg;
+      break;
+
+    case O_constant:
+      /* inherit newtok[0,2] */
+      if (high)
+	{
+	  /* emit "ldah r, high(r) */
+	  set_tok_const (newtok[1], high);
+	  assemble_tokens ("ldah", newtok, 3, 0);
+	  basereg = targreg;
+	  set_tok_preg (newtok[2], basereg);
+	}
+
+      /* Emit a low part if there is one or we're currently in the
+	 wrong register AND if there's no-one to pick it up later */
+      if (!poffset && (low || basereg != targreg))
+	{
+	  /* emit "lda r, low(base)" */
+	  set_tok_const (newtok[1], low);
+	  assemble_tokens ("lda", newtok, 3, 0);
+	  basereg = targreg;
+	  low = 0;
+	}
+
+      /* There's someone there waiting to use the low part, so say
+	 what it was! */
+      if (poffset)
+	set_tok_const (*poffset, low);
+      *pbasereg = basereg;
+
+      break;
+
+    case O_subtract:
+      abort();  /* Not sure if we need this one */
+      /* Assume that this difference expression will be resolved to an
+	 absolute value and that that value will fit in 16 bits. */
+
+      set_tok_reg (newtok[0], targreg);
+      newtok[1] = *exp;
+      set_tok_preg (newtok[2], basereg);
+      assemble_tokens ("lda", newtok, 3, 0);
+
+      if (poffset)
+	set_tok_const (*poffset, 0);
+      return 0;
+
+    default:
+      abort();
+    }
+
+  return false;
+}
+#endif /* ] */
+
 /* The lda macro differs from the lda instruction in that it handles
    most simple expressions, particualrly symbol address loads and
    large constants.  */
@@ -2579,7 +3005,11 @@ emit_lda (tok, ntok, unused)
   int basereg;
 
   if (ntok == 2)
+#ifdef TE_PE
+    basereg = AXP_REG_ZERO;
+#else
     basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
+#endif
   else
     basereg = tok[2].X_add_number;
 
@@ -2619,7 +3049,11 @@ emit_ir_load (tok, ntok, opname)
   struct alpha_insn insn;
 
   if (ntok == 2)
+#ifdef TE_PE
+    basereg = AXP_REG_ZERO;
+#else
     basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
+#endif
   else
     basereg = tok[2].X_add_number;
 
@@ -2662,7 +3096,11 @@ emit_loadstore (tok, ntok, opname)
   struct alpha_insn insn;
 
   if (ntok == 2)
+#ifdef TE_PE
+    basereg = AXP_REG_ZERO;
+#else
     basereg = (tok[1].X_op == O_constant ? AXP_REG_ZERO : alpha_gp_register);
+#endif
   else
     basereg = tok[2].X_add_number;
 
@@ -3250,7 +3688,11 @@ emit_jsrjmp (tok, ntok, vopname)
 #else
   else
     {
+#ifdef TE_PE
+      int basereg = AXP_REG_ZERO;
+#else
       int basereg = alpha_gp_register;
+#endif
       lituse = load_expression (r = AXP_REG_PV, &tok[tokidx], &basereg, NULL);
     }
 #endif
@@ -3467,7 +3909,7 @@ s_alpha_comm (ignore)
 
 #endif /* ! OBJ_ELF */
 
-#ifdef OBJ_ECOFF
+#if defined (OBJ_ECOFF) || defined(TE_PE)
 
 /* Handle the .rdata pseudo-op.  This is like the usual one, but it
    clears alpha_insn_label and restores auto alignment.  */
@@ -3477,9 +3919,13 @@ s_alpha_rdata (ignore)
      int ignore;
 {
   int temp;
+  segT new_sec;
 
   temp = get_absolute_expression ();
-  subseg_new (".rdata", 0);
+  new_sec = subseg_new (".rdata", 0);
+#ifdef TE_PE
+  bfd_set_section_flags(stdoutput, new_sec, SEC_READ | SEC_READONLY | SEC_DATA);
+#endif
   demand_empty_rest_of_line ();
   alpha_insn_label = NULL;
   alpha_auto_align_on = 1;
@@ -3488,7 +3934,7 @@ s_alpha_rdata (ignore)
 
 #endif
 
-#ifdef OBJ_ECOFF
+#if defined(OBJ_ECOFF) || defined(TE_PE)
 
 /* Handle the .sdata pseudo-op.  This is like the usual one, but it
    clears alpha_insn_label and restores auto alignment.  */
@@ -3508,6 +3954,39 @@ s_alpha_sdata (ignore)
 }
 #endif
 
+#ifdef TE_PE
+
+static void
+s_alpha_make_pdata()
+{
+  if (pdata_section == 0) 
+    {
+      pdata_section = subseg_new (".pdata", 0);
+      
+      bfd_set_section_flags (stdoutput, pdata_section,
+			     (SEC_READ | SEC_ALLOC | SEC_LOAD | SEC_RELOC
+			      | SEC_READONLY | SEC_DATA ));
+      
+      bfd_set_section_alignment (stdoutput, pdata_section, 2);
+    }
+  else
+    {
+      pdata_section = subseg_new(".pdata", 0);
+    }
+}
+
+static void
+s_alpha_pdata(ignore)
+     int ignore;
+{
+  s_alpha_make_pdata();
+  demand_empty_rest_of_line();
+  alpha_insn_label = NULL;
+  alpha_auto_align_on = 1;
+  alpha_current_align = 0;
+}
+#endif
+
 #ifdef OBJ_ELF
 
 /* Handle the .section pseudo-op.  This is like the usual one, but it
@@ -3524,6 +4003,8 @@ s_alpha_section (ignore)
   alpha_current_align = 0;
 }
 
+#endif
+
 static void
 s_alpha_ent (dummy)
      int dummy;
@@ -3645,7 +4126,12 @@ s_alpha_prologue (ignore)
   int arg;
 
   arg = get_absolute_expression ();
-  demand_empty_rest_of_line ();
+#ifdef TE_PE
+  /* the flag is gp mode usage, but since we don't use it... 
+     See the NT ASAXP documentation (.hlp) on .prologue's arg being ignored */
+
+  current_location (&alpha_evax_proc.prologue);
+#else
 
   if (ECOFF_DEBUGGING)
     sym = ecoff_get_cur_proc_sym ();
@@ -3668,8 +4154,27 @@ s_alpha_prologue (ignore)
 	as_bad (_("Invalid argument %d to .prologue."), arg);
 	break;
     }  
+#endif
+  demand_empty_rest_of_line ();
 }
 
+#ifdef TE_PE
+/* .eflag */
+
+static void
+s_alpha_eflag (ignore)
+     int ignore;
+{
+
+  alpha_evax_proc.type = get_absolute_expression ();
+  demand_empty_rest_of_line ();
+
+  return;
+}
+
+#endif
+
+
 static void
 s_alpha_coff_wrapper (which)
      int which;
@@ -3699,7 +4204,7 @@ s_alpha_coff_wrapper (which)
 }
 #endif /* OBJ_ELF */
 
-#ifdef OBJ_EVAX
+#if defined(OBJ_EVAX) || defined(TE_PE)
   
 /* Handle the section specific pseudo-op.  */
   
@@ -3710,7 +4215,12 @@ s_alpha_section (secid)
   int temp;
 #define EVAX_SECTION_COUNT 5
   static char *section_name[EVAX_SECTION_COUNT+1] =
+#ifdef TE_PE
+  static char *section_name[EVAX_SECTION_COUNT+1] =
+    { "NULL", ".rdata", "<error>", "<error>", ".ctors", ".dtors"};
+#else
     { "NULL", ".rdata", ".comm", ".link", ".ctors", ".dtors" };
+#endif
 
   if ((secid <= 0) || (secid > EVAX_SECTION_COUNT))
     {
@@ -3726,6 +4236,9 @@ s_alpha_section (secid)
   alpha_current_align = 0;
 }
 
+#endif
+
+#if defined(OBJ_EVAX) || defined(TE_PE)
 
 /* Parse .ent directives.  */
 
@@ -3744,7 +4257,11 @@ s_alpha_ent (ignore)
   alpha_evax_proc.fp_save = -1;
   alpha_evax_proc.imask = 0;
   alpha_evax_proc.fmask = 0;
+#ifdef TE_PE
+  alpha_evax_proc.prologue.X_op = 0;
+#else
   alpha_evax_proc.prologue = 0;
+#endif
   alpha_evax_proc.type = 0;
 
   expression (&symexpr);
@@ -3800,7 +4317,9 @@ s_alpha_frame (ignore)
 
   return;
 }
+#endif
 
+#if defined(OBJ_EVAX)
 static void
 s_alpha_pdesc (ignore)
      int ignore;
@@ -3950,10 +4469,12 @@ s_alpha_pdesc (ignore)
 
   return;
 }
+#endif
 
 
 /* Support for crash debug on vms.  */
 
+#ifndef TE_PE
 static void
 s_alpha_name (ignore)
      int ignore;
@@ -4061,7 +4582,9 @@ s_alpha_fp_save (ignore)
   demand_empty_rest_of_line ();
   return;
 }
+#endif
 
+#if defined(OBJ_EVAX) || defined(TE_PE)
 
 static void
 s_alpha_mask (ignore)
@@ -4111,10 +4634,32 @@ s_alpha_end (ignore)
      int ignore;
 {
   char c;
+  char *s;
 
-  c = get_symbol_end ();
+  /* just a sanity check */
+  s = input_line_pointer; 
+  c = get_symbol_end();
+  if (alpha_evax_proc.symbol == NULL)
+    {
+     as_bad(".end without matching .ent\n");
+     return;
+    }
+  if (input_line_pointer != s-1)
+    {
+     if (strcmp(S_GET_NAME(alpha_evax_proc.symbol), s) != 0) 
+       { 
+	 as_warn(".ent %s and .end %s don't match", 
+	    S_GET_NAME(alpha_evax_proc.symbol), s);
+       }
+    }
   *input_line_pointer = c;
+#ifdef TE_PE
+  alpha_build_pdata();
+#endif
+
   demand_empty_rest_of_line ();
+
+/* get ready for next procedure */
   alpha_evax_proc.symbol = 0;
 
   return;
@@ -4128,24 +4673,41 @@ s_alpha_file (ignore)
   symbolS *s;
   int length;
   static char case_hack[32];
+  char *fname;
 
   extern char *demand_copy_string PARAMS ((int *lenP));
-
+#ifndef TE_PE
+  /* This seems to be specific to some non-PE assemblers; change the test
+     if you know WHY this exists at all */
   sprintf (case_hack, "<CASE:%01d%01d>",
 	    alpha_flag_hash_long_names, alpha_flag_show_after_trunc);
 
   s = symbol_find_or_make (case_hack);
   s->bsym->flags |= BSF_FILE;
+#endif
 
   get_absolute_expression ();
-  s = symbol_find_or_make (demand_copy_string (&length));
+  if ((fname = demand_copy_string (&length)) != 0)
+    {
+      new_logical_line (fname, -1);
+#ifdef LISTING
+      if (listing)
+	listing_source_file (fname);
+#endif
+    }
+#ifdef obj_app_file
+  obj_app_file (fname);
+#else
+  s = symbol_find_or_make (fname);
   s->bsym->flags |= BSF_FILE;
+#endif
   demand_empty_rest_of_line ();
 
   return;
 }
-#endif /* OBJ_EVAX  */
+#endif /* OBJ_EVAX || TE_PE */
 
+#ifndef TE_PE
 /* Handle the .gprel32 pseudo op.  */
 
 static void
@@ -4198,6 +4760,7 @@ s_alpha_gprel32 (ignore)
   fix_new_exp (frag_now, p-frag_now->fr_literal, 4,
 	       &e, 0, BFD_RELOC_GPREL32);
 }
+#endif
 
 /* Handle floating point allocation pseudo-ops.  This is like the
    generic vresion, but it makes sure the current label, if any, is
@@ -4316,6 +4879,7 @@ s_alpha_set (x)
   demand_empty_rest_of_line ();
 }
 
+#ifndef TE_PE
 /* Handle the .base pseudo op.  This changes the assembler's notion of
    the $gp register.  */
 
@@ -4349,6 +4913,7 @@ s_alpha_base (ignore)
 
   demand_empty_rest_of_line ();
 }
+#endif
 
 /* Handle the .align pseudo-op.  This aligns to a power of two.  It
    also adjusts any current instruction label.  We treat this the same
@@ -4420,6 +4985,11 @@ s_alpha_space (ignore)
 
 /* Hook into cons for auto-alignment.  */
 
+/* The only place this is called right now is from the stabs code;
+   it is prone to doing temporary section switches (which are in
+   effect (rightly) while this is called).  (It's called as md_cons_align()).
+   We need to hide ALPHA_INSN_LABEL from it.  If this is ever used elsewhere, 
+   this may need to be conditional on whether it's the same sctn. */
 void
 alpha_cons_align (size)
      int size;
@@ -4484,7 +5054,7 @@ found:
 static void
 alpha_print_token(f, exp)
     FILE *f;
-    const expressionS *exp;
+    expressionS *exp;
 {
   switch (exp->X_op)
     {
@@ -4496,12 +5066,12 @@ alpha_print_token(f, exp)
 	{
 	  expressionS nexp = *exp;
 	  nexp.X_op = O_register;
-	  print_expr (f, &nexp);
+	  print_expr_1 (f, &nexp);
 	}
 	putc (')', f);
 	break;
       default:
-	print_expr (f, exp);
+	print_expr_1 (f, exp);
 	break;
     }
   return;
@@ -4514,11 +5084,16 @@ const pseudo_typeS md_pseudo_table[] =
 {
 #ifdef OBJ_ECOFF
   {"comm", s_alpha_comm, 0},	/* osf1 compiler does this */
+#endif
+#if defined(OBJ_ECOFF) || defined(TE_PE)
   {"rdata", s_alpha_rdata, 0},
 #endif
+#if defined(TE_PE)
+  {"pdata", s_alpha_pdata, 0},
+#endif
   {"text", s_alpha_text, 0},
   {"data", s_alpha_data, 0},
-#ifdef OBJ_ECOFF
+#if defined(OBJ_ECOFF) || defined(TE_PE)
   {"sdata", s_alpha_sdata, 0},
 #endif
 #ifdef OBJ_ELF
@@ -4532,22 +5107,24 @@ const pseudo_typeS md_pseudo_table[] =
   { "name", s_alpha_name, 0},
   { "linkage", s_alpha_linkage, 0},
   { "code_address", s_alpha_code_address, 0},
+  { "fp_save", s_alpha_fp_save, 0},
+  { "rdata", s_alpha_section, 1},
+  { "comm", s_alpha_comm, 0},
+  { "link", s_alpha_section, 3},
+  { "ent", s_alpha_ent, 0},
+#endif
+#if defined(OBJ_EVAX) || defined(TE_PE)
   { "ent", s_alpha_ent, 0},
   { "frame", s_alpha_frame, 0},
-  { "fp_save", s_alpha_fp_save, 0},
   { "mask", s_alpha_mask, 0},
   { "fmask", s_alpha_fmask, 0},
   { "end", s_alpha_end, 0},
   { "file", s_alpha_file, 0},
-  { "rdata", s_alpha_section, 1},
-  { "comm", s_alpha_comm, 0},
-  { "link", s_alpha_section, 3},
   { "ctors", s_alpha_section, 4},
   { "dtors", s_alpha_section, 5},
 #endif
 #ifdef OBJ_ELF
   /* Frame related pseudos.  */
-  {"ent", s_alpha_ent, 0},
   {"end", s_alpha_end, 0},
   {"mask", s_alpha_mask, 0},
   {"fmask", s_alpha_mask, 1},
@@ -4565,9 +5142,13 @@ const pseudo_typeS md_pseudo_table[] =
   {"val", s_alpha_coff_wrapper, 8},
   {"loc", s_alpha_coff_wrapper, 9},
 #else
+#ifndef TE_PE
   {"prologue", s_ignore, 0},
 #endif
+#endif
+#ifndef TE_PE
   {"gprel32", s_alpha_gprel32, 0},
+#endif
   {"t_floating", s_alpha_float_cons, 'd'},
   {"s_floating", s_alpha_float_cons, 'f'},
   {"f_floating", s_alpha_float_cons, 'F'},
@@ -4579,11 +5160,18 @@ const pseudo_typeS md_pseudo_table[] =
   {"set", s_alpha_set, 0},
   {"reguse", s_ignore, 0},
   {"livereg", s_ignore, 0},
+#ifndef TE_PE
   {"base", s_alpha_base, 0},		/*??*/
+#endif
   {"option", s_ignore, 0},
   {"aent", s_ignore, 0},
   {"ugen", s_ignore, 0},
+#ifdef TE_PE
+  {"prologue", s_alpha_prologue, 0},
+  {"eflag", s_alpha_eflag, 0},
+#else
   {"eflag", s_ignore, 0},
+#endif
 
   {"align", s_alpha_align, 0},
   {"double", s_alpha_float_cons, 'd'},
@@ -4657,6 +5245,83 @@ maybe_set_gp (sec)
   if (vma && vma < alpha_gp_value)
     alpha_gp_value = vma;
 }
+
+#ifdef TE_PE
+/* Build an entry in the .pdata subspace from the given function
+   attributes accumulated for it. 
+
+   This is incomplete, in that it doesn't handle the insertion of
+   the handler or its data, but we don't run into those from the
+   compiler yet.  What's the syntax?
+
+   */
+
+static void
+alpha_build_pdata ()
+{
+  asection *seg, *save_seg;
+  subsegT subseg, save_subseg;
+  char *p;
+  expressionS dot;
+
+  save_seg = now_seg;
+  save_subseg = now_subseg;
+
+  current_location (&dot);
+
+  s_alpha_make_pdata(); /* which might do nothing */
+
+  /* begin address */
+  p = frag_more (4);
+  md_number_to_chars (p, 0, 4);
+
+  /* Relocation info. for start offset of the function.  */
+  fix_new (frag_now, p - frag_now->fr_literal, 4,
+	   alpha_evax_proc.symbol, (offsetT) 0, 0,
+	   BFD_RELOC_32);
+
+  /* end address */
+  p = frag_more (4);
+  md_number_to_chars (p, 0, 4);
+
+  /* Relocation info. for end offset of the function.
+
+     Because we allow reductions of 32bit relocations for ELF, this will be
+     reduced to section_sym + offset which avoids putting the temporary
+     symbol into the symbol table.  It (should) end up giving the same
+     value as call_info->start_symbol + function size once the linker is
+     finished with its work.  */
+
+  fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
+ 	   &dot, 0,
+  	   BFD_RELOC_32);
+
+  /* Execption Handler.  Until the compiler generates try/except stuff 
+     we won't do anything.  However, we do plug in the high bit of the eflag */
+
+  /* The below is the right way to do it, but since we don't yet have an
+     exception handler address, we'll just stuff it in.  The md_number_to_chars
+     should really stuff 0 
+     exception_handler.X_add_number = (alpha_evax_proc.type>>2) & 0x1; */
+
+  p = frag_more (4);
+  md_number_to_chars (p, (alpha_evax_proc.type>>2) & 0x1, 4);
+
+  /* Handler data.  Also 0 (no other bits) */
+  p = frag_more (4);
+  md_number_to_chars (p, 0, 4);
+
+  /* Then the prologue; it gets the other 2 bits of the flags */
+  p = frag_more (4);
+  md_number_to_chars (p, 0, 4);
+  alpha_evax_proc.prologue.X_add_number = alpha_evax_proc.type & 0x3;
+  fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
+ 	   &alpha_evax_proc.prologue, 0,
+  	   BFD_RELOC_32);
+
+  subseg_set (save_seg, save_subseg);
+}
+#endif
 
 static void
 select_gp_value ()
diff -urpPd --exclude-from=exclude.files //D/donn.intel/gnu.intel/gas/config/tc-alpha.h //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/tc-alpha.h
--- //D/donn.intel/gnu.intel/gas/config/tc-alpha.h	Fri Apr  2 17:56:07 1999
+++ //D/donn.intel/gnu.intel/gas.0325.fullpatch/config/tc-alpha.h	Wed Mar 31 10:43:25 1999
@@ -25,6 +25,14 @@
 
 #define WORKING_DOT_WORD
 
+#ifdef TE_INTERIX
+
+#define TARGET_ARCH			bfd_arch_nt_alpha
+
+#define TARGET_FORMAT                   "pe-alpha"
+
+#else
+
 #define TARGET_ARCH			bfd_arch_alpha
 
 #define TARGET_FORMAT (OUTPUT_FLAVOR == bfd_target_ecoff_flavour	\
@@ -34,6 +42,8 @@
 		       : OUTPUT_FLAVOR == bfd_target_evax_flavour	\
 		       ? "vms-alpha"					\
 		       : "unknown-format")
+
+#endif
 
 #define NEED_LITERAL_POOL
 #define TC_HANDLES_FX_DONE
diff -urpPd --exclude-from=exclude.files //D/donn.intel/gnu.intel/gas/configure.in //D/donn.intel/gnu.intel/gas.0325.fullpatch/configure.in
--- //D/donn.intel/gnu.intel/gas/configure.in	Fri Apr  2 17:57:40 1999
+++ //D/donn.intel/gnu.intel/gas.0325.fullpatch/configure.in	Wed Mar 31 10:43:25 1999
@@ -124,6 +124,7 @@ changequote([,])dnl
       a29k-nyu-sym1)        fmt=coff ;;
       a29k-*-vxworks*)      fmt=coff ;;
 
+      alpha-*-interix)      fmt=coff em=interix ;;
       alpha*-*-*vms*)	    fmt=evax ;;
       alpha*-*-netware*)    fmt=ecoff ;;
       alpha*-*-openbsd*)    fmt=ecoff ;;
diff -urpPd --exclude-from=exclude.files //Q/Gnusrc/cygwin.0325/gas/expr.c //D/donn.intel/gnu.intel/gas/expr.c
--- //Q/Gnusrc/cygwin.0325/gas/expr.c	Thu Mar 25 02:10:29 1999
+++ //D/intel/gnu.intel/gas/expr.c	Wed Mar 31 10:43:26 1999
@@ -36,7 +36,7 @@
 static void floating_constant PARAMS ((expressionS * expressionP));
 static void integer_constant PARAMS ((int radix, expressionS * expressionP));
 static void mri_char_constant PARAMS ((expressionS *));
-static void current_location PARAMS ((expressionS *));
+void current_location PARAMS ((expressionS *));
 static void clean_up_expression PARAMS ((expressionS * expressionP));
 static segT operand PARAMS ((expressionS *));
 static operatorT operator PARAMS ((void));
@@ -738,7 +738,7 @@ mri_char_constant (expressionP)
 /* Return an expression representing the current location.  This
    handles the magic symbol `.'.  */
 
-static void
+void
 current_location (expressionp)
      expressionS *expressionp;
 {
