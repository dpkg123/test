MS LIB.EXE archive members can have full or partial pathnames
(not just filenames).  This ar cannot generate such an archive,
but for POSIX conformance, when presented with a full name, it
must use just the base filename.  -P causes full pathname match.

-P is intended as an unadvertized feature... ordinary users shouldn't
be doing such things.

The need to pass another argument around makes this a lot bigger patch
than the actual change would otherwise imply.

	* ar.c (match_pathnames): New var.
	(map_over_members): Extract only basename unless option.
	(main): Recognize -P
	(map_over_members): Add arg to called fn (prototype and defn),
	(print_contents): Ditto.
	(print_descr): Ditto.
	(extract_file): accept/use target_filename.
	* arsup.c (extract_file): Add arg.
	* arsup.h (extract_file): Add arg.

diff -drupP --exclude-from=//M/donn/bin/exclude.files binutils.nil/ar.c binutils/ar.c
--- binutils.nil/ar.c	Wed Jul  7 16:58:49 1999
+++ binutils/ar.c	Wed Jul  7 16:59:21 1999
@@ -68,10 +68,10 @@ static void
 remove_output PARAMS ((void));
 
 static void
-map_over_members PARAMS ((bfd *, void (*)(bfd *), char **, int));
+map_over_members PARAMS ((bfd *, void (*)(bfd *, char *), char **, int));
 
 static void
-print_contents PARAMS ((bfd * member));
+print_contents PARAMS ((bfd * member, char*));
 
 static void
 delete_members PARAMS ((bfd *, char **files_to_delete));
@@ -89,7 +89,7 @@ static void
 replace_members PARAMS ((bfd *, char **files_to_replace, boolean quick));
 
 static void
-print_descr PARAMS ((bfd * abfd));
+print_descr PARAMS ((bfd * abfd, char *));
 
 static void
 write_archive PARAMS ((bfd *));
@@ -134,6 +134,12 @@ int newer_only = 0;
    if any of the members are object files.  */
 int write_armap = 0;
 
+/* If presented with an archive containing full pathnames (LIB.EXE does
+   that), match on the full pathname of the member with a full pathname
+   on the command line.  Extraction is still done locally, per POSIX.
+   (This ar cannot create such archives.) */
+int match_pathnames = 0;
+
 /* Nonzero means it's the name of an existing member; position new or moved
    files with respect to this one.  */
 char *posname = NULL;
@@ -169,7 +175,7 @@ mri_emul ()
 static void
 map_over_members (arch, function, files, count)
      bfd *arch;
-     void (*function) PARAMS ((bfd *));
+     void (*function) PARAMS ((bfd *, char *));
      char **files;
      int count;
 {
@@ -180,7 +186,7 @@ map_over_members (arch, function, files,
       for (head = arch->next; head; head = head->next)
 	{
 	  PROGRESS (1);
-	  function (head);
+	  function (head, NULL);
 	}
       return;
     }
@@ -193,6 +199,19 @@ map_over_members (arch, function, files,
   for (; count > 0; files++, count--)
     {
       boolean found = false;
+      char *filename;
+      const char *membername;
+
+      /* POSIX is explicit: name matching is on the filename component
+	 of the member, not the whole member name.  Thus, if we GET
+	 an archive with pathnames in the members, or our command line
+	 contains same, we need to clean up the name to get a sane
+	 match. */
+      filename = strrchr(*files, '/');
+      if (filename == NULL || match_pathnames) 
+	  filename = *files;
+      else
+	  filename++;
 
       for (head = arch->next; head; head = head->next)
 	{
@@ -204,11 +223,18 @@ map_over_members (arch, function, files,
 	      struct stat buf;
 	      bfd_stat_arch_elt (head, &buf);
 	    }
-	  if ((head->filename != NULL) &&
-	      (!strcmp (*files, head->filename)))
+	  if (head->filename != NULL) 
 	    {
-	      found = true;
-	      function (head);
+	      membername = strrchr(head->filename, '/');
+	      if (membername == NULL || match_pathnames) 
+		  membername = head->filename;
+	      else
+		  membername++;
+	      if (!strcmp (filename, membername))
+		{
+		  found = true;
+		  function (head, *files);
+		}
 	    }
 	}
       if (!found)
@@ -501,6 +527,9 @@ main (argc, argv)
 	case 'M':
 	  mri_mode = 1;
 	  break;
+	case 'P':
+	  match_pathnames = 1;
+	  break;
 	case 'f':
 	  ar_truncate = true;
 	  break;
@@ -727,8 +759,9 @@ open_inarch (archive_filename, file)
 }
 
 static void
-print_contents (abfd)
+print_contents (abfd, ignored)
      bfd *abfd;
+     char *ignored;
 {
   int ncopied = 0;
   char *cbuf = xmalloc (BUFSIZE);
@@ -776,8 +809,9 @@ print_contents (abfd)
    Gilmore  */
 
 void
-extract_file (abfd)
+extract_file (abfd, target_filename)
      bfd *abfd;
+     char *target_filename;
 {
   FILE *ostream;
   char *cbuf = xmalloc (BUFSIZE);
@@ -786,17 +820,21 @@ extract_file (abfd)
   long size;
   struct stat buf;
   
+
+  if (target_filename == NULL)
+      target_filename = bfd_get_filename (abfd);
+
   if (bfd_stat_arch_elt (abfd, &buf) != 0)
     /* xgettext:c-format */
-    fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
+    fatal (_("internal stat error on %s"), target_filename);
   size = buf.st_size;
 
   if (size < 0)
     /* xgettext:c-format */
-    fatal (_("stat returns negative size for %s"), bfd_get_filename (abfd));
+    fatal (_("stat returns negative size for %s"), target_filename);
   
   if (verbose)
-    printf ("x - %s\n", bfd_get_filename (abfd));
+    printf ("x - %s\n", target_filename);
 
   bfd_seek (abfd, 0, SEEK_SET);
 
@@ -804,12 +842,12 @@ extract_file (abfd)
   if (size == 0)
     {
       /* Seems like an abstraction violation, eh?  Well it's OK! */
-      output_filename = bfd_get_filename (abfd);
+      output_filename = target_filename;
 
-      ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);
+      ostream = fopen (target_filename, FOPEN_WB);
       if (ostream == NULL)
 	{
-	  perror (bfd_get_filename (abfd));
+	  perror (target_filename);
 	  xexit (1);
 	}
 
@@ -832,12 +870,12 @@ extract_file (abfd)
 	if (ostream == NULL)
 	  {
 	    /* Seems like an abstraction violation, eh?  Well it's OK! */
-	    output_filename = bfd_get_filename (abfd);
+	    output_filename = target_filename;
 
-	    ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);
+	    ostream = fopen (target_filename, FOPEN_WB);
 	    if (ostream == NULL)
 	      {
-		perror (bfd_get_filename (abfd));
+		perror (target_filename);
 		xexit (1);
 	      }
 
@@ -853,10 +891,10 @@ extract_file (abfd)
   output_file = NULL;
   output_filename = NULL;
 
-  chmod (bfd_get_filename (abfd), buf.st_mode);
+  chmod (target_filename, buf.st_mode);
 
   if (preserve_dates)
-    set_times (bfd_get_filename (abfd), &buf);
+    set_times (target_filename, &buf);
 
   free (cbuf);
 }
@@ -1340,8 +1378,9 @@ ranlib_touch (archname)
 /* Things which are interesting to map over all or some of the files: */
 
 static void
-print_descr (abfd)
+print_descr (abfd, ignored)
      bfd *abfd;
+     char *ignored;
 {
   print_arelt_descr (stdout, abfd, verbose);
 }
diff -drupP --exclude-from=//M/donn/bin/exclude.files binutils.nil/arsup.c binutils/arsup.c
--- binutils.nil/arsup.c	Wed Jul  7 16:58:49 1999
+++ binutils/arsup.c	Wed Jul  7 16:59:21 1999
@@ -438,7 +438,7 @@ DEFUN(ar_extract,(list),
       {
 	if (strcmp(member->filename, list->name) == 0) 
 	{
-	  extract_file(member);
+	  extract_file(member, list->name);
 	  found = 1;
 	  }
 
diff -drupP --exclude-from=//M/donn/bin/exclude.files binutils.nil/arsup.h binutils/arsup.h
--- binutils.nil/arsup.h	Wed Jul  7 16:58:49 1999
+++ binutils/arsup.h	Wed Jul  7 16:59:21 1999
@@ -70,6 +70,6 @@ yyparse PARAMS ((void));
 /* Functions from ar.c */
 
 void
-extract_file PARAMS ((bfd * abfd));
+extract_file PARAMS ((bfd * abfd, char *));
 
 extern int interactive;
