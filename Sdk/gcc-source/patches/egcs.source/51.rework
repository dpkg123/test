There had accrued a lot of historical differences between cygwin.h and
interix.h that weren't necessary.  Although still significantly different,
what could be shared is now shared, and they are in roughly the same order.
This should make maintenance easier.

There are also a few real changes in here, associated with using the
winnt.c stuff, and ASM_FILE_START, ASM_DECLARE_FUNCTION_NAME
ASM_OUTPUT_EXTERNAL, and ASM_OUTPUT_EXTERNAL_LIBCALL, and ASM_FILE_END.
N.B.  The change to ASM_FILE_END may remove the need for some code that
tests whether a symbol's type is T_NULL or not in bfd.  However, it won't
hurt to leave it there.

This also allows Interix to use winnt.c, rather than interix.c, which
is fully deleted.

diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files gcc.saved/config/i386/i386-interix.h.orig gcc/config/i386/i386-interix.h
--- gcc.saved/config/i386/i386-interix.h.orig	Mon Apr  1 11:51:10 2002
+++ gcc/config/i386/i386-interix.h	Mon Apr  1 14:34:05 2002
@@ -24,8 +24,13 @@ along with GNU CC; see the file COPYING.
 the Free Software Foundation, 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA.  */
 
-/* The rest must follow.  */
-
+/* Note: Interix doesn't support user-written DLLs (use conventional
+   shared libs (.so) instead).  Thus a lot of the stuff that might apply
+   about dllimport/dllexport and the like does not apply here. */
+
+#include <stdio.h>
+
+/* We don't use the "usual" push-an-address solution. */
 #undef TARGET_ASM_CONSTRUCTOR
 
 #define DBX_DEBUGGING_INFO 1
@@ -48,27 +53,8 @@ Boston, MA 02111-1307, USA.  */
 { "ms-bitfields", MASK_MS_BITFIELD_LAYOUT, N_("Use native (MS) bitfield layout") }, \
 { "no-ms-bitfields", -MASK_MS_BITFIELD_LAYOUT, N_("Use gcc default bitfield layout") },
 
-
-/* By default, target has a 80387, uses IEEE compatible arithmetic,
-   and returns float values in the 387 and needs stack probes
-   We also align doubles to 64-bits for MSVC default compatibility
-   We do bitfields MSVC-compatably by default, too. */
-#undef TARGET_SUBTARGET_DEFAULT
-#define TARGET_SUBTARGET_DEFAULT \
-   (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE | \
-    MASK_ALIGN_DOUBLE | MASK_MS_BITFIELD_LAYOUT)
-
-#undef TARGET_CPU_DEFAULT
-#define TARGET_CPU_DEFAULT 2 /* 486 */
-
-#define WCHAR_TYPE_SIZE 16
-#define WCHAR_TYPE "short unsigned int"
-
-/* WinNT (and thus Interix) use unsigned int */
-#define SIZE_TYPE "unsigned int"
-
-#define ASM_LOAD_ADDR(loc, reg)   "     leal " #loc "," #reg "\n"
-
+/* Most *_SPEC entries are found in config/interix.h */
+
 /* cpp handles __STDC__ */
 #define TARGET_OS_CPP_BUILTINS()					\
   do									\
@@ -103,157 +89,11 @@ Boston, MA 02111-1307, USA.  */
 #define CPP_SPEC "-remap %{posix:-D_POSIX_SOURCE} \
 -isystem %$INTERIX_ROOT/usr/include"
 
-#define TARGET_VERSION fprintf (stderr, " (i386 Interix)");
-
-/* The global __fltused is necessary to cause the printf/scanf routines
-   for outputting/inputting floating point numbers to be loaded.  Since this
-   is kind of hard to detect, we just do it all the time.  */
-
-#ifdef ASM_FILE_START
-#undef ASM_FILE_START
-#endif
-#define ASM_FILE_START(FILE) \
-  do {  fprintf (FILE, "\t.file\t");                            \
-        output_quoted_string (FILE, dump_base_name);            \
-        fprintf (FILE, "\n");                                   \
-        fprintf (FILE, ".global\t__fltused\n");                 \
-  } while (0)
-
-/* A table of bytes codes used by the ASM_OUTPUT_ASCII and
-   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table
-   corresponds to a particular byte value [0..255].  For any
-   given byte value, if the value in the corresponding table
-   position is zero, the given character can be output directly.
-   If the table value is 1, the byte must be output as a \ooo
-   octal escape.  If the tables value is anything else, then the
-   byte value should be output as a \ followed by the value
-   in the table.  Note that we can use standard UN*X escape
-   sequences for many control characters, but we don't use
-   \a to represent BEL because some svr4 assemblers (e.g. on
-   the i386) don't know about that.  Also, we don't use \v
-   since some versions of gas, such as 2.2 did not accept it.  */
-
-#define ESCAPES \
-"\1\1\1\1\1\1\1\1btn\1fr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
-\0\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\0\0\
-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\
-\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
-\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
-\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
-\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1"
-
-/* Some svr4 assemblers have a limit on the number of characters which
-   can appear in the operand of a .string directive.  If your assembler
-   has such a limitation, you should define STRING_LIMIT to reflect that
-   limit.  Note that at least some svr4 assemblers have a limit on the
-   actual number of bytes in the double-quoted string, and that they
-   count each character in an escape sequence as one byte.  Thus, an
-   escape sequence like \377 would count as four bytes.
-
-   If your target assembler doesn't support the .string directive, you
-   should define this to zero.
-*/
-
-#define STRING_LIMIT	((unsigned) 256)
-
-#define STRING_ASM_OP	"\t.string\t"
-
-/* The routine used to output NUL terminated strings.  We use a special
-   version of this for most svr4 targets because doing so makes the
-   generated assembly code more compact (and thus faster to assemble)
-   as well as more readable, especially for targets like the i386
-   (where the only alternative is to output character sequences as
-   comma separated lists of numbers).   */
-
-#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)				\
-  do									\
-    {									\
-      register const unsigned char *_limited_str =			\
-        (const unsigned char *) (STR);					\
-      register unsigned ch;						\
-      fprintf ((FILE), "%s\"", STRING_ASM_OP);				\
-      for (; (ch = *_limited_str); _limited_str++)			\
-        {								\
-	  register int escape = ESCAPES[ch];				\
-	  switch (escape)						\
-	    {								\
-	    case 0:							\
-	      putc (ch, (FILE));					\
-	      break;							\
-	    case 1:							\
-	      fprintf ((FILE), "\\%03o", ch);				\
-	      break;							\
-	    default:							\
-	      putc ('\\', (FILE));					\
-	      putc (escape, (FILE));					\
-	      break;							\
-	    }								\
-        }								\
-      fprintf ((FILE), "\"\n");						\
-    }									\
-  while (0)
-
-/* The routine used to output sequences of byte values.  We use a special
-   version of this for most svr4 targets because doing so makes the
-   generated assembly code more compact (and thus faster to assemble)
-   as well as more readable.  Note that if we find subparts of the
-   character sequence which end with NUL (and which are shorter than
-   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */
-
-#undef ASM_OUTPUT_ASCII
-#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)				\
-  do									\
-    {									\
-      register const unsigned char *_ascii_bytes =			\
-        (const unsigned char *) (STR);					\
-      register const unsigned char *limit = _ascii_bytes + (LENGTH);	\
-      register unsigned bytes_in_chunk = 0;				\
-      for (; _ascii_bytes < limit; _ascii_bytes++)			\
-        {								\
-	  register const unsigned char *p;				\
-	  if (bytes_in_chunk >= 64)					\
-	    {								\
-	      fputc ('\n', (FILE));					\
-	      bytes_in_chunk = 0;					\
-	    }								\
-	  for (p = _ascii_bytes; p < limit && *p != '\0'; p++)		\
-	    continue;							\
-	  if (p < limit && (p - _ascii_bytes) <= (long) STRING_LIMIT)	\
-	    {								\
-	      if (bytes_in_chunk > 0)					\
-		{							\
-		  fputc ('\n', (FILE));					\
-		  bytes_in_chunk = 0;					\
-		}							\
-	      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);		\
-	      _ascii_bytes = p;						\
-	    }								\
-	  else								\
-	    {								\
-	      if (bytes_in_chunk == 0)					\
-		fprintf ((FILE), "\t.byte\t");				\
-	      else							\
-		fputc (',', (FILE));					\
-	      fprintf ((FILE), "0x%02x", *_ascii_bytes);		\
-	      bytes_in_chunk += 5;					\
-	    }								\
-	}								\
-      if (bytes_in_chunk > 0)						\
-        fprintf ((FILE), "\n");						\
-    }									\
-  while (0)
-
-/* Emit code to check the stack when allocating more that 4000
-   bytes in one go.  */
-
-#define CHECK_STACK_LIMIT 0x1000
-
-/* the following are OSF linker (not gld) specific... we don't want them */
-#undef HAS_INIT_SECTION
-#undef LD_INIT_SWITCH
-#undef LD_FINI_SWITCH
-
+#define SIZE_TYPE "unsigned int"
+#define PTRDIFF_TYPE "int"
+#define WCHAR_TYPE_SIZE 16
+#define WCHAR_TYPE "unsigned short"
+
 /* The following are needed for us to be able to use winnt.c, but are not
    otherwise meaningful to Interix.  (The functions that use these are
    never called because we don't do DLLs.) */
@@ -264,16 +104,136 @@ Boston, MA 02111-1307, USA.  */
 
 #define READONLY_DATA_SECTION_ASM_OP	"\t.section\t.rdata,\"r\""
 
+/* Define this macro if references to a symbol must be treated
+   differently depending on something about the variable or
+   function named by the symbol (such as what section it is in).  */
+
+#undef TARGET_ENCODE_SECTION_INFO
+#define TARGET_ENCODE_SECTION_INFO i386_pe_encode_section_info
+#undef  TARGET_STRIP_NAME_ENCODING
+#define TARGET_STRIP_NAME_ENCODING  i386_pe_strip_name_encoding_full
+
+/* Emit code to check the stack when allocating more that 4000
+   bytes in one go.  */
+
+#define CHECK_STACK_LIMIT 4000
+
+/* By default, target has a 80387, uses IEEE compatible arithmetic,
+   and returns float values in the 387 and needs stack probes
+   We also align doubles to 64-bits for MSVC default compatibility
+   Ditto for bitfields. */
+#undef TARGET_SUBTARGET_DEFAULT
+#define TARGET_SUBTARGET_DEFAULT \
+   (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE | \
+    MASK_ALIGN_DOUBLE | MASK_MS_BITFIELD_LAYOUT)
+
+#undef TARGET_CPU_DEFAULT
+#define TARGET_CPU_DEFAULT 2 /* 486 */
+
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (i386 Interix)");
+
 /* The MS compilers take alignment as a number of bytes, so we do as well */
 #undef ASM_OUTPUT_ALIGN
 #define ASM_OUTPUT_ALIGN(FILE,LOG) \
   if ((LOG)!=0) fprintf ((FILE), "\t.balign %d\n", 1<<(LOG))
 
+/* Define this macro if in some cases global symbols from one translation
+   unit may not be bound to undefined symbols in another translation unit
+   without user intervention.  For instance, under Microsoft Windows
+   symbols must be explicitly imported from shared libraries (DLLs).  */
+#define MULTIPLE_SYMBOL_SPACES
+
+/* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */
+#define HANDLE_PRAGMA_PACK_PUSH_POP 1
+
+extern void i386_pe_unique_section PARAMS ((tree, int));
+#define TARGET_ASM_UNIQUE_SECTION i386_pe_unique_section
+
+#define SUPPORTS_ONE_ONLY 1
+
+/* Switch into a generic section.  */
+#define TARGET_ASM_NAMED_SECTION  default_pe_asm_named_section
+
+/* Select attributes for named sections.  */
+#define TARGET_SECTION_TYPE_FLAGS  i386_pe_section_type_flags
+
+/* Write the extra assembler code needed to declare a function
+   properly.  If we are generating SDB debugging information, this
+   will happen automatically, so we only need to handle other cases.  */
+#undef ASM_DECLARE_FUNCTION_NAME
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
+  do									\
+    {									\
+      if (write_symbols != SDB_DEBUG)					\
+	i386_pe_declare_function_type (FILE, NAME, TREE_PUBLIC (DECL));	\
+      ASM_OUTPUT_LABEL (FILE, NAME);					\
+    }									\
+  while (0)
+
+/* Add an external function to the list of functions to be declared at
+   the end of the file.  */
+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)				\
+  do									\
+    {									\
+      if (TREE_CODE (DECL) == FUNCTION_DECL)				\
+	i386_pe_record_external_function (NAME);			\
+    }									\
+  while (0)
+
+/* Declare the type properly for any external libcall.  */
+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN) \
+  i386_pe_declare_function_type (FILE, XSTR (FUN, 0), 1)
+
+/* This says out to put a global symbol in the BSS section.  */
+#undef ASM_OUTPUT_ALIGNED_BSS
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))
+
+/* Output function declarations at the end of the file.  */
+#undef ASM_FILE_END
+#define ASM_FILE_END(FILE) \
+  i386_pe_asm_file_end (FILE)
+
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START " #"
+
+/* Don't assume anything about the header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+/* External function declarations.  */
+extern void i386_pe_record_external_function PARAMS ((const char *));
+extern void i386_pe_declare_function_type PARAMS ((FILE *, const char *, int));
+extern void i386_pe_record_exported_symbol PARAMS ((const char *, int));
+extern void i386_pe_asm_file_end PARAMS ((FILE *));
+
+/* For Win32 ABI compatibility */
+#undef DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* A bitfield declared as `int' forces `int' alignment for the struct.  */
+#undef PCC_BITFIELD_TYPE_MATTERS 
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+/* Enable alias attribute support.  */
+#ifndef SET_ASM_OP
+#define SET_ASM_OP "\t.set\t"
+#endif
+
+/* Note that there appears to be two different ways to support const
+   sections at the moment.  You can either #define the symbol
+   READONLY_DATA_SECTION (giving it some code which switches to the
+   readonly data section) or else you can #define the symbols
+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and
+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */
+
+#define USE_CONST_SECTION	1
+
+#define CONST_SECTION_ASM_OP	"\t.section\t.rdata,\"r\""
 /* The linker will take care of this, and having them causes problems with
    ld -r (specifically -rU).  */
 #define CTOR_LISTS_DEFINED_EXTERNALLY 1
 
-#define SET_ASM_OP	"\t.set\t"
 /* Output a definition (implements alias) */
 #define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)				\
 do									\
@@ -289,8 +249,6 @@ while (0)
 #define HOST_PTR_PRINTF "%p"
 #define HOST_PTR_AS_INT unsigned long
 
-#define PCC_BITFIELD_TYPE_MATTERS 1
-
 /* The following two flags are usually "off" for i386, because some non-gnu
    tools (for the i386) don't handle them.  However, we don't have that
    problem, so....  */
@@ -301,6 +259,17 @@ while (0)
 /* Unknown tags are also allowed.  */
 #define SDB_ALLOW_UNKNOWN_REFERENCES
 
+/* DWARF2 Unwinding doesn't work with exception handling yet.  */
+#define DWARF2_UNWIND_INFO 0
+/* MSVC returns structs of up to 8 bytes via registers. */
+
+#undef RETURN_IN_MEMORY
+#define RETURN_IN_MEMORY(TYPE) \
+  (TYPE_MODE (TYPE) == BLKmode || \
+     (AGGREGATE_TYPE_P (TYPE) && int_size_in_bytes(TYPE) > 8 ))
+
+#define ASM_LOAD_ADDR(loc, reg)   "     leal " #loc "," #reg "\n"
+
 /* The integer half of this list needs to be constant.  However, there's
    a lot of disagreement about what the floating point adjustments should
    be.  We pick one that works with gdb.  (The underlying problem is
@@ -323,47 +292,37 @@ while (0)
  : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+8 \
  : (-1))
 
-/* Define this macro if references to a symbol must be treated
-   differently depending on something about the variable or
-   function named by the symbol (such as what section it is in).  */
-
-#undef TARGET_ENCODE_SECTION_INFO
-#define TARGET_ENCODE_SECTION_INFO i386_pe_encode_section_info
-#undef  TARGET_STRIP_NAME_ENCODING
-#define TARGET_STRIP_NAME_ENCODING  i386_pe_strip_name_encoding_full
-
-/* Define this macro if in some cases global symbols from one translation
-   unit may not be bound to undefined symbols in another translation unit
-   without user intervention.  For instance, under Microsoft Windows
-   symbols must be explicitly imported from shared libraries (DLLs).  */
-#define MULTIPLE_SYMBOL_SPACES
-
-/* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */
-#define HANDLE_PRAGMA_PACK_PUSH_POP 1
-
-extern void i386_pe_unique_section PARAMS ((tree, int));
-#define TARGET_ASM_UNIQUE_SECTION i386_pe_unique_section
-
-#define SUPPORTS_ONE_ONLY 1
-
-/* Switch into a generic section.  */
-#define TARGET_ASM_NAMED_SECTION  default_pe_asm_named_section
-
-/* DWARF2 Unwinding doesn't work with exception handling yet.  */
-#define DWARF2_UNWIND_INFO 0
-
-/* Don't assume anything about the header files.  */
-#define NO_IMPLICIT_EXTERN_C
-
-/* MSVC returns structs of up to 8 bytes via registers. */
-
-#define DEFAULT_PCC_STRUCT_RETURN 0
-
-#undef RETURN_IN_MEMORY
-#define RETURN_IN_MEMORY(TYPE) \
-  (TYPE_MODE (TYPE) == BLKmode || \
-     (AGGREGATE_TYPE_P (TYPE) && int_size_in_bytes(TYPE) > 8 ))
-
+/* The global __fltused is necessary to cause the printf/scanf routines
+   for outputting/inputting floating point numbers to be loaded.  Since this
+   is kind of hard to detect, we just do it all the time.  */
+
+#ifdef ASM_FILE_START
+#undef ASM_FILE_START
+#endif
+#define ASM_FILE_START(FILE) \
+  do {  fprintf (FILE, "\t.file\t");                            \
+        output_quoted_string (FILE, dump_base_name);            \
+        fprintf (FILE, "\n");                                   \
+        fprintf (FILE, ".global\t__fltused\n");                 \
+  } while (0)
+
+#define EH_FRAME_IN_DATA_SECTION
+
+/* the following are OSF linker (not gld) specific... we don't want them */
+#undef HAS_INIT_SECTION
+#undef LD_INIT_SWITCH
+#undef LD_FINI_SWITCH
+
+/* The following are needed for us to be able to use winnt.c, but are not
+   otherwise meaningful to Interix.  (The functions that use these are
+   never called because we don't do DLLs.) */
+#define TARGET_NOP_FUN_DLLIMPORT 1
+#define I386_PE_STRIP_ENCODING(SYM_NAME) \
+  ((SYM_NAME) + ((SYM_NAME)[0] == '@' \
+		  ? ((SYM_NAME)[3] == '*' ? 4 : 3) : 0) \
+	      + ((SYM_NAME)[0] == '*' ? 1 : 0))
+
+#define drectve_section()  /* nothing */
 
 /* Objective C has its own packing rules...
    Objc tries to parallel the code in stor-layout.c at runtime	
