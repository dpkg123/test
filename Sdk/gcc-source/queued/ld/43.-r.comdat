This looks bigger than it really is due to having to add an argument to
a function in many places.

The objective is to, when processing a ld -r with COMDAT sections (at least
as generated by MSVC), pass them thru "unharmed".  They need to remain
separate sections, but with the same name.  This is particularly important
because MSVC does string pooling using .rdata COMDATS, and if the output
from ld -r converts a pooled string from COMDAT to ordinary, it can cause
a duplicate symbol collision with the same string coming in from some other
file.  This is done by recognizing the situation, and when creating the
output section pass flags indicating that the name is to be passed thru
unchanged.  (What it really means is "create a new section by this
name, even if one already exists".)  (Note: renameing the section
does not work correctly.  It causes problems when the result is reread
by ld when doing the final link!)

This same thing can happen if the compiler generates each function in
a separate section.

Fix emultempl/pe.em to recognize the situation and call the modified
functions with a flag indicating that the section is to be copied to
the output without renaming.  Note: indentation change needed, but
deferred until final application by Maintainer (please).

   ldlang: lang_output_section_statement_lookup: new arg. lang_add_section: new arg.
   Many files: lang_output_section_statement_lookup: provide default new arg.
   Many files: lang_add_section: provide default new arg.
   emultempl/pe.em: fix to recognize ld -r, COMDAT, call new functions.

diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/emultempl/beos.em ld/emultempl/beos.em
--- ld.orig/emultempl/beos.em	Wed May 22 15:28:09 2002
+++ ld/emultempl/beos.em	Wed May 22 17:56:51 2002
@@ -766,8 +766,8 @@ gld${EMULATION_NAME}_place_orphan (file,
   output_secname = xstrdup (secname);
   ps = strchr (output_secname + 1, '\$');
   *ps = 0;
-  os = lang_output_section_statement_lookup (output_secname);
-
+  os = lang_output_section_statement_lookup (output_secname, false);
+
   /* Find the '\$' wild statement for this section.  We currently require the
      linker script to explicitly mention "*(.foo\$)".
      FIXME: ppcpe.sc has .CRT\$foo in the .rdata section.  According to the
@@ -817,7 +817,7 @@ gld${EMULATION_NAME}_place_orphan (file,
      The sections still have to be sorted, but that has to wait until
      all such sections have been processed by us.  The sorting is done by
      sort_sections.  */
-  lang_add_section (&l->wild_statement.children, s, os, file);
+  lang_add_section (&l->wild_statement.children, s, os, file, false);
 
   return true;
 }
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/emultempl/elf32.em ld/emultempl/elf32.em
--- ld.orig/emultempl/elf32.em	Wed May 22 15:28:09 2002
+++ ld/emultempl/elf32.em	Wed May 22 17:57:00 2002
@@ -1080,7 +1080,7 @@ gld${EMULATION_NAME}_place_orphan (file,
 	{
 	  /* We already have an output section statement with this
 	     name, and its bfd section, if any, has compatible flags.  */
-	  lang_add_section (&os->children, s, os, file);
+	  lang_add_section (&os->children, s, os, file, false);
 	  return true;
 	}
     }
@@ -1212,7 +1212,7 @@ gld${EMULATION_NAME}_place_orphan (file,
   else
     address = NULL;
 
-  os = lang_enter_output_section_statement (secname, address, 0,
+  os = lang_enter_output_section_statement (secname, false, address, 0,
 					    (bfd_vma) 0,
 					    (etree_type *) NULL,
 					    (etree_type *) NULL,
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/emultempl/hppaelf.em ld/emultempl/hppaelf.em
--- ld.orig/emultempl/hppaelf.em	Wed May 22 15:28:09 2002
+++ ld/emultempl/hppaelf.em	Wed May 22 17:57:07 2002
@@ -203,7 +203,7 @@ hppaelf_add_stub_section (stub_sec_name,
 
   info.input_section = input_section;
   lang_list_init (&info.add);
-  lang_add_section (&info.add, stub_sec, os, stub_file);
+  lang_add_section (&info.add, stub_sec, os, stub_file, false);
 
   if (info.add.head == NULL)
     goto err_ret;
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/emultempl/mmo.em ld/emultempl/mmo.em
--- ld.orig/emultempl/mmo.em	Wed May 22 15:28:09 2002
+++ ld/emultempl/mmo.em	Wed May 22 17:57:13 2002
@@ -109,7 +109,7 @@ mmo_place_orphan (file, s)
      (regardless of whether the linker script lists it as input).  */
   if (os != NULL)
     {
-      lang_add_section (&os->children, s, os, file);
+      lang_add_section (&os->children, s, os, file, false);
       return true;
     }
 
@@ -137,6 +137,7 @@ mmo_place_orphan (file, s)
 
   os = lang_enter_output_section_statement (bfd_get_section_name (s->owner,
 								  s),
+					    false,
 					    NULL, 0,
 					    (bfd_vma) 0,
 					    (etree_type *) NULL,
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/emultempl/pe.em ld/emultempl/pe.em
--- ld.orig/emultempl/pe.em	Wed May 22 15:28:09 2002
+++ ld/emultempl/pe.em	Thu May 23 09:49:20 2002
@@ -2078,11 +2078,14 @@ gld_${EMULATION_NAME}_place_orphan (file
   if (os != NULL
       && (os->bfd_section == NULL
 	  || ((s->flags ^ os->bfd_section->flags)
-	      & (SEC_LOAD | SEC_ALLOC)) == 0))
+	      & (SEC_LOAD | SEC_ALLOC)) == 0)
+      && (!link_info.relocateable || (s->flags & SEC_LINK_ONCE) == 0))
     {
       /* We already have an output section statement with this
-	 name, and its bfd section, if any, has compatible flags.  */
-      lang_add_section (&add_child, s, os, file);
+	 name, and its bfd section, if any, has compatible flags.
+	 It also can't be "link once", as those must stay separate
+	 until final link to avoid duplicate symbol errors.  */
+      lang_add_section (&add_child, s, os, file, false);
     }
   else
     {
@@ -2096,12 +2099,18 @@ gld_${EMULATION_NAME}_place_orphan (file
       lang_statement_list_type add;
       etree_type *address;
 
+      place = NULL;
+      outsecname = xstrdup (hold_section_name);
+
+      /* We don't want to try to be fancy with comdats. */
+      if (!link_info.relocateable || (s->flags & SEC_LINK_ONCE) == 0)
+// Deferred indentation fix; indent when final apply is done
+    {
       /* Try to put the new output section in a reasonable place based
 	 on the section name and section flags.  */
 #define HAVE_SECTION(hold, name) \
 (hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)
 
-      place = NULL;
       if ((s->flags & SEC_ALLOC) == 0)
 	;
       else if ((s->flags & SEC_HAS_CONTENTS) == 0
@@ -2123,7 +2132,6 @@ gld_${EMULATION_NAME}_place_orphan (file
       /* Choose a unique name for the section.  This will be needed if
 	 the same section name appears in the input file with
 	 different loadable or allocatable characteristics.  */
-      outsecname = xstrdup (hold_section_name);
       if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
 	{
 	  unsigned int len;
@@ -2136,7 +2144,7 @@ gld_${EMULATION_NAME}_place_orphan (file
 	  i = 0;
 	  do
 	    {
-	      sprintf (newname + len, "%d", i);
+	      sprintf (newname + len, "?%d", i);
 	      ++i;
 	    }
 	  while (bfd_get_section_by_name (output_bfd, newname) != NULL);
@@ -2144,7 +2152,8 @@ gld_${EMULATION_NAME}_place_orphan (file
 	  free (outsecname);
 	  outsecname = newname;
 	}
-
+    }
+
       /* Start building a list of statements for this section.  */
       old = stat_ptr;
       stat_ptr = &add;
@@ -2180,13 +2189,21 @@ gld_${EMULATION_NAME}_place_orphan (file
 			      exp_nameop (NAME, "__section_alignment__"));
 	}
 
-      os = lang_enter_output_section_statement (outsecname, address, 0,
+      /* Output the section; be sure that if it's a relocateable link and
+	 COMDAT that we preserve the fact that it's a separate section, even
+	 if the name is the same as another section. */
+      os = lang_enter_output_section_statement (outsecname, 
+						link_info.relocateable &&
+						(s->flags & SEC_LINK_ONCE)!=0,
+						address, 0,
 						(bfd_vma) 0,
 						(etree_type *) NULL,
 						(etree_type *) NULL,
 						(etree_type *) NULL);
 
-      lang_add_section (&add_child, s, os, file);
+      lang_add_section (&add_child, s, os, file,
+					link_info.relocateable &&
+					(s->flags & SEC_LINK_ONCE)!=0);
 
       lang_leave_output_section_statement
 	((bfd_vma) 0, "*default*",
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/emultempl/ppc64elf.em ld/emultempl/ppc64elf.em
--- ld.orig/emultempl/ppc64elf.em	Wed May 22 15:28:09 2002
+++ ld/emultempl/ppc64elf.em	Wed May 22 17:59:29 2002
@@ -179,7 +179,7 @@ ppc_add_stub_section (stub_sec_name, inp
 
   info.input_section = input_section;
   lang_list_init (&info.add);
-  lang_add_section (&info.add, stub_sec, os, stub_file);
+  lang_add_section (&info.add, stub_sec, os, stub_file, false);
 
   if (info.add.head == NULL)
     goto err_ret;
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/emultempl/sunos.em ld/emultempl/sunos.em
--- ld.orig/emultempl/sunos.em	Wed May 22 15:28:09 2002
+++ ld/emultempl/sunos.em	Wed May 22 15:43:04 2002
@@ -719,7 +719,7 @@ gld${EMULATION_NAME}_before_allocation (
 
       /* Set the .text section to start at 0x20, not 0x2020.  FIXME:
          This is too magical.  */
-      os = lang_output_section_statement_lookup (".text");
+      os = lang_output_section_statement_lookup (".text", false);
       if (os->addr_tree == NULL)
 	os->addr_tree = exp_intop (0x20);
     }
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/ldexp.c ld/ldexp.c
--- ld.orig/ldexp.c	Wed May 22 15:28:09 2002
+++ ld/ldexp.c	Wed May 22 16:01:02 2002
@@ -468,7 +468,7 @@ fold_name (tree, current_section, alloca
 
 		      os = (lang_output_section_statement_lookup
 			    (bfd_get_section_name (output_bfd,
-						   output_section)));
+						   output_section), false));
 
 		      /* FIXME: Is this correct if this section is
 			 being linked with -R?  */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/ldgram.y ld/ldgram.y
--- ld.orig/ldgram.y	Wed May 22 15:28:10 2002
+++ ld/ldgram.y	Wed May 22 15:30:26 2002
@@ -833,7 +833,7 @@ section:	NAME 		{ ldlex_expression(); }
 		opt_at   	{ ldlex_popstate (); ldlex_script (); }
 		'{'
 			{
-			  lang_enter_output_section_statement($1, $3,
+			  lang_enter_output_section_statement($1, false, $3,
 							      sectype,
 							      0, 0, 0, $4);
 			}
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/ldlang.c ld/ldlang.c
--- ld.orig/ldlang.c	Wed May 22 15:28:10 2002
+++ ld/ldlang.c	Thu May 23 09:48:23 2002
@@ -68,7 +68,8 @@ static lang_input_statement_type *new_af
   PARAMS ((const char *, lang_input_file_enum_type, const char *, boolean));
 static lang_memory_region_type *lang_memory_default PARAMS ((asection *));
 static void lang_map_flags PARAMS ((flagword));
-static void init_os PARAMS ((lang_output_section_statement_type *));
+static void init_os PARAMS ((lang_output_section_statement_type *,
+                             boolean));
 static void exp_init_os PARAMS ((etree_type *));
 static void section_already_linked PARAMS ((bfd *, asection *, PTR));
 static struct bfd_hash_entry *already_linked_newfunc
@@ -592,8 +593,8 @@ lang_init ()
 				    lang_input_file_is_marker_enum,
 				    (char *) NULL);
   abs_output_section =
-    lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME);
-
+    lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME, false);
+
   abs_output_section->bfd_section = bfd_abs_section_ptr;
 
 }
@@ -713,12 +714,25 @@ lang_output_section_find (name)
 }
 
 lang_output_section_statement_type *
-lang_output_section_statement_lookup (name)
+lang_output_section_statement_lookup (name, newname)
      const char *const name;
-{
+     boolean newname;
+{
   lang_output_section_statement_type *lookup;
 
-  lookup = lang_output_section_find (name);
+  /* If we've been asked to treat this name as new even if it isn't,
+     just pretend we hadn't seen it before.  This is used for relocatable
+     links where the same section name must be output several times to
+     make downstream links work correctly. (E.g. PE comdats from MSVC) */
+  if (newname)
+    {
+      lookup = NULL;
+    }
+  else
+    {
+      lookup = lang_output_section_find (name);
+    }
+
   if (lookup == (lang_output_section_statement_type *) NULL)
     {
 
@@ -829,9 +843,10 @@ lang_map ()
 /* Initialize an output section.  */
 
 static void
-init_os (s)
+init_os (s, newsec)
      lang_output_section_statement_type *s;
-{
+     boolean newsec;
+{
   section_userdata_type *new;
 
   if (s->bfd_section != NULL)
@@ -843,9 +858,20 @@ init_os (s)
   new = ((section_userdata_type *)
 	 stat_alloc (sizeof (section_userdata_type)));
 
-  s->bfd_section = bfd_get_section_by_name (output_bfd, s->name);
-  if (s->bfd_section == (asection *) NULL)
-    s->bfd_section = bfd_make_section (output_bfd, s->name);
+  /* If we're forcing a new section (for ld -r that wants to preserve
+     sections, e.g. PE comdat), then just make a new output section from
+     scratch, unconditionally. Otherwise, find a match if there is one. */
+  if (newsec) 
+    {
+      s->bfd_section = bfd_make_section_anyway (output_bfd, s->name);
+    }
+  else
+    {
+      s->bfd_section = bfd_get_section_by_name (output_bfd, s->name);
+      if (s->bfd_section == (asection *) NULL)
+	s->bfd_section = bfd_make_section (output_bfd, s->name);
+    }
+
   if (s->bfd_section == (asection *) NULL)
     {
       einfo (_("%P%F: output format %s cannot represent section called %s\n"),
@@ -903,7 +929,7 @@ exp_init_os (exp)
 
 	    os = lang_output_section_find (exp->name.name);
 	    if (os != NULL && os->bfd_section == NULL)
-	      init_os (os);
+	      init_os (os, false);
 	  }
 	}
       break;
@@ -1118,12 +1144,13 @@ wildcardp (pattern)
    input file which holds SECTION.  */
 
 void
-lang_add_section (ptr, section, output, file)
+lang_add_section (ptr, section, output, file, newsec)
      lang_statement_list_type *ptr;
      asection *section;
      lang_output_section_statement_type *output;
      lang_input_statement_type *file;
-{
+     boolean newsec;
+{
   flagword flags;
   boolean discard;
 
@@ -1165,8 +1192,8 @@ lang_add_section (ptr, section, output, 
       flagword flags;
 
       if (output->bfd_section == NULL)
-	init_os (output);
-
+	init_os (output, newsec);
+
       first = ! output->bfd_section->linker_has_input;
       output->bfd_section->linker_has_input = 1;
 
@@ -1399,7 +1426,7 @@ output_section_callback (ptr, sec, secti
   if (before == NULL)
     lang_add_section (&ptr->children, section,
 		      (lang_output_section_statement_type *) output,
-		      file);
+		      file, false);
   else
     {
       lang_statement_list_type list;
@@ -1408,8 +1435,8 @@ output_section_callback (ptr, sec, secti
       lang_list_init (&list);
       lang_add_section (&list, section,
 			(lang_output_section_statement_type *) output,
-			file);
-
+			file, false);
+
       /* If we are discarding the section, LIST.HEAD will
 	 be NULL.  */
       if (list.head != NULL)
@@ -2134,13 +2161,13 @@ map_input_to_output_sections (s, target,
 	case lang_input_statement_enum:
 	  if (output_section_statement != NULL
 	      && output_section_statement->bfd_section == NULL)
-	    init_os (output_section_statement);
+	    init_os (output_section_statement, false);
 	  break;
 	case lang_assignment_statement_enum:
 	  if (output_section_statement != NULL
 	      && output_section_statement->bfd_section == NULL)
-	    init_os (output_section_statement);
-
+	    init_os (output_section_statement, false);
+
 	  /* Make sure that any sections mentioned in the assignment
 	     are initialized.  */
 	  exp_init_os (s->assignment_statement.exp);
@@ -2153,10 +2180,10 @@ map_input_to_output_sections (s, target,
 	  {
 	    lang_output_section_statement_type *os =
 	      lang_output_section_statement_lookup
-		(s->address_statement.section_name);
-
+		(s->address_statement.section_name, false);
+
 	    if (os->bfd_section == NULL)
-	      init_os (os);
+	      init_os (os, false);
 	    os->addr_tree = s->address_statement.address;
 	  }
 	  break;
@@ -3846,11 +3873,11 @@ lang_place_orphans ()
 			  info_msg (_("%P: no [COMMON] command, defaulting to .bss\n"));
 #endif
 			  default_common_section =
-			    lang_output_section_statement_lookup (".bss");
-
+			    lang_output_section_statement_lookup (".bss", false);
+
 			}
 		      lang_add_section (&default_common_section->children, s,
-					default_common_section, file);
+					default_common_section, file, false);
 		    }
 		}
 	      else if (ldemul_place_orphan (file, s))
@@ -3859,8 +3886,8 @@ lang_place_orphans ()
 		{
 		  lang_output_section_statement_type *os;
 
-		  os = lang_output_section_statement_lookup (s->name);
-		  lang_add_section (&os->children, s, os, file);
+		  os = lang_output_section_statement_lookup (s->name, false);
+		  lang_add_section (&os->children, s, os, file, false);
 		}
 	    }
 	}
@@ -4032,10 +4059,11 @@ topower (x)
 }
 
 lang_output_section_statement_type *
-lang_enter_output_section_statement (output_section_statement_name,
+lang_enter_output_section_statement (output_section_statement_name, newname,
 				     address_exp, sectype, block_value,
 				     align, subalign, ebase)
      const char *output_section_statement_name;
+     boolean newname;
      etree_type *address_exp;
      enum section_type sectype;
      bfd_vma block_value;
@@ -4047,8 +4075,8 @@ lang_enter_output_section_statement (out
 
   current_section =
    os =
-    lang_output_section_statement_lookup (output_section_statement_name);
-
+    lang_output_section_statement_lookup (output_section_statement_name, newname);
+
   /* Add this statement to tree.  */
 #if 0
   add_statement (lang_output_section_statement_enum,
@@ -4867,7 +4895,7 @@ lang_enter_overlay_section (name)
   struct overlay_list *n;
   etree_type *size;
 
-  lang_enter_output_section_statement (name, overlay_vma, normal_section,
+  lang_enter_output_section_statement (name, false, overlay_vma, normal_section,
 				       0, 0, 0, 0);
 
   /* If this is the first section, then base the VMA of future
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/ldlang.h ld/ldlang.h
--- ld.orig/ldlang.h	Wed May 22 15:28:10 2002
+++ ld/ldlang.h	Wed May 22 17:56:43 2002
@@ -380,6 +380,7 @@ extern void lang_set_flags PARAMS ((lang
 extern void lang_add_output PARAMS ((const char *, int from_script));
 extern lang_output_section_statement_type *lang_enter_output_section_statement
   PARAMS ((const char *output_section_statement_name,
+	   boolean newname,
 	   etree_type * address_exp,
 	   enum section_type sectype,
 	   bfd_vma block_value,
@@ -434,7 +435,8 @@ extern lang_input_statement_type *lang_a
 	   const char *target));
 extern void lang_add_keepsyms_file PARAMS ((const char *filename));
 extern lang_output_section_statement_type *
-  lang_output_section_statement_lookup PARAMS ((const char * const name));
+  lang_output_section_statement_lookup PARAMS ((const char * const name, 
+						boolean newname));
 extern void ldlang_add_undef PARAMS ((const char *const name));
 extern void lang_add_output_format PARAMS ((const char *, const char *,
 					    const char *, int from_script));
@@ -457,7 +459,8 @@ extern void lang_leave_group PARAMS ((vo
 extern void lang_add_section
   PARAMS ((lang_statement_list_type *ptr, asection *section,
 	   lang_output_section_statement_type *output,
-	   lang_input_statement_type *file));
+	   lang_input_statement_type *file,
+	   boolean newsec));
 extern void lang_new_phdr
   PARAMS ((const char *, etree_type *, boolean, boolean, etree_type *,
 	   etree_type *));
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files ld.orig/mri.c ld/mri.c
--- ld.orig/mri.c	Wed May 22 15:28:10 2002
+++ ld/mri.c	Wed May 22 15:31:27 2002
@@ -234,7 +234,7 @@ mri_draw_tree ()
 	  if (base == 0)
 	    base = p->vma ? p->vma : exp_nameop (NAME, ".");
 
-	  lang_enter_output_section_statement (p->name, base,
+	  lang_enter_output_section_statement (p->name, false, base,
 					       p->ok_to_load ? 0 : noload_section,
 					       1, align, subalign,
 					       (etree_type *) NULL);
