This is a hack fix until the CVS is corrected.

--- /C/CVS/binutils.baseline/src/expect/exp_tty.c	Fri Sep  7 23:26:30 2001
+++ exp_tty.c	Tue Feb  5 11:55:15 2002
@@ -299,6 +299,7 @@ int *len;	/* current and new length of s
 static char exec_cmd[] = "exec";
 static char stty_cmd[] = "/bin/stty";
 
+#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION < 3)
 static int		/* returns TCL_whatever */
 exec_stty(interp,argc,argv,devtty)
 Tcl_Interp *interp;
@@ -334,11 +335,7 @@ int devtty;		/* if true, redirect to /de
 	/* and I don't know any other way of doing it */
 	Tcl_SetVar(interp,"errorCode","NONE",0);
 
-#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION < 3)
 	rc = Tcl_ExecCmd((ClientData)0,interp,argc+1+devtty,new_argv);
-#else
-	rc = Tcl_ExecObjCmd((ClientData)0,interp,argc+1+devtty,Tcl_NewStringObj(new_argv,-1));
-#endif
 	ckfree((char *)new_argv);
 
 	/* if stty-reads-stdout, stty will fail since Exec */
@@ -353,6 +350,61 @@ int devtty;		/* if true, redirect to /de
 #endif
 	return TCL_OK;
 }
+
+#else
+
+static int              /* returns TCL_whatever */
+exec_stty(interp,argc,argv,devtty)
+Tcl_Interp *interp;
+int argc;
+char **argv;
+int devtty;             /* if true, redirect to /dev/tty */
+{
+        char **new_argv;
+        int i;
+        int rc;
+
+        Tcl_Obj *cmdObj = Tcl_NewStringObj("",0);
+        Tcl_IncrRefCount(cmdObj);
+
+        Tcl_AppendStringsToObj(cmdObj,"exec /bin/stty",(char *)0);
+        for (i=1;i<argc;i++) {
+            Tcl_AppendStringsToObj(cmdObj," ",argv[i],(char *)0);
+        }
+        if (devtty) Tcl_AppendStringsToObj(cmdObj,
+#ifdef STTY_READS_STDOUT
+                " >/dev/tty",
+#else
+                " </dev/tty",
+#endif
+                (char *)0);
+
+        Tcl_ResetResult(interp);
+
+        /*
+         * normally, I wouldn't set one of Tcl's own variables, but in this
+         * case, I only want to see if Tcl resets it to non-NONE, and I don't
+         * know any other way of doing it
+         */
+
+        Tcl_SetVar(interp,"errorCode","NONE",0);
+        rc = Tcl_EvalObjEx(interp,cmdObj,TCL_EVAL_DIRECT);
+
+        Tcl_DecrRefCount(cmdObj);
+
+        /* if stty-reads-stdout, stty will fail since Exec */
+        /* will detect the stderr.  Only by examining errorCode */
+        /* can we tell if a real error occurred. */
+
+#ifdef STTY_READS_STDOUT
+        if (rc == TCL_ERROR) {
+                char *ec = Tcl_GetVar(interp,"errorCode",TCL_GLOBAL_ONLY);
+                if (ec && !streq(ec,"NONE")) return TCL_ERROR;
+        }
+#endif
+        return TCL_OK;
+}
+#endif
 
 /*ARGSUSED*/
 static int
