@@ -922,8 +922,10 @@ int
 tc_i386_fix_adjustable(fixP)
      fixS * fixP;
 {
-#ifdef OBJ_ELF
+#if defined(OBJ_ELF) || defined(TE_PE)
   /* Prevent all adjustments to global symbols. */
+  /* PE doesn't make everything section relative, and it really botches
+     up dynamic linking to do so! */
   if (S_IS_EXTERN (fixP->fx_addsy))
     return 0;
   if (S_IS_WEAK (fixP->fx_addsy))
@@ -933,6 +935,7 @@ tc_i386_fix_adjustable(fixP)
   if (fixP->fx_r_type == BFD_RELOC_386_GOTOFF
       || fixP->fx_r_type == BFD_RELOC_386_PLT32
       || fixP->fx_r_type == BFD_RELOC_386_GOT32
+      || fixP->fx_r_type == BFD_RELOC_RVA
       || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
       || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
     return 0;
@@ -2468,7 +2471,8 @@ md_assemble (line)
 					== O_subtract))))
 			  {
 			    r_type = BFD_RELOC_386_GOTPC;
-			    i.imms[n]->X_add_number += 3;
+			    i.imms[n]->X_add_number += insn_size;  // DYNLINK
+			    pcrel = true; // benign
 			  }
 #endif
 			fix_new_exp (frag_now, p - frag_now->fr_literal, size,
@@ -2512,6 +2516,8 @@ i386_is_reg (reg_string)
     return 1;
 }
 
+enum bfd_reloc_code_real special_reloc;
+
 static int i386_immediate PARAMS ((char *));
 
 static int
@@ -2537,61 +2543,9 @@ i386_immediate (imm_start)
   save_input_line_pointer = input_line_pointer;
   input_line_pointer = imm_start;
 
-#ifndef LEX_AT
-  {
-    /*
-     * We can have operands of the form
-     *   <symbol>@GOTOFF+<nnn>
-     * Take the easy way out here and copy everything
-     * into a temporary buffer...
-     */
-    register char *cp;
-
-    cp = strchr (input_line_pointer, '@');
-    if (cp != NULL)
-      {
-	char *tmpbuf;
-	int len = 0;
-	int first;
-
-	/* GOT relocations are not supported in 16 bit mode */
-	if (flag_16bit_code)
-	  as_bad (_("GOT relocations not supported in 16 bit mode"));
-
-	if (GOT_symbol == NULL)
-	  GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
-
-	if (strncmp (cp + 1, "PLT", 3) == 0)
-	  {
-	    i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
-	    len = 3;
-	  }
-	else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
-	  {
-	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
-	    len = 6;
-	  }
-	else if (strncmp (cp + 1, "GOT", 3) == 0)
-	  {
-	    i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
-	    len = 3;
-	  }
-	else
-	  as_bad (_("Bad reloc specifier in expression"));
-
-	/* Replace the relocation token with ' ', so that errors like
-	   foo@GOTOFF1 will be detected.  */
-	first = cp - input_line_pointer;
-	tmpbuf = (char *) alloca (strlen(input_line_pointer));
-	memcpy (tmpbuf, input_line_pointer, first);
-	tmpbuf[first] = ' ';
-	strcpy (tmpbuf + first + 1, cp + 1 + len);
-	input_line_pointer = tmpbuf;
-       }
-  }
-#endif
-
+  special_reloc = NO_RELOC;
   exp_seg = expression (exp);
+  i.disp_reloc[this_operand] = special_reloc;
 
   SKIP_WHITESPACE ();
   if (*input_line_pointer)
@@ -2715,7 +2670,6 @@ i386_displacement (disp_start, disp_end)
 
   exp = &disp_expressions[i.disp_operands];
   i.disps[this_operand] = exp;
-  i.disp_reloc[this_operand] = NO_RELOC;
   i.disp_operands++;
   save_input_line_pointer = input_line_pointer;
   input_line_pointer = disp_start;
@@ -2766,61 +2720,10 @@ i386_displacement (disp_start, disp_end)
     *displacement_string_end = '0';
     }
 #endif
-#ifndef LEX_AT
-  {
-    /*
-     * We can have operands of the form
-     *   <symbol>@GOTOFF+<nnn>
-     * Take the easy way out here and copy everything
-     * into a temporary buffer...
-     */
-    register char *cp;
-
-    cp = strchr (input_line_pointer, '@');
-    if (cp != NULL)
-      {
-	  char *tmpbuf;
-	  int len = 0;
-	  int first;
-
-	 /* GOT relocations are not supported in 16 bit mode */
-	 if (flag_16bit_code)
-	   as_bad (_("GOT relocations not supported in 16 bit mode"));
-
-	  if (GOT_symbol == NULL)
-	    GOT_symbol = symbol_find_or_make (GLOBAL_OFFSET_TABLE_NAME);
-
-	  if (strncmp (cp + 1, "PLT", 3) == 0)
-	    {
-	      i.disp_reloc[this_operand] = BFD_RELOC_386_PLT32;
-	      len = 3;
-	    }
-	  else if (strncmp (cp + 1, "GOTOFF", 6) == 0)
-	    {
-	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOTOFF;
-	      len = 6;
-	    }
-	  else if (strncmp (cp + 1, "GOT", 3) == 0)
-	    {
-	      i.disp_reloc[this_operand] = BFD_RELOC_386_GOT32;
-	      len = 3;
-	    }
-	  else
-	    as_bad (_("Bad reloc specifier in expression"));
-
-	  /* Replace the relocation token with ' ', so that errors like
-	     foo@GOTOFF1 will be detected.  */
-	  first = cp - input_line_pointer;
-	  tmpbuf = (char *) alloca (strlen(input_line_pointer));
-	  memcpy (tmpbuf, input_line_pointer, first);
-	  tmpbuf[first] = ' ';
-	  strcpy (tmpbuf + first + 1, cp + 1 + len);
-	  input_line_pointer = tmpbuf;
-	}
-  }
-#endif
 
+    special_reloc = NO_RELOC;
     exp_seg = expression (exp);
+    i.disp_reloc[this_operand] = special_reloc;
 
 #ifdef BFD_ASSEMBLER
     /* We do this to make sure that the section symbol is in
@@ -3346,6 +3250,64 @@ i386_intel_operand (operand_string, got_
   return 1;
 }
 
+#ifdef LEX_AT
+/*
+ * We can have a name of the form
+ *   <symbol>@GOTOFF
+ * Strip off the @GOTOFF (or whatever) and set a global giving the
+ * relocation type.  This is called from within expr(), and we
+ * don't have access to the per-operand relocations there, so we use
+ * (yetch) a global to pass it back.  (If expr() is ever rewritten...)
+ *
+ * Note: @ can be an ordinary identifier character; only if the name is
+ * suffixed by EXACTLY one of the reserved operators do we recognize
+ * it.  In any other case, it's just passed thru like an ordinary 
+ * identifier.
+ */
+
+int
+i386_parse_name (name, expressionP)
+  char *name;
+  expressionS *expressionP;
+{
+    register char *cp;
+
+    if ((cp = strrchr (name,'@')) == NULL)
+       return 0;
+
+    if (strcmp(cp+1, "PLT") == 0) 
+      {
+	special_reloc = BFD_RELOC_386_PLT32;
+      } 
+    else if (strcmp(cp+1, "GOTOFF") == 0) 
+      {
+	special_reloc = BFD_RELOC_386_GOTOFF;
+      }
+    else if (strcmp(cp+1, "GOT") == 0) 
+      {
+	special_reloc = BFD_RELOC_386_GOT32;
+      } 
+    else if (strcmp(cp+1, "IMAGEBASE") == 0) 
+      {
+	special_reloc = BFD_RELOC_RVA;
+      } 
+    else
+      return 0;
+
+    /* GOT relocations are not supported in 16 bit mode */
+    if (flag_16bit_code)
+      as_bad (_("GOT relocations not supported in 16 bit mode"));
+
+    if(special_reloc != BFD_RELOC_RVA && !GOT_symbol)
+      GOT_symbol = symbol_find_or_make(GLOBAL_OFFSET_TABLE_NAME);
+
+    *cp = '\0';
+
+    return 0;
+}
+#endif
+ 
+
 /* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero
    on error. */
 
@@ -3680,6 +3642,58 @@ i386_operand (operand_string)
     }
   return 1;			/* normal return */
 }
+
+void
+i386_parse_cons_expression (exp)
+     expressionS *exp;
+{
+  /* All we do different here from the normal is initialize special_reloc,
+     so we can pick it up below in i386_cons_fix_new. */
+  special_reloc = NO_RELOC;
+  expression(exp);
+}
+
+void
+i386_cons_fix_new (frag, where, size, exp)
+     fragS *frag;
+     int where;
+     int size;
+     expressionS *exp;
+{
+  unsigned int rel_type;
+
+  bfd_reloc_code_real_type r;
+
+  /* now that we know that special_reloc is properly initialized, we check
+     it; if it got set we have a foo@PLT type relocation.  Else, just like
+     the generic stuff (BFD style) */
+  if (special_reloc != NO_RELOC)
+    {
+       r = special_reloc;
+       if (size != 4)
+          as_bad (_("unsupported PIC BFD relocation size %u"), size);
+    }
+  else switch (size)
+    {
+    case 1:
+      r = BFD_RELOC_8;
+      break;
+    case 2:
+      r = BFD_RELOC_16;
+      break;
+    case 4:
+      r = BFD_RELOC_32;
+      break;
+    case 8:
+      r = BFD_RELOC_64;
+      break;
+    default:
+      as_bad (_("unsupported BFD relocation size %u"), size);
+      r = BFD_RELOC_32;
+      break;
+    }
+  fix_new_exp (frag, where, size, exp, 0, r);
+}
 
 /*
  *			md_estimate_size_before_relax()
@@ -3906,7 +3920,7 @@ md_apply_fix3 (fixP, valp, seg)
   register char *p = fixP->fx_where + fixP->fx_frag->fr_literal;
   valueT value = *valp;
 
-#if defined (BFD_ASSEMBLER) && !defined (TE_Mach)
+#if defined (BFD_ASSEMBLER) && !defined (TE_Mach) /* [ */
   if (fixP->fx_pcrel)
     {
       switch (fixP->fx_r_type)
@@ -3926,9 +3940,12 @@ md_apply_fix3 (fixP, valp, seg)
 	}
     }
 
+#ifndef PUSHMI_PULLU /* [ */
   /*
    * This is a hack.  There should be a better way to
-   * handle this.
+   * handle this.  This covers for the fact that bfd_install_relocation
+   * will subtract the current location (for partial_inplace, PC relative
+   * relocations); see more below.
    */
   if ((fixP->fx_r_type == BFD_RELOC_32_PCREL
        || fixP->fx_r_type == BFD_RELOC_16_PCREL
@@ -3959,69 +3976,62 @@ md_apply_fix3 (fixP, valp, seg)
 	  value += fixP->fx_where + fixP->fx_frag->fr_address;
 	}
 #endif
+
+#ifdef PUSHMI_PULLU
 #if defined (OBJ_COFF) && defined (TE_PE)
       /* For some reason, the PE format does not store a section
          address offset for a PC relative symbol.  */
       if (S_GET_SEGMENT (fixP->fx_addsy) != seg)
 	value += md_pcrel_from (fixP);
 #endif
+#endif
     }
+#endif /* ] */
 
   /* Fix a few things - the dynamic linker expects certain values here,
      and we must not dissappoint it. */
+#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) || defined (TE_PE_DYN) /* [ */
+  if (fixP->fx_addsy
 #if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
-  if (OUTPUT_FLAVOR == bfd_target_elf_flavour
-      && fixP->fx_addsy)
+      && OUTPUT_FLAVOR == bfd_target_elf_flavour
+#endif
+  )
     switch (fixP->fx_r_type) {
     case BFD_RELOC_386_PLT32:
+#ifdef TE_PE_DYN
+      /* On PE, to get the right value in the .o file, we need to fake out 
+	 _bfd_install_relocaction, see above.  */
+      value += fixP->fx_where + fixP->fx_frag->fr_address;
+#else
       /* Make the jump instruction point to the address of the operand.  At
 	 runtime we merely add the offset to the actual PLT entry. */
       value = 0xfffffffc;
+#endif
       break;
+
+#ifdef TE_PE_DYN
+    case BFD_RELOC_32:
+      /* On PE, to get the right value in the .o file, we need to fake out 
+	 _bfd_install_relocaction, see above.
+	 In this case, we're looking to see if this might be transformed
+	 into a GOTPC, later*/
+      if (GOT_symbol == NULL || fixP->fx_addsy != GOT_symbol)
+	  break;
+      /* drop thru */
+#endif
+
     case BFD_RELOC_386_GOTPC:
-/*
- *   This is tough to explain.  We end up with this one if we have
- * operands that look like "_GLOBAL_OFFSET_TABLE_+[.-.L284]".  The goal
- * here is to obtain the absolute address of the GOT, and it is strongly
- * preferable from a performance point of view to avoid using a runtime
- * relocation for this.  The actual sequence of instructions often look
- * something like:
- *
- * 	call	.L66
- * .L66:
- * 	popl	%ebx
- * 	addl	$_GLOBAL_OFFSET_TABLE_+[.-.L66],%ebx
- *
- *   The call and pop essentially return the absolute address of
- * the label .L66 and store it in %ebx.  The linker itself will
- * ultimately change the first operand of the addl so that %ebx points to
- * the GOT, but to keep things simple, the .o file must have this operand
- * set so that it generates not the absolute address of .L66, but the
- * absolute address of itself.  This allows the linker itself simply
- * treat a GOTPC relocation as asking for a pcrel offset to the GOT to be
- * added in, and the addend of the relocation is stored in the operand
- * field for the instruction itself.
- *
- *   Our job here is to fix the operand so that it would add the correct
- * offset so that %ebx would point to itself.  The thing that is tricky is
- * that .-.L66 will point to the beginning of the instruction, so we need
- * to further modify the operand so that it will point to itself.
- * There are other cases where you have something like:
- *
- * 	.long	$_GLOBAL_OFFSET_TABLE_+[.-.L66]
- *
- * and here no correction would be required.  Internally in the assembler
- * we treat operands of this form as not being pcrel since the '.' is
- * explicitly mentioned, and I wonder whether it would simplify matters
- * to do it this way.  Who knows.  In earlier versions of the PIC patches,
- * the pcrel_adjust field was used to store the correction, but since the
- * expression is not pcrel, I felt it would be confusing to do it this way.
- */
-      value -= 1;
+#ifdef TE_PE_DYN
+      /* On PE, to get the right value in the .o file, we need to fake out
+	 _bfd_install_relocaction, see above.  */
+      value += fixP->fx_where + fixP->fx_frag->fr_address;
+#endif
       break;
+
     case BFD_RELOC_386_GOT32:
       value = 0; /* Fully resolved at runtime.  No addend. */
       break;
+
     case BFD_RELOC_386_GOTOFF:
       break;
 
@@ -4033,9 +4043,9 @@ md_apply_fix3 (fixP, valp, seg)
     default:
       break;
     }
-#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) */
+#endif /* defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) ] */
   *valp = value;
-#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach) */
+#endif /* defined (BFD_ASSEMBLER) && !defined (TE_Mach) ] */
   md_number_to_chars (p, value, fixP->fx_size);
 
   return 1;
@@ -4066,7 +4076,7 @@ md_chars_to_number (con, nbytes)
    is stored in *sizeP .  An error message is returned, or NULL on OK.  */
 char *
 md_atof (type, litP, sizeP)
-     char type;
+     int type;
      char *litP;
      int *sizeP;
 {
@@ -4096,7 +4106,7 @@ md_atof (type, litP, sizeP)
       *sizeP = 0;
       return _("Bad call to md_atof ()");
     }
-  t = atof_ieee (input_line_pointer, type, words);
+  t = atof_ieee (input_line_pointer, (char)type, words);
   if (t)
     input_line_pointer = t;
 
@@ -4256,7 +4266,11 @@ symbolS *
 md_undefined_symbol (name)
      char *name;
 {
-  if (*name == '_' && *(name+1) == 'G'
+	/* slightly strange coding, but this makes changing the string
+	   constant work right. */
+	if (name[0] == GLOBAL_OFFSET_TABLE_NAME[0]
+	 && name[1] == GLOBAL_OFFSET_TABLE_NAME[1]
+	 && name[2] == GLOBAL_OFFSET_TABLE_NAME[2]
 	    && strcmp(name, GLOBAL_OFFSET_TABLE_NAME) == 0)
 	  {
 	    if (!GOT_symbol)
@@ -4415,6 +4429,20 @@ tc_gen_reloc (section, fixp)
       assert (rel->howto != NULL);
     }
 
+#ifndef PUSHMI_PULLU
+  /*
+   * Ohhh, this is ugly.  The problem is that if this is a local global
+   * symbol, the relocation will entirely be performed at link time, not
+   * at assembly time.  bfd_install_reloc doesn't know about this sort
+   * of thing, and as a result we need to fake it out here.
+   *
+   * Note that if you change this as part of cleaning up the apalling
+   * mess of complementary adds/subtracts of which this is part, that
+   * bfd:coff_i386_reloc may need attention too.
+   */
+  if (S_IS_EXTERN (fixp->fx_addsy) && !S_IS_COMMON(fixp->fx_addsy))
+    rel->addend -= symbol_get_bfdsym (fixp->fx_addsy)->value;
+#endif
   return rel;
 }
 
