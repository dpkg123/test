This is the patch to support Elf style (dlopen/dlclose) dynamic linking.
I've used DYNAMIC_LINKING to flag the changes that are really about
dynamic linking.  The ones not bracketed with these are housekeeping
changes that are required to make this patch work, but which could
be left that way if dynamic linking was turned off.  (In a few places,
I've used comments rather than ifdefs because in principle it would
be conditional, there are logistical reasons that make it messy.

This also includes support for NT style weak symbols (weak aliases).
It would be possible to tease the two apart, but VERY difficult to
do so if the weak symbols patch was to be applied first, and not
really worth it if it's to be applied second.  (The real work would be
limited to cofflink.c)

Open issue: the rel.internal counting stuff doesn't take into account
the possiblity of discarding a LINK_ONCE section, which throws the count
off.  It's easily worked around by having ld.so ignore 0 relocatiion.
However, there must be a better fix (the counting code needs to know
the section is to be discarded.)

There is a parallel patch to include.

Donn


THERE ARE LOTS OF // comments to work thru, and some proposed discarded code.

diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/bfd-in.h bfd/bfd-in.h
--- bfd.pre.dynlink/bfd-in.h	Wed Feb  6 10:10:02 2002
+++ bfd/bfd-in.h	Wed Feb  6 17:42:50 2002
@@ -270,7 +270,10 @@ bfd_format;
  
 /* The sections in this BFD specify a memory page.  */
 #define HAS_LOAD_PAGE 0x1000
-
+
+/* This flag indicates that the BFD has the NO-LINK flag set */
+#define NO_LINK 0x2000
+
 /* Symbols and relocation.  */
 
 /* A count of carsyms (canonical archive symbols).  */
@@ -701,6 +704,12 @@ extern boolean bfd_m68klinux_size_dynami
   PARAMS ((bfd *, struct bfd_link_info *));
 extern boolean bfd_sparclinux_size_dynamic_sections
   PARAMS ((bfd *, struct bfd_link_info *));
+
+/* PE/COFF shared library support routines for the linker.  */
+extern boolean bfd_coff_size_dynamic_sections
+  PARAMS ((bfd *, const char *, const char *, const char *,
+	   const char * const *, struct bfd_link_info *, struct sec **,
+	   struct bfd_elf_version_tree *));
 
 /* mmap hacks */
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/bfd.c bfd/bfd.c
--- bfd.pre.dynlink/bfd.c	Wed Feb  6 10:10:02 2002
+++ bfd/bfd.c	Wed Feb  6 10:11:27 2002
@@ -145,6 +145,13 @@ CODE_FRAGMENT
 .     be used only for archive elements.  *}
 .  int archive_pass;
 .
+.{* #ifdef DYNAMIC_LINKING *}
+.    {* Used by some backends for dynamic link private data; independent
+.       of per-format private data. *}
+.    struct dynamic_info *dynamic_info;  {* used by shared libs only *}
+.    bfd_vma *local_got_offsets; {* used if dynamic linking on all bfds *}
+.{* #endif *}
+.
 .  {* Used by the back end to hold private data.  *}
 .  union
 .    {
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/binary.c bfd/binary.c
--- bfd.pre.dynlink/binary.c	Wed Feb  6 10:10:02 2002
+++ bfd/binary.c	Wed Feb  6 10:11:27 2002
@@ -348,6 +348,7 @@ const bfd_target binary_vec =
 {
   "binary",			/* name */
   bfd_target_unknown_flavour,	/* flavour */
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* byteorder */
   BFD_ENDIAN_UNKNOWN,		/* header_byteorder */
   EXEC_P,			/* object_flags */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/coff-alpha.c bfd/coff-alpha.c
--- bfd.pre.dynlink/coff-alpha.c	Wed Feb  6 10:10:02 2002
+++ bfd/coff-alpha.c	Wed Feb  6 10:11:27 2002
@@ -2361,6 +2361,7 @@ const bfd_target ecoffalpha_little_vec =
 {
   "ecoff-littlealpha",		/* name */
   bfd_target_ecoff_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_LITTLE,		/* data byte order is little */
   BFD_ENDIAN_LITTLE,		/* header byte order is little */
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/coff-i386.c bfd/coff-i386.c
--- bfd.pre.dynlink/coff-i386.c	Wed Feb  6 10:10:02 2002
+++ bfd/coff-i386.c	Wed Feb  6 10:11:27 2002
@@ -323,7 +323,117 @@ static reloc_howto_type howto_table[] =
 	 true,			/* partial_inplace */
 	 0xffffffff,		/* src_mask */
 	 0xffffffff,		/* dst_mask */
-	 PCRELOFFSET)		/* pcrel_offset */
+	 PCRELOFFSET),		/* pcrel_offset */
+
+#ifdef DYNAMIC_LINKING /* [ */
+  {025,0,0,0,0,0,0,0,"",0,0,0,0},
+  {026,0,0,0,0,0,0,0,"",0,0,0,0},
+  {027,0,0,0,0,0,0,0,"",0,0,0,0},
+  HOWTO (R_GNU_GOT32,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 false,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GOT32",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_PLT32,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 true,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "PLT32",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_COPY,		/* type 032 */                                  
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 false,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "COPY",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_GLOB_DAT,	/* type 033 */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 false,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GLOB_DAT",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_JUMP_SLOT,	/* type 034 */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 true,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "JUMP_SLOT",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_RELATIVE,	/* type 035 */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 true,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "RELATIVE",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_GOTOFF,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 false,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GOTOFF",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_GNU_GOTPC,		/* type */                                 
+	 0,			/* rightshift */                           
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */ 
+	 32,			/* bitsize */                   
+	 true,			/* pc_relative */                          
+	 0,			/* bitpos */                               
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_i386_reloc,	/* special_function */                     
+	 "GOTPC",		/* name */                                 
+	 true,			/* partial_inplace */                      
+	 0xffffffff,		/* src_mask */                             
+	 0xffffffff,		/* dst_mask */                             
+	 PCRELOFFSET),		/* pcrel_offset */
+#endif /* ] */
 };
 
 /* Turn a howto into a reloc  nunmber */
@@ -487,6 +597,13 @@ coff_i386_reloc_type_lookup (abfd, code)
       return howto_table + R_RELBYTE;
     case BFD_RELOC_8_PCREL:
       return howto_table + R_PCRBYTE;
+#ifdef DYNAMIC_LINKING
+    case BFD_RELOC_386_GOT32:
+    case BFD_RELOC_386_PLT32:
+    case BFD_RELOC_386_GOTOFF:
+    case BFD_RELOC_386_GOTPC:
+      return howto_table + (R_GNU_GOT32 + (code - BFD_RELOC_386_GOT32));
+#endif
     default:
       BFD_FAIL ();
       return 0;
@@ -495,6 +612,32 @@ coff_i386_reloc_type_lookup (abfd, code)
 
 #define coff_rtype_to_howto coff_i386_rtype_to_howto
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+static boolean coff_i386_link_create_dynamic_sections 
+      PARAMS (( bfd *, struct bfd_link_info *));
+static boolean coff_i386_check_relocs 
+      PARAMS (( bfd *, struct bfd_link_info *, asection *, 
+		const struct internal_reloc *relocs));
+static boolean coff_i386_adjust_dynamic_symbol 
+      PARAMS (( bfd*, struct bfd_link_info *, struct coff_link_hash_entry *,
+		boolean));
+static boolean coff_i386_finish_dynamic_symbol 
+      PARAMS (( bfd *, struct bfd_link_info *, struct coff_link_hash_entry *,
+                struct internal_syment *));
+static boolean coff_i386_finish_dynamic_sections 
+      PARAMS (( bfd *, struct bfd_link_info *));
+
+#define coff_backend_link_create_dynamic_sections \
+             coff_i386_link_create_dynamic_sections
+#define coff_backend_check_relocs coff_i386_check_relocs
+#define coff_backend_adjust_dynamic_symbol coff_i386_adjust_dynamic_symbol
+#define coff_backend_size_dynamic_sections pei_generic_size_dynamic_sections
+#define coff_backend_finish_dynamic_symbol coff_i386_finish_dynamic_symbol
+#define coff_backend_finish_dynamic_sections coff_i386_finish_dynamic_sections
+
+#endif /* ] */
+
 #ifdef TARGET_UNDERSCORE
 
 /* If i386 gcc uses underscores for symbol names, then it does not use
@@ -520,6 +663,1019 @@ coff_i386_is_local_label_name (abfd, nam
 
 #include "coffcode.h"
 
+
+#ifdef DYNAMIC_LINKING /* [ */
+
+/* The size in bytes of an entry in the procedure linkage table.  */
+
+#define PLT_ENTRY_SIZE 16
+
+/* The first entry in a (PIC) procedure linkage table look like this.  */
+
+static const bfd_byte coff_i386_pic_plt0_entry[PLT_ENTRY_SIZE] =
+{
+  0xff, 0xb3, 4, 0, 0, 0,	/* pushl 4(%ebx) */
+  0xff, 0xa3, 8, 0, 0, 0,	/* jmp *8(%ebx) */
+  0, 0, 0, 0			/* pad out to 16 bytes.  */
+};
+
+/* Subsequent entries in a (PIC) procedure linkage table look like this.  */
+
+static const bfd_byte coff_i386_pic_plt_entry[PLT_ENTRY_SIZE] =
+{
+  0xff, 0xa3,	/* jmp *offset(%ebx) */
+  0, 0, 0, 0,	/* replaced with offset of this symbol in .got.  */
+  0x68,		/* pushl immediate */
+  0, 0, 0, 0,	/* replaced with offset into relocation table.  */
+  0xe9,		/* jmp relative */
+  0, 0, 0, 0	/* replaced with offset to start of .plt.  */
+};
+
+  /* Since the spelling of _DYNAMIC et. al. changes, this becomes architecture
+     dependent */
+
+#ifdef TARGET_UNDERSCORE
+#define DYNAMIC_SYM "__DYNAMIC"
+#define GOT_SYM     "__GLOBAL_OFFSET_TABLE_"
+#define PLT_SYM     "__PROCEDURE_LINKAGE_TABLE_"
+#else
+#define DYNAMIC_SYM "_DYNAMIC"
+#define GOT_SYM     "_GLOBAL_OFFSET_TABLE_"
+#define PLT_SYM     "_PROCEDURE_LINKAGE_TABLE_"
+#endif
+
+static boolean
+coff_i386_link_create_dynamic_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  flagword flags;
+  register asection *s;
+  struct coff_link_hash_entry *h = NULL;
+
+  /* We need to create .plt, .rel.plt, .got, .got.plt, .dynbss, and
+     .rel.bss sections.  */
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED);
+
+  s = bfd_make_section (abfd, ".plt");
+  coff_hash_table (info)->splt = s;
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+				  (flags | SEC_CODE | SEC_READONLY))
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return false;
+
+    /* Define the symbol __PROCEDURE_LINKAGE_TABLE_ at the start of the
+       .plt section.  */
+    if (! (bfd_coff_link_add_one_symbol
+	   (info, abfd, PLT_SYM, BSF_GLOBAL, s,
+	    (bfd_vma) 0, (const char *) NULL, 
+	    false, false,
+	    (struct bfd_link_hash_entry **) &h)))
+      return false;
+    h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+    h->type = 0;
+
+    if (info->shared
+	&& ! _bfd_coff_link_record_dynamic_symbol (info, h))
+      return false;
+
+  s = bfd_make_section (abfd, ".rel.plt");
+  coff_hash_table (info)->srelplt = s;
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY | SEC_DATA)
+      || ! bfd_set_section_alignment (abfd, s, 1))
+    return false;
+
+  if (! _bfd_coff_create_got_section (abfd, info, GOT_SYM, true))
+    return false;
+
+#ifdef USE_COPY_RELOC /* [ */
+  /* The .dynbss section is a place to put symbols which are defined
+     by dynamic objects, are referenced by regular objects, and are
+     not functions.  We must allocate space for them in the process
+     image and use a R_*_COPY reloc to tell the dynamic linker to
+     initialize them at run time.  The linker script puts the .dynbss
+     section into the .bss section of the final image.  */
+  s = bfd_make_section (abfd, ".dynbss");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
+    return false;
+
+  /* The .rel.bss section holds copy relocs.  This section is not
+     normally needed.  We need to create it here, though, so that the
+     linker will map it to an output section.  We can't just create it
+     only if we need it, because we will not know whether we need it
+     until we have seen all the input files, and the first time the
+     main linker code calls BFD after examining all the input files
+     (size_dynamic_sections) the input sections have already been
+     mapped to the output sections.  If the section turns out not to
+     be needed, we can discard it later.  We will never need this
+     section when generating a shared object, since they do not use
+     copy relocs.  */
+  if (! info->shared)
+    {
+      s = bfd_make_section (abfd, ".rel.bss"); 
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY
+						     | SEC_DYNAMIC)
+	  || ! bfd_set_section_alignment (abfd, s, 1))
+	return false;
+    }
+#endif /* ] */
+
+
+  /* The special symbol _DYNAMIC is always set to the start of the
+     .dynamic section.  This call occurs before we have processed the
+     symbols for any dynamic object, so we don't have to worry about
+     overriding a dynamic definition.  We could set _DYNAMIC in a
+     linker script, but we only want to define it if we are, in fact,
+     creating a .dynamic section.  We don't want to define it if there
+     is no .dynamic section, since on some ELF platforms the start up
+     code examines it to decide how to initialize the process.  */
+  s = coff_hash_table (info)->dynamic;
+  h = NULL;
+  if (! (bfd_coff_link_add_one_symbol
+	 (info, abfd, DYNAMIC_SYM, BSF_GLOBAL, s, (bfd_vma) 0,
+	  (const char *) NULL, 
+	  false, false,
+	  (struct bfd_link_hash_entry **) &h)))
+    return false;
+  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+
+  return true;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static boolean
+coff_i386_check_relocs (abfd, info, sec, relocs)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection *sec;
+     const struct internal_reloc *relocs;
+{
+  bfd *dynobj;
+  bfd_vma *local_got_offsets;
+  const struct internal_reloc *rel;
+  const struct internal_reloc *rel_end;
+  asection *sgot;
+  asection *srelgot;
+  asection *sreloc;
+
+  if (info->relocateable)
+    return true;
+
+  /* we don't do this for .stabs (or .stabstr). */
+  if (strncmp(sec->name, ".stab",5) == 0)
+    return true;
+
+  dynobj = coff_hash_table (info)->dynobj;
+  local_got_offsets = coff_local_got_offsets (abfd);
+
+  sgot = NULL;
+  srelgot = NULL;
+  sreloc = NULL;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      long r_symndx;
+      struct coff_link_hash_entry *h;
+
+      r_symndx = rel->r_symndx;
+
+      if (r_symndx == -1)
+	h = NULL;
+      else
+	h = obj_coff_sym_hashes(abfd)[r_symndx];
+
+      switch (rel->r_type)
+	{
+	case R_GNU_GOTOFF:
+	case R_GNU_GOTPC:
+	case R_GNU_GOT32:
+	  /* This symbol/reloc requires at least the existence of a GOT */
+	  if (dynobj == NULL)
+	      coff_hash_table (info)->dynobj = dynobj = abfd;
+
+	  if (sgot == NULL)
+	      sgot = coff_hash_table(info)->sgot;
+
+	  if (sgot == NULL)
+	    {
+	      if (! _bfd_coff_create_got_section (dynobj, info, GOT_SYM, true))
+		return false;
+	      sgot = coff_hash_table(info)->sgot;
+	    }
+
+
+	  if (rel->r_type != R_GNU_GOT32)
+	      break;
+
+	  /* This symbol requires a real global offset table entry (and
+	     a relocation for it).  */
+	  if (srelgot == NULL
+	      && (h != NULL || info->shared))
+	    {
+	      srelgot = coff_hash_table(info)->srelgot;
+	      if (srelgot == NULL)
+		{
+		  srelgot = bfd_make_section (dynobj, ".rel.got");
+                  coff_hash_table(info)->srelgot = srelgot;
+		  if (srelgot == NULL
+		      || ! bfd_set_section_flags (dynobj, srelgot,
+						  (SEC_ALLOC
+						   | SEC_LOAD
+						   | SEC_HAS_CONTENTS
+						   | SEC_IN_MEMORY
+						   | SEC_LINKER_CREATED
+						   | SEC_READONLY))
+		      || ! bfd_set_section_alignment (dynobj, srelgot, 1))
+		    return false;
+		}
+	    }
+
+	  /* If it has a GOT relocation, it needs a GOT offset.  If it
+	     has a symbol table entry, it goes there, otherwise we build
+	     a special table (for locals). */
+	  if (h != NULL)
+	    {
+	      if (h->got_offset != (bfd_vma) -1)
+		{
+		  /* We have already allocated space in the .got.  */
+		  break;
+		}
+	      h->got_offset = sgot->_raw_size;
+
+	      /* Make sure this symbol is output as a dynamic symbol.  */
+	      if (h->dynindx == -1)
+		{
+		  if (! _bfd_coff_link_record_dynamic_symbol (info, h))
+		    return false;
+		}
+
+// fprintf(stderr, "relgot adds reloc #%d in slot %d, %s\n", srelgot->_raw_size/10, h->got_offset/4, h->root.root.string); //
+	      srelgot->_raw_size += bfd_coff_relsz (abfd);
+	    }
+	  else
+	    {
+     	      /* This is a global offset table entry for a local
+                 symbol.  */
+	      if (local_got_offsets == NULL)
+		{
+		  size_t size;
+		  register unsigned int i;
+
+		  size = obj_raw_syment_count(abfd) * sizeof (bfd_vma);
+		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
+		  if (local_got_offsets == NULL)
+		    return false;
+		  coff_local_got_offsets (abfd) = local_got_offsets;
+		  for (i = 0; i <obj_raw_syment_count(abfd); i++)
+		    local_got_offsets[i] = (bfd_vma) -1;
+		}
+	      if (local_got_offsets[r_symndx] != (bfd_vma) -1)
+		{
+		  /* We have already allocated space in the .got.  */
+		  break;
+		}
+	      local_got_offsets[r_symndx] = sgot->_raw_size;
+
+	      if (info->shared)
+		{
+		  /* If we are generating a shared object, we need to
+                     output a R_GNU_RELATIVE reloc so that the dynamic
+                     linker can adjust this GOT entry.  */
+		  srelgot->_raw_size += bfd_coff_relsz (abfd);
+// fprintf(stderr, "relgot adds anonymous\n"); //
+		}
+	    }
+
+	  sgot->_raw_size += 4;
+
+	  break;
+
+	case R_GNU_PLT32:
+	  /* This symbol requires a procedure linkage table entry.  We
+             actually build the entry in adjust_dynamic_symbol,
+             because this might be a case of linking PIC code which is
+             never referenced by a dynamic object, in which case we
+             don't need to generate a procedure linkage table entry
+             after all.  */
+
+	  /* If this is a local symbol, we resolve it directly without
+             creating a procedure linkage table entry.  */
+	  if (h == NULL)
+	    continue;
+
+	  if (dynobj == NULL)
+	      coff_hash_table (info)->dynobj = dynobj = abfd;
+
+	  h->coff_link_hash_flags |= COFF_LINK_HASH_NEEDS_PLT;
+
+	  break;
+
+	case R_PCRLONG:
+	  /* local symbols don't get dynamic PCRLONG relocs */
+	  if (h == NULL)
+	      break;
+
+	  /* Symbolicly linked shared libs may not propigate all PCRLONG 
+	     relocations.  For defined symbols they end up just being 
+	     normal branches.  (When it's not symbolic, they are subject 
+	     to dynamic symbol resolution, so each needs a relocation entry.)  
+
+	     Undefined symbols still need an entry, in case someone else 
+	     defines them.  Since we don't yet know for sure whether it's
+	     undefined or not, we count them separately. */
+
+	  /* drop thru */
+        case R_DIR32:
+
+	  if (dynobj == NULL)
+	      coff_hash_table (info)->dynobj = dynobj = abfd;
+
+	  /* DIR32 relocations always need some sort of relocation,
+	     either RELATIVE or symbolic; either way, count them. */
+#ifdef USE_COPY_RELOC
+	  if (info->shared)
+#endif
+	    {
+	      /* When creating a shared object, or not using COPY relocations,
+		 we must copy some of these reloc types into the output file.
+		 We create a reloc section in dynobj and make room for this
+		 reloc.  */
+	      if (sreloc == NULL)
+		{
+	          sreloc = coff_hash_table (info)->sreloc;
+		  if (sreloc == NULL)
+		    {
+		      flagword flags;
+
+		      sreloc = bfd_make_section (dynobj, ".rel.internal");
+	              coff_hash_table (info)->sreloc = sreloc;
+		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
+			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
+		      if ((sec->flags & SEC_ALLOC) != 0)
+			flags |= SEC_ALLOC | SEC_LOAD;
+		      if (sreloc == NULL
+			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
+			  || ! bfd_set_section_alignment (dynobj, sreloc, 1))
+			return false;
+		    }
+		}
+
+	      /* For the generic reloc section, we want to count the
+		 number of relocations needed on a per-symbol basis,
+		 and then increase the section size after we determine
+		 which symbols will actually need runtime reloc entries.
+		 Local symbols (h==NULL) will get RELATIVE relocs (if any),
+		 so just count 'em now.   We figure out section symbols
+		 later, as it *might* look like an ordinary ref now. */
+
+	      if (h)
+		{
+      		  if (rel->r_type == R_PCRLONG)
+		      h->num_relative_relocs_needed++;
+		  else
+		      h->num_long_relocs_needed++;
+		}
+#ifdef USE_COPY_RELOC
+	      else
+#else
+	      else if (info->shared)
+#endif
+		{
+	          sreloc->_raw_size += bfd_coff_relsz (abfd);
+		}
+	    }
+
+	  break;
+
+	default:
+	  break;
+	}
+    }
+
+  return true;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static boolean
+coff_i386_adjust_dynamic_symbol (dynobj, info, h, skip)
+     struct bfd_link_info *info;
+     struct coff_link_hash_entry *h;
+     bfd *dynobj;
+     boolean skip;
+{
+  asection *s;
+#ifdef USE_COPY_RELOC
+  unsigned int power_of_two;
+#endif
+  asection *sreloc = coff_hash_table (info)->sreloc;
+
+  /* The first part is done for every symbol; the rest only for 
+     ones selected by the generic adjust_dynamic_symbol */
+
+  /* Earlier, we counted the number of relocations each symbol might
+     need.  Now that we know the symbol type, increase the size of 
+     .rel.internal for those symbols that will get dynamic relocations.
+
+     If it's a dynamic symbol (unconditionally) or we're doing a
+     shared library, we want to emit dynamic relocations 
+     for those relocations we counted up earlier.  (The code there knows
+     which types of relocations we care about, but doesn't for sure
+     know the symbol type.)  (N.B.: we can occasionally have dynamic symbol
+     that we reference (and thus need to count) that isn't defined, if
+     it's coming via an indirect shared lib.)
+
+     If it is a symbolic shared library, we don't want to count locally
+     defined absolute symbols, because they won't get a relocation.
+
+     DLL symbols are ALWAYS static w.r.t. .so's; their dynamic nature
+     is handled by the DLL mechanism.
+
+     Section symbols are (implicitly) counted in shared libraries 
+     because they get RELATIVE relocs that weren't counted (again because 
+     we couldn't be sure of symbol type at the time.)
+
+     Note: the fact that the count is non-zero is in the formal sense
+     equivalent to REF_REGULAR being true, so we don't need to check
+     REF_REGULAR, just add the count.
+
+     Note: if it's a very simple case, sreloc may be null (and
+     consequently all counts zero), and we don't need to bother.  */
+
+  if (sreloc != NULL 
+	&& (((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0)
+             || (h->dynindx != -1 && h->root.type == bfd_link_hash_undefined)
+             || info->shared)
+        )
+    {
+#undef DEBUG_COUNTING
+#ifdef DEBUG_COUNTING //!!
+int did_print=0;
+if (h->num_long_relocs_needed || h->num_relative_relocs_needed) 
+{
+did_print = 1;
+fprintf(stderr, "%s (%x) adds %d+%d(?)", h->root.root.string, h->coff_link_hash_flags, h->num_long_relocs_needed, h->num_relative_relocs_needed); //!!
+}
+#endif
+      /* We'll need a dynamic reloc for 'long relocs' passed above (whether
+	 it'll be symbolic or relative is determined by the relocation code)
+	 and whether it's a suppressed symbol or not (suppressed either
+	 explicitly, or because it's symbolic mode).  For suppressed
+	 symbols, if they're locally defined and absolute, no relocation.
+	 (Read || as "or else if" below, it'll make more sense.) */
+      if (! info->shared 
+	  || !(info->symbolic || h->dynindx == -1)
+	  || !((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	  || !bfd_is_abs_section(h->root.u.def.section)
+	  )
+	{
+          sreloc->_raw_size += 
+	      (h->num_long_relocs_needed * bfd_coff_relsz (dynobj));
+          h->num_long_relocs_needed = -h->num_long_relocs_needed;
+	}
+      /* relative relocs are needed in shared but not for suppressed symbols,
+	 but undefined suppressed symbols do get a reloc. We couldn't
+	 tell about undefined when we first counted them, but now we can.
+	 Note... these tests really are different; things fail if not. */
+      if (
+#ifdef USE_DLLS
+	  (h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) == 0
+#endif
+	  && (! info->shared 
+	     || !(info->symbolic || h->dynindx == -1)
+	     || !((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	     || h->root.type == bfd_link_hash_undefined)
+	  )
+	{
+          sreloc->_raw_size += 
+	      (h->num_relative_relocs_needed * bfd_coff_relsz (dynobj));
+          h->num_relative_relocs_needed = -h->num_relative_relocs_needed;
+	}
+#ifdef DEBUG_COUNTING //!!
+if (did_print) fprintf(stderr, "relocs = %d\n", sreloc->_raw_size); //!!
+#endif
+    }
+
+  if (skip)
+      return true;
+  /* Make sure we know what is going on here.  */
+#ifdef USE_WEAK
+  BFD_ASSERT (dynobj != NULL
+	      && ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT)
+		  || h->weakdef != NULL
+		  || ((h->coff_link_hash_flags
+		       & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_REF_REGULAR) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_DEF_REGULAR) == 0)));
+#else
+  BFD_ASSERT (dynobj != NULL
+	      && ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT)
+		  || ((h->coff_link_hash_flags
+		       & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_REF_REGULAR) != 0
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_DEF_REGULAR) == 0)));
+#endif
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (ISFCN(h->type)
+      || (h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) != 0)
+    {
+      if (! info->shared
+	  && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+	  && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) == 0)
+	{
+	  /* This case can occur if we saw a PLT32 reloc in an input
+             file, but the symbol was never mentioned by a dynamic
+             object.  In such a case, we don't actually need to build
+             a procedure linkage table, and we can just do a PC32
+             reloc instead.  */
+	  BFD_ASSERT ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) != 0);
+	  return true;
+	}
+
+      /* Make sure this symbol is output as a dynamic symbol.  */
+      if (h->dynindx == -1)
+	{
+	  if (! _bfd_coff_link_record_dynamic_symbol (info, h))
+	    return false;
+	}
+
+      s = coff_hash_table(info)->splt;
+      BFD_ASSERT (s != NULL);
+
+      /* If this is the first .plt entry, make room for the special
+	 first entry.  */
+      if (s->_raw_size == 0)
+	s->_raw_size += PLT_ENTRY_SIZE;
+
+      /* If this symbol is not defined in a regular file, and we are
+	 not generating a shared library, then set the symbol to this
+	 location in the .plt.  This is required to make function
+	 pointers compare as equal between the normal executable and
+	 the shared library.  */
+      if (! info->shared
+	  && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  h->root.u.def.section = s;
+	  h->root.u.def.value = s->_raw_size;
+	}
+
+      h->plt_offset = s->_raw_size;
+
+      /* Make room for this entry.  */
+      s->_raw_size += PLT_ENTRY_SIZE;
+
+      /* We also need to make an entry in the .got.plt section, which
+	 will be placed in the .got section by the linker script.  */
+
+      s = coff_hash_table(info)->sgotplt;
+      BFD_ASSERT (s != NULL);
+      s->_raw_size += 4;
+
+      /* We also need to make an entry in the .rel.plt section.  */
+
+      s = coff_hash_table(info)->srelplt;
+      BFD_ASSERT (s != NULL);
+      s->_raw_size += bfd_coff_relsz (dynobj);
+//fprintf(stderr, "relPLT adds # %d, %s\n",( s->_raw_size/bfd_coff_relsz (dynobj))-1, h->root.root.string);
+
+      return true;
+    }
+
+#ifdef USE_WEAK
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->weakdef != NULL)
+    {
+      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
+		  || h->weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->weakdef->root.u.def.section;
+      h->root.u.def.value = h->weakdef->root.u.def.value;
+      return true;
+    }
+#endif
+
+#ifdef USE_COPY_RELOC /* [ */
+  /* If we are not doing COPY relocations at all, we assume the same
+     case as for shared libraries, and pay the cost of doing relocations
+     for such symbols at runtime if the symbol is accessed by non-PIC
+     code.  (By being smart, it's not necessarily that bad.) */
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return true;
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  s = bfd_get_section_by_name (dynobj, ".dynbss");
+  BFD_ASSERT (s != NULL);
+
+  /* We must generate a R_GNU_COPY reloc to tell the dynamic linker to
+     copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rel.bss section we are going to use.  */
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      asection *srel;
+
+      srel = bfd_get_section_by_name (dynobj, ".rel.bss");
+      BFD_ASSERT (srel != NULL);
+      srel->_raw_size += bfd_coff_relsz (abfd);
+      h->coff_link_hash_flags |= COFF_LINK_HASH_NEEDS_COPY;
+    }
+
+  /* We need to figure out the alignment required for this symbol.  I
+     have no idea how ELF linkers handle this.  */
+  power_of_two = bfd_log2 (h->size);
+  if (power_of_two > 3)
+    power_of_two = 3;
+
+  /* Apply the required alignment.  */
+  s->_raw_size = BFD_ALIGN (s->_raw_size,
+			    (bfd_size_type) (1 << power_of_two));
+  if (power_of_two > bfd_get_section_alignment (dynobj, s))
+    {
+      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
+	return false;
+    }
+
+  /* Define the symbol as being at this point in the section.  */
+  h->root.u.def.section = s;
+  h->root.u.def.value = s->_raw_size;
+
+  /* Increment the section size to make room for the symbol.  */
+  s->_raw_size += h->size;
+#endif /* ] */
+
+  return true;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static boolean
+coff_i386_finish_dynamic_symbol (output_bfd, info, h, sym)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+     struct coff_link_hash_entry *h;
+     struct internal_syment *sym;
+{
+  bfd *dynobj;
+  bfd_vma imagebase=0;
+  if (pe_data(output_bfd) != NULL)
+      imagebase = pe_data(output_bfd)->pe_opthdr.ImageBase;
+
+  /* It is possible to get here with h->dynindx == -1; a symbol that is
+     forced local may still need a GOT entry. */
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  if (h->plt_offset != (bfd_vma) -1)
+    {
+      asection *splt;
+      asection *sgotplt;
+      asection *srelplt;
+      bfd_vma plt_index;
+      bfd_vma got_offset;
+      struct internal_reloc rel;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+	 it up.  */
+
+      BFD_ASSERT (h->dynindx != -1);
+
+      splt = coff_hash_table(info)->splt;
+      sgotplt = coff_hash_table(info)->sgotplt;
+      srelplt = coff_hash_table(info)->srelplt;
+      BFD_ASSERT (splt != NULL && sgotplt != NULL && srelplt != NULL);
+
+      /* Get the index in the procedure linkage table which
+	 corresponds to this symbol.  This is the index of this symbol
+	 in all the symbols for which we are making plt entries.  The
+	 first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt_offset / PLT_ENTRY_SIZE - 1;
+
+      /* Get the offset into the .got table of the entry that
+	 corresponds to this function.  Each .got entry is 4 bytes.
+	 The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+
+      /* Fill in the entry in the procedure linkage table.
+
+	 Non-PIC code in a shared library won't go thru the PLT/GOT
+	 (it gets relocated inline), so using PIC in any 
+	 shared lib works.  Since the caller of the stub must be in
+	 this shared lib (and thus share a single GOT value) %ebx will
+	 be right when the PIC PLT entry is called. 
+
+	 Main won't go thru the PLT/GOT unless there's PIC in it; whether
+	 the PLT is PIC or not really doesn't matter, and it saves a
+	 few relocation entries if it is PIC.  */
+
+      /* No need for a base_file entry here (code is PIC) */
+      memcpy (splt->contents + h->plt_offset, coff_i386_pic_plt_entry,
+	      PLT_ENTRY_SIZE);
+      bfd_put_32 (output_bfd, got_offset,
+		  splt->contents + h->plt_offset + 2);
+
+      /* Fill in rest of plt entry: the offset to the relocation and
+	 the start of the PLT.  Tricky code, here:
+
+	 - This becomes the branch stub/thunk for this symbol.
+	 - Instruction 1 is a jump indirect to the symbol's GOT slot
+	   * Initially, the GOT slot contains the address of the next
+	     instruction below.
+	   * After dynamic link, this is the address of the real function.
+	 - Instruction 2 pushes the offset of the relocation entry.
+	 - Instruction 3 jumps indirect to the start of PLT, which
+	   contains:
+	      pushl .got+4   # startup crams in &info struct for this lib
+	      jmp   *.got+8  # startup crams in &runtime linker.
+	 - .got+8 contains the address of the runtime dynamic linker.
+	 - The dynamic linker is effectively called with 2 args,
+	      - the reloc entry
+	      - the info struct.  (This struct is private to the runtime
+		  side of things.  We don't know anything about it here.)
+
+	 Thus, until the dynamic linker has done it's thing (the first
+	 call) we jump to the dynamic linker after having pushed the relocation
+	 information it requires.  After that (once the GOT is modified)
+	 we jump to the real routine.  */
+
+      bfd_put_32 (output_bfd, plt_index * bfd_coff_relsz (output_bfd),
+		  splt->contents + h->plt_offset + 7);
+      bfd_put_32 (output_bfd, - (h->plt_offset + PLT_ENTRY_SIZE),
+		  splt->contents + h->plt_offset + 12);
+
+      /* if (info->base_file ...  do something */
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd,
+		  (splt->output_section->vma
+		   + splt->output_offset
+		   + h->plt_offset
+		   + 6 + imagebase),
+		  sgotplt->contents + got_offset);
+
+      /* Fill in the entry in the .rel.plt section.  */
+      rel.r_symndx = h->dynindx;
+      rel.r_vaddr = (sgotplt->output_section->vma
+		      + sgotplt->output_offset
+		      + got_offset);
+
+//fprintf(stderr, "relPLT emits # %d, %s\n", plt_index, h->root.root.string);
+      rel.r_type = R_GNU_JUMP_SLOT;
+      bfd_coff_swap_reloc_out (output_bfd, &rel,
+			srelplt->contents + plt_index * bfd_coff_relsz (output_bfd));
+      srelplt->reloc_count++;  /* used for subsequent assert */
+
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->n_scnum = N_UNDEF;
+	  sym->n_sclass = C_EXT;
+	}
+    }
+
+  if (h->got_offset != (bfd_vma) -1)
+    {
+      asection *sgot;
+      asection *srelgot;
+      struct internal_reloc rel;
+
+      /* This symbol has an entry in the global offset table.  Set it
+	 up.  */
+
+      sgot = coff_hash_table(info)->sgot;
+      srelgot = coff_hash_table(info)->srelgot;
+      BFD_ASSERT (sgot != NULL && srelgot != NULL);
+
+      rel.r_vaddr = (sgot->output_section->vma
+		      + sgot->output_offset
+		      + (h->got_offset &~ 1));
+
+      /* If this is a -Bsymbolic link, and the symbol is defined
+	 locally, we just want to emit a RELATIVE reloc.  The entry in
+	 the global offset table will already have been initialized in
+	 the relocate_section function.  */
+      if ((info->shared
+	     && info->symbolic
+	     && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR))
+	  || (h->coff_link_hash_flags & COFF_LINK_FORCED_LOCAL) != 0) 
+        {
+	  rel.r_type = R_GNU_RELATIVE;
+	  rel.r_symndx = 0;
+	}
+      else
+	{
+          BFD_ASSERT (h->dynindx != -1);
+	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got_offset);
+	  rel.r_type = R_GNU_GLOB_DAT;
+	  rel.r_symndx = h->dynindx;
+	}
+
+      bfd_coff_swap_reloc_out (output_bfd, &rel,
+	      (srelgot->contents + srelgot->reloc_count*bfd_coff_relsz (output_bfd)));
+// fprintf(stderr, "finish relgot emits %d, reloc #%d, for slot %d, %s\n", rel.r_type, srelgot->reloc_count, h->got_offset/4, h->root.root.string); //
+      ++srelgot->reloc_count;
+    }
+
+#ifdef USE_COPY_RELOC /* [ */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_COPY) != 0)
+    {
+      asection *s;
+      struct internal_reloc rel;
+
+      /* This symbol needs a copy reloc.  Set it up.  */
+
+      BFD_ASSERT (h->dynindx != -1
+		  && (h->root.type == bfd_link_hash_defined
+		      || h->root.type == bfd_link_hash_defweak));
+
+      s = bfd_get_section_by_name (h->root.u.def.section->owner,
+				   ".rel.bss");
+      BFD_ASSERT (s != NULL);
+
+      rel.r_vaddr = (h->root.u.def.value
+		      + h->root.u.def.section->output_section->vma
+		      + h->root.u.def.section->output_offset);
+      rel.r_type = R_GNU_COPY;
+      rel.r_symndx = h->dynindx;
+      bfd_coff_swap_reloc_out (output_bfd, &rel,
+		      (s->contents + s->reloc_count*bfd_coff_relsz (abfd)));
+      ++s->reloc_count;
+    }
+#endif /* ] */
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
+  if (strcmp (h->root.root.string, DYNAMIC_SYM) == 0
+      || strcmp (h->root.root.string, GOT_SYM) == 0)
+    sym->n_scnum = N_ABS;
+
+  return true;
+}
+
+/* Finish up the dynamic sections.  */
+
+static boolean
+coff_i386_finish_dynamic_sections (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  bfd *dynobj;
+  asection *sgotplt;
+  asection *sdyn;
+  bfd_vma imagebase=0;
+
+  if (pe_data(output_bfd) != NULL)
+      imagebase = pe_data(output_bfd)->pe_opthdr.ImageBase;
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  sgotplt = coff_hash_table(info)->sgotplt;
+  BFD_ASSERT (sgotplt != NULL);
+  sdyn = coff_hash_table (info)->dynamic;
+
+  if (coff_hash_table (info)->dynamic_sections_created)
+    {
+      asection *splt;
+      coff_external_dyn *dyncon, *dynconend;
+
+      splt = coff_hash_table(info)->splt;
+      BFD_ASSERT (splt != NULL && sdyn != NULL);
+
+      dyncon = (coff_external_dyn *) sdyn->contents;
+      dynconend = (coff_external_dyn *) (sdyn->contents + sdyn->_raw_size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  coff_internal_dyn dyn;
+	  asection *s;
+
+	  bfd_coff_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+
+	    case DT_PLTGOT:
+	      s = coff_hash_table(info)->sgotplt;
+	      goto get_vma;
+	    case DT_JMPREL:
+	      s = coff_hash_table(info)->srelplt;
+	    get_vma:
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_ptr = s->output_section->vma 
+	                       + s->vma 
+			       + s->output_offset;
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_PLTRELSZ:
+	      /* Get size from .rel.plt section. */
+	      s = coff_hash_table(info)->srelplt;
+	      BFD_ASSERT (s != NULL);
+	      if (s->_cooked_size != 0)
+		dyn.d_un.d_val = s->_cooked_size;
+	      else
+		dyn.d_un.d_val = s->_raw_size;
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_RELSZ:
+	      /* Accumulate sizes from .rel.internal and .rel.got sections */
+	      s = coff_hash_table(info)->sreloc;
+	      dyn.d_un.d_val = 0;
+	      if (s != NULL)
+		{
+		  if (s->_cooked_size != 0)
+		    dyn.d_un.d_val = s->_cooked_size;
+		  else
+		    dyn.d_un.d_val = s->_raw_size;
+		}
+
+	      s = coff_hash_table(info)->srelgot;
+	      if (s != NULL)
+		{
+		  if (s->_cooked_size != 0)
+		    dyn.d_un.d_val += s->_cooked_size;
+		  else
+		    dyn.d_un.d_val += s->_raw_size;
+		}
+
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+	    }
+	}
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      if (splt->_raw_size > 0)
+	{
+	   memcpy (splt->contents, coff_i386_pic_plt0_entry, PLT_ENTRY_SIZE);
+	}
+    }
+
+  /* Fill in the first three entries in the global offset table.  */
+  if (sgotplt->_raw_size > 0)
+    {
+      /* if (info->base_file ...) */
+      if (sdyn == NULL)
+	bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents);
+      else
+	bfd_put_32 (output_bfd,
+		    sdyn->output_section->vma + sdyn->output_offset + imagebase,
+		    sgotplt->contents);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents + 4);
+      bfd_put_32 (output_bfd, (bfd_vma) 0, sgotplt->contents + 8);
+    }
+
+  return true;
+}
+
+#endif /* ] DYNAMIC_LINKING */
+
+#ifdef INPUT_FORMAT
+extern const bfd_target INPUT_FORMAT;
+#define PINPUT_FORMAT &INPUT_FORMAT
+#else
+#define PINPUT_FORMAT NULL
+#endif
+
 const bfd_target
 #ifdef TARGET_SYM
   TARGET_SYM =
@@ -533,13 +1686,18 @@ const bfd_target
   "coff-i386",			/* name */
 #endif
   bfd_target_coff_flavour,
+  PINPUT_FORMAT,		/* format of acceptable input files for link */
   BFD_ENDIAN_LITTLE,		/* data byte order is little */
   BFD_ENDIAN_LITTLE,		/* header byte order is little */
 
   (HAS_RELOC | EXEC_P |		/* object flags */
    HAS_LINENO | HAS_DEBUG |
+#ifdef DYNAMIC_LINKING
+   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED | DYNAMIC),
+#else
    HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),
-
+#endif
+
   (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
 #ifdef COFF_WITH_PE
    | SEC_LINK_ONCE | SEC_LINK_DUPLICATES | SEC_READONLY
@@ -577,7 +1735,11 @@ const bfd_target
      BFD_JUMP_TABLE_RELOCS (coff),
      BFD_JUMP_TABLE_WRITE (coff),
      BFD_JUMP_TABLE_LINK (coff),
+#ifdef DYNAMIC_LINKING
+     BFD_JUMP_TABLE_DYNAMIC (coff),
+#else
      BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+#endif
 
   NULL,
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/coffcode.h bfd/coffcode.h
--- bfd.pre.dynlink/coffcode.h	Wed Feb  6 10:10:03 2002
+++ bfd/coffcode.h	Wed Feb  6 15:53:10 2002
@@ -332,7 +332,7 @@ static boolean coff_slurp_line_table PAR
 static boolean coff_slurp_symbol_table PARAMS ((bfd *));
 static enum coff_symbol_classification coff_classify_symbol
   PARAMS ((bfd *, struct internal_syment *));
-static boolean coff_slurp_reloc_table PARAMS ((bfd *, asection *, asymbol **));
+static boolean coff_slurp_reloc_table PARAMS ((bfd *, asection *, asymbol **, boolean));
 static long coff_canonicalize_reloc
   PARAMS ((bfd *, asection *, arelent **, asymbol **));
 #ifndef coff_mkobject_hook
@@ -1305,6 +1305,85 @@ Special entry points for gdb to swap in 
 .  boolean (*_bfd_coff_final_link_postscript)
 .    PARAMS ((bfd *, struct coff_final_link_info *));
 .
+. void (*_bfd_coff_canonicalize_one_symbol) PARAMS((
+.       bfd *,
+.       combined_entry_type *,
+.       coff_symbol_type *));
+.#ifdef DYNAMIC_LINKING
+. void (*_bfd_coff_swap_dyn_in) PARAMS ((
+.       bfd *, 
+.       const PTR, 
+.       coff_internal_dyn *));
+. void (*_bfd_coff_swap_dyn_out) PARAMS ((
+.       bfd *, 
+.       const coff_internal_dyn *, 
+.       coff_external_dyn *));
+. void (*_bfd_coff_swap_verdef_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_verdef *src,
+.	coff_internal_verdef *dst));
+. void (*_bfd_coff_swap_verdef_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_verdef *src,
+.	coff_external_verdef *dst));
+. void (*_bfd_coff_swap_verdaux_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_verdaux *src,
+.	coff_internal_verdaux *dst));
+. void (*_bfd_coff_swap_verdaux_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_verdaux *src,
+.	coff_external_verdaux *dst));
+. void (*_bfd_coff_swap_verneed_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_verneed *src,
+.	coff_internal_verneed *dst));
+. void (*_bfd_coff_swap_verneed_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_verneed *src,
+.	coff_external_verneed *dst));
+. void (*_bfd_coff_swap_vernaux_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_vernaux *src,
+.	coff_internal_vernaux *dst));
+. void (*_bfd_coff_swap_vernaux_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_vernaux *src,
+.	coff_external_vernaux *dst));
+. void (*_bfd_coff_swap_versym_in) PARAMS ((
+.	bfd *abfd,
+.	const coff_external_versym *src,
+.	coff_internal_versym *dst));
+. void (*_bfd_coff_swap_versym_out) PARAMS ((
+.	bfd *abfd,
+.	const coff_internal_versym *src,
+.	coff_external_versym *dst));
+. boolean (*_bfd_coff_backend_link_create_dynamic_sections) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *));
+. boolean (*_bfd_coff_backend_check_relocs) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *,
+.       asection *,
+.       const struct internal_reloc *relocs));
+. boolean (*_bfd_coff_backend_adjust_dynamic_symbol) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *,
+.       struct coff_link_hash_entry *,
+.	boolean));
+. boolean (*_bfd_coff_backend_size_dynamic_sections) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *));
+. boolean (*_bfd_coff_backend_finish_dynamic_symbol) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *,
+.       struct coff_link_hash_entry *,
+.       struct internal_syment *));
+. boolean (*_bfd_coff_backend_finish_dynamic_sections) PARAMS ((
+.       bfd *,
+.       struct bfd_link_info *));
+.#endif
+.
 .} bfd_coff_backend_data;
 .
 .#define coff_backend_info(abfd) \
@@ -1340,6 +1419,51 @@ Special entry points for gdb to swap in 
 .#define bfd_coff_swap_aouthdr_out(abfd, i,o) \
 .  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o))
 .
+.#ifdef DYNAMIC_LINKING
+.#define bfd_coff_swap_dyn_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_in) (abfd, i, o))
+.#define bfd_coff_swap_dyn_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_dyn_out) (abfd, i, o))
+.#define bfd_coff_swap_verdef_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_in) (abfd, i, o))
+.#define bfd_coff_swap_verdef_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdef_out) (abfd, i, o))
+.#define bfd_coff_swap_verdaux_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_in) (abfd, i, o))
+.#define bfd_coff_swap_verdaux_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verdaux_out) (abfd, i, o))
+.#define bfd_coff_swap_verneed_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_in) (abfd, i, o))
+.#define bfd_coff_swap_verneed_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_verneed_out) (abfd, i, o))
+.#define bfd_coff_swap_vernaux_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_in) (abfd, i, o))
+.#define bfd_coff_swap_vernaux_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_vernaux_out) (abfd, i, o))
+.#define bfd_coff_swap_versym_in(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_in) (abfd, i, o))
+.#define bfd_coff_swap_versym_out(abfd, i,o) \
+.        ((coff_backend_info (abfd)->_bfd_coff_swap_versym_out) (abfd, i, o))
+.#define bfd_coff_backend_link_create_dynamic_sections(abfd, i) \
+.        ((coff_backend_info (abfd)-> \
+.           _bfd_coff_backend_link_create_dynamic_sections) (abfd, i))
+.#define bfd_coff_backend_check_relocs(abfd, i, s, r) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_check_relocs) \
+.           (abfd, i, s, r))
+.#define bfd_coff_backend_adjust_dynamic_symbol(abfd, i, h, s) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_adjust_dynamic_symbol) \
+.           (abfd, i, h, s))
+.#define bfd_coff_backend_size_dynamic_sections(abfd, i) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_size_dynamic_sections) \
+.           (abfd, i))
+.#define bfd_coff_backend_finish_dynamic_symbol(abfd, i, h, s) \
+.        ((coff_backend_info (abfd)->_bfd_coff_backend_finish_dynamic_symbol) \
+.           (abfd, i, h, s))
+.#define bfd_coff_backend_finish_dynamic_sections(abfd, i) \
+.        ((coff_backend_info(abfd)->_bfd_coff_backend_finish_dynamic_sections) \
+.           (abfd, i))
+.#endif
+.
 .#define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz)
 .#define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz)
 .#define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz)
@@ -1428,7 +1552,10 @@ Special entry points for gdb to swap in 
 .#define bfd_coff_link_add_one_symbol(info,abfd,name,flags,section,value,string,cp,coll,hashp)\
 .  ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\
 .   (info, abfd, name, flags, section, value, string, cp, coll, hashp))
-.
+.#define bfd_coff_canonicalize_one_symbol(abfd, src, dest) \
+.        ((coff_backend_info (abfd)->_bfd_coff_canonicalize_one_symbol)\
+.         (abfd, src, dest))
+.
 .#define bfd_coff_link_output_has_begun(a,p) \
 .  ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a,p))
 .#define bfd_coff_final_link_postscript(a,p) \
@@ -3341,6 +3468,7 @@ coff_write_object_contents (abfd)
   asection *bss_sec = NULL;
   struct internal_filehdr internal_f;
   struct internal_aouthdr internal_a;
+  int section_count;
 #ifdef COFF_LONG_SECTION_NAMES
   size_t string_size = STRING_SIZE_SIZE;
 #endif
@@ -3361,7 +3489,9 @@ coff_write_object_contents (abfd)
   reloc_base = obj_relocbase (abfd);
 
   /* Work out the size of the reloc and linno areas */
-
+  /* Incidentally, count the number of sections */
+  section_count=0;
+
   for (current = abfd->sections; current != NULL; current =
        current->next)
     {
@@ -3370,6 +3500,7 @@ coff_write_object_contents (abfd)
       if (current->reloc_count > 0xffff)
 	reloc_count ++;
 #endif
+      section_count++;
       reloc_count += current->reloc_count;
     }
 
@@ -3546,7 +3677,60 @@ coff_write_object_contents (abfd)
 	{
 	  bss_sec = current;
 	}
-
+#ifdef DYNAMIC_LINKING
+      else if (strcmp (current->name, ".dynsym") == 0)
+	{
+          int dynsymcount;
+	  /* objcopy or strip will copy over info_r, but may not set
+	     dynsymcount.  The linker will set dynsymcount, but info_r will be
+	     zero.  */
+	  if (current->info_r == 0)
+	    {
+              dynsymcount = 
+	          coff_hash_table(coff_data(abfd)->link_info)->dynsymcount;
+	      section.s_nreloc = dynsymcount;
+	    }
+	    else
+	      section.s_nreloc = current->info_r;
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".dynstr") == 0)
+	{
+	  section.s_nreloc = current->info_r;
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".gnu.version_d") == 0)
+	{
+	  /* objcopy or strip will copy over info_r, but may not set
+	     cverrefs.  The linker will set cverrefs, but info_r will be
+	     zero.  */
+	  if (current->info_r == 0)
+	    section.s_nreloc = dyn_data (abfd)->cverdefs;
+	  else
+	    BFD_ASSERT (dyn_data (abfd)->cverdefs == 0
+			|| current->info_r == dyn_data (abfd)->cverdefs);
+
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".gnu.version_r") == 0)
+	{
+	  /* objcopy or strip will copy over info_r, but may not set
+	     cverrefs.  The linker will set cverrefs, but info_r will be
+	     zero.  */
+	  if (current->info_r == 0)
+	    section.s_nreloc = dyn_data (abfd)->cverrefs;
+	  else
+	    BFD_ASSERT (dyn_data (abfd)->cverrefs == 0
+			|| current->info_r == dyn_data (abfd)->cverrefs);
+	  section.s_nlnno = current->info_l;
+	}
+      else if (strcmp (current->name, ".gnu.version") == 0)
+	{
+	  section.s_nreloc = current->info_r;
+	  section.s_nlnno = current->info_l;
+	}
+#endif
+
 #ifdef I960
       section.s_align = (current->alignment_power
 			 ? 1 << current->alignment_power
@@ -3762,6 +3946,13 @@ coff_write_object_contents (abfd)
   internal_f.f_target_id = TIC80_TARGET_ID;
 #endif
 
+#ifdef COFF_IMAGE_WITH_PE
+#ifdef DYNAMIC_LINKING
+  if ((abfd->flags & DYNAMIC) != 0)
+    pe_data(abfd)->pe_opthdr.DllCharacteristics |= 0x0001;
+#endif
+#endif
+
   /*
      FIXME, should do something about the other byte orders and
      architectures.
@@ -4342,52 +4533,31 @@ coff_slurp_line_table (abfd, asect)
   return true;
 }
 
-/* Slurp in the symbol table, converting it to generic form.  Note
-   that if coff_relocate_section is defined, the linker will read
-   symbols via coff_link_add_symbols, rather than via this routine.  */
-
-static boolean
-coff_slurp_symbol_table (abfd)
+// NOTE:  This text is NOT part of the official patch submittal, but
+// MUST remain with it until the patch is actually applied to the official
+// source.  Thus the // comments.
+
+// The goal of this group of changes is to split coff_slurp_symbol_table
+// into a "worker" coff_canonicalize_one_symbol, which is the body of
+// function, and a driver coff_slurp_symbol_table.  To make maintenance
+// easier until the patch is applied officially, the indentation has not
+// been changed to match GNU standards.  When actually applying the change,
+// the indentation needs to be changed, after the patch is applied.
+// There are other // comments below to indicate the residual changes.
+
+/* Input one symbol, needed for dynamic linking as well as 
+   coff_slurp_symbol_table */
+  
+static void coff_canonicalize_one_symbol 
+  PARAMS((bfd *, combined_entry_type *, coff_symbol_type *));
+
+static void
+coff_canonicalize_one_symbol (abfd, src, dst)
      bfd * abfd;
-{
-  combined_entry_type *native_symbols;
-  coff_symbol_type *cached_area;
-  unsigned int *table_ptr;
-  bfd_size_type amt;
-
-  unsigned int number_of_symbols = 0;
-
-  if (obj_symbols (abfd))
-    return true;
-
-  /* Read in the symbol table */
-  if ((native_symbols = coff_get_normalized_symtab (abfd)) == NULL)
-    {
-      return (false);
-    }				/* on error */
-
-  /* Allocate enough room for all the symbols in cached form */
-  amt = obj_raw_syment_count (abfd);
-  amt *= sizeof (coff_symbol_type);
-  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);
-  if (cached_area == NULL)
-    return false;
-
-  amt = obj_raw_syment_count (abfd);
-  amt *= sizeof (unsigned int);
-  table_ptr = (unsigned int *) bfd_alloc (abfd, amt);
-
-  if (table_ptr == NULL)
-    return false;
-  else
-    {
-      coff_symbol_type *dst = cached_area;
-      unsigned int last_native_index = obj_raw_syment_count (abfd);
-      unsigned int this_index = 0;
-      while (this_index < last_native_index)
-	{
-	  combined_entry_type *src = native_symbols + this_index;
-	  table_ptr[this_index] = number_of_symbols;
+     combined_entry_type *src;
+     coff_symbol_type *dst;
+{
+//  This needs an indentation fix.
 	  dst->symbol.the_bfd = abfd;
 
 	  dst->symbol.name = (char *) (src->u.syment._n._n_n._n_offset);
@@ -4688,7 +4858,64 @@ coff_slurp_symbol_table (abfd)
 
 	  dst->symbol.udata.i = 0;
 	  dst->lineno = (alent *) NULL;
+
+    // End of misindented region
+}
+
+
+/* Slurp in the symbol table, converting it to generic form.  Note
+   that if coff_relocate_section is defined, the linker will read
+   symbols via coff_link_add_symbols, rather than via this routine.  */
+
+static boolean coff_slurp_symbol_table PARAMS (( bfd *abfd));
+
+static boolean
+coff_slurp_symbol_table (abfd)
+     bfd * abfd;
+{
+  combined_entry_type *native_symbols;
+  coff_symbol_type *cached_area;
+  unsigned int *table_ptr;
+  bfd_size_type amt;
+
+  unsigned int number_of_symbols = 0;
+
+  if (obj_symbols (abfd))
+    return true;
+
+  /* Read in the symbol table */
+  if ((native_symbols = coff_get_normalized_symtab (abfd)) == NULL)
+    {
+      return (false);
+    }				/* on error */
+
+  /* Allocate enough room for all the symbols in cached form */
+  amt = obj_raw_syment_count (abfd);
+  amt *= sizeof (coff_symbol_type);
+  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);
+  if (cached_area == NULL)
+    return false;
+
+  amt = obj_raw_syment_count (abfd);
+  amt *= sizeof (unsigned int);
+  table_ptr = (unsigned int *) bfd_alloc (abfd, amt);
+
+  if (table_ptr == NULL)
+    return false;
+  else
+    {
+      coff_symbol_type *dst = cached_area;
+      unsigned int last_native_index = obj_raw_syment_count (abfd);
+      unsigned int this_index = 0;
+      while (this_index < last_native_index)
+	{
+	  combined_entry_type *src = native_symbols + this_index;
+	  table_ptr[this_index] = number_of_symbols;
+
 	  this_index += (src->u.syment.n_numaux) + 1;
+
+	  bfd_coff_canonicalize_one_symbol(abfd, src, dst);
+
 	  dst++;
 	  number_of_symbols++;
 	}			/* walk the native symtab */
@@ -4737,9 +4964,6 @@ coff_classify_symbol (abfd, syment)
 #ifdef C_SYSTEM
     case C_SYSTEM:
 #endif
-#ifdef COFF_WITH_PE
-    case C_NT_WEAK:
-#endif
       if (syment->n_scnum == 0)
 	{
 	  if (syment->n_value == 0)
@@ -4748,7 +4972,11 @@ coff_classify_symbol (abfd, syment)
 	    return COFF_SYMBOL_COMMON;
 	}
       return COFF_SYMBOL_GLOBAL;
-
+#ifdef COFF_WITH_PE
+    case C_NT_WEAK:
+      return COFF_SYMBOL_GLOBAL;
+#endif
+
     default:
       break;
     }
@@ -4862,17 +5090,25 @@ SUBSUBSECTION
 #endif
 
 static boolean
-coff_slurp_reloc_table (abfd, asect, symbols)
+coff_slurp_reloc_table (abfd, asect, symbols, dynamic)
      bfd * abfd;
      sec_ptr asect;
      asymbol ** symbols;
-{
+     boolean dynamic;
+{
   RELOC *native_relocs;
   arelent *reloc_cache;
   arelent *cache_ptr;
   unsigned int idx;
   bfd_size_type amt;
-
+  unsigned int num_relocs;
+  unsigned int *conv_table;
+  int conv_table_size = 0;
+  bfd_vma this_vma;
+
+// NOTE:  MISINDENT until final patch
+  if (!dynamic)
+    {   //  Begin misindent
   if (asect->relocation)
     return true;
   if (asect->reloc_count == 0)
@@ -4881,15 +5117,47 @@ coff_slurp_reloc_table (abfd, asect, sym
     return true;
   if (!coff_slurp_symbol_table (abfd))
     return false;
+
+  num_relocs = asect->reloc_count;
   amt = (bfd_size_type) bfd_coff_relsz (abfd) * asect->reloc_count;
   native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos, amt);
   amt = (bfd_size_type) asect->reloc_count * sizeof (arelent);
   reloc_cache = (arelent *) bfd_alloc (abfd, amt);
 
+  conv_table = obj_convert (abfd);
+  conv_table_size = obj_conv_table_size (abfd);
+
   if (reloc_cache == NULL)
     return false;
 
-  for (idx = 0; idx < asect->reloc_count; idx++)
+  this_vma = asect->vma;
+    } // end of misindent.
+#ifdef DYNAMIC_LINKING
+  else
+    {
+      num_relocs = pei_section_data (abfd,asect)->virt_size
+	   / bfd_coff_relsz (abfd);
+
+      native_relocs = bfd_alloc (abfd, pei_section_data(abfd,asect)->virt_size);
+      if (native_relocs == NULL)
+	return false;
+      bfd_get_section_contents(abfd, asect, native_relocs, 0, 
+				pei_section_data(abfd,asect)->virt_size);
+
+      reloc_cache = (arelent *)
+	bfd_alloc (abfd, (size_t) (num_relocs * sizeof (arelent)));
+      if (reloc_cache == NULL)
+	return false;
+
+      conv_table = NULL;
+
+      /* We'd apply the VMA of the .rel.dyn section if we
+	 used the section's vma, which is wrong! 0 is right. */
+      this_vma = 0;
+    }
+#endif
+
+  for (idx = 0; idx < num_relocs; idx++)
     {
       struct internal_reloc dst;
       struct external_reloc *src;
@@ -4904,26 +5172,57 @@ coff_slurp_reloc_table (abfd, asect, sym
 
 #ifdef RELOC_PROCESSING
       RELOC_PROCESSING (cache_ptr, &dst, symbols, abfd, asect);
+
+      if (cache_ptr->howto == NULL)
+	{
+	  (*_bfd_error_handler)
+	    (_("%s: illegal relocation type %d at address 0x%lx"),
+	     bfd_archive_filename (abfd), dst.r_type, (long) dst.r_vaddr);
+	  bfd_set_error (bfd_error_bad_value);
+	  return false;
+	}
 #else
       cache_ptr->address = dst.r_vaddr;
-
-      if (dst.r_symndx != -1)
+      /* Fill in the cache_ptr->howto field from dst.r_type;
+	 We need this very early because of use of symndx_is_value below */
+      RTYPE2HOWTO (cache_ptr, &dst);
+
+      if (cache_ptr->howto == NULL)
 	{
-	  if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd))
-	    {
-	      (*_bfd_error_handler)
-		(_("%s: warning: illegal symbol index %ld in relocs"),
-		 bfd_archive_filename (abfd), dst.r_symndx);
-	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
-	      ptr = NULL;
-	    }
-	  else
-	    {
-	      cache_ptr->sym_ptr_ptr = (symbols
-					+ obj_convert (abfd)[dst.r_symndx]);
-	      ptr = *(cache_ptr->sym_ptr_ptr);
-	    }
+	  (*_bfd_error_handler)
+	    (_("%s: illegal relocation type %d at address 0x%lx"),
+	     bfd_archive_filename (abfd), dst.r_type, (long) dst.r_vaddr);
+	  bfd_set_error (bfd_error_bad_value);
+	  return false;
 	}
+
+      if (dst.r_symndx != -1)
+	{
+	  if (dst.r_symndx < 0 || 
+	       (conv_table != NULL && dst.r_symndx >= conv_table_size))
+  	    {
+  	      (*_bfd_error_handler)
+	         (_("%s: warning: illegal symbol index %ld at offset 0x%lx in relocs"),
+		 bfd_archive_filename (abfd), dst.r_symndx, dst.r_vaddr);
+  	      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
+  	      ptr = NULL;
+  	    }
+#ifdef DYNAMIC_LINKING
+	  else if (conv_table == NULL)
+  	    {
+	      /* Dynamic link symbol tables contain no aux entries, so
+		 the index applies directly. */
+	      cache_ptr->sym_ptr_ptr = symbols + dst.r_symndx;
+  	      ptr = *(cache_ptr->sym_ptr_ptr);
+  	    }
+#endif
+  	  else
+  	    {
+  	      cache_ptr->sym_ptr_ptr = (symbols
+					+ conv_table[dst.r_symndx]);
+  	      ptr = *(cache_ptr->sym_ptr_ptr);
+  	    }
+  	}
       else
 	{
 	  cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
@@ -4940,21 +5239,11 @@ coff_slurp_reloc_table (abfd, asect, sym
       /* Calculate any reloc addend by looking at the symbol */
       CALC_ADDEND (abfd, ptr, dst, cache_ptr);
 
-      cache_ptr->address -= asect->vma;
+      cache_ptr->address -= this_vma;
 /* !!     cache_ptr->section = (asection *) NULL;*/
 
-      /* Fill in the cache_ptr->howto field from dst.r_type */
-      RTYPE2HOWTO (cache_ptr, &dst);
 #endif	/* RELOC_PROCESSING */
 
-      if (cache_ptr->howto == NULL)
-	{
-	  (*_bfd_error_handler)
-	    (_("%s: illegal relocation type %d at address 0x%lx"),
-	     bfd_archive_filename (abfd), dst.r_type, (long) dst.r_vaddr);
-	  bfd_set_error (bfd_error_bad_value);
-	  return false;
-	}
     }
 
   asect->relocation = reloc_cache;
@@ -5024,7 +5313,7 @@ coff_canonicalize_reloc (abfd, section, 
     }
   else
     {
-      if (! coff_slurp_reloc_table (abfd, section, symbols))
+      if (! coff_slurp_reloc_table (abfd, section, symbols, false))
 	return -1;
 
       tblptr = section->relocation;
@@ -5036,6 +5325,43 @@ coff_canonicalize_reloc (abfd, section, 
   return section->reloc_count;
 }
 
+/* Canonicalize the dynamic relocation entries. */
+static long coff_canonicalize_dynamic_reloc 
+    PARAMS ((bfd *, arelent **, asymbol **));
+
+static long
+coff_canonicalize_dynamic_reloc (abfd, storage, syms)
+     bfd *abfd;
+     arelent **storage;
+     asymbol **syms;
+{
+  asection *s;
+  long ret;
+  arelent *p;
+  long count, i;
+
+  if (dyn_data (abfd) == 0)
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      return -1;
+    }
+
+  ret = 0;
+  s = bfd_get_section_by_name(abfd, ".rel.dyn");
+
+  if (! coff_slurp_reloc_table (abfd, s, syms, true))
+    return -1;
+  count = pei_section_data(abfd,s)->virt_size / bfd_coff_relsz(abfd);
+  p = s->relocation;
+  for (i = 0; i < count; i++)
+    *storage++ = p++;
+  ret += count;
+
+  *storage = NULL;
+
+  return ret;
+}
+
 #ifdef GNU960
 file_ptr
 coff_sym_filepos (abfd)
@@ -5236,7 +5562,19 @@ static const bfd_coff_backend_data bfd_c
   coff_classify_symbol, coff_compute_section_file_positions,
   coff_start_final_link, coff_relocate_section, coff_rtype_to_howto,
   coff_adjust_symndx, coff_link_add_one_symbol,
-  coff_link_output_has_begun, coff_final_link_postscript
+  coff_link_output_has_begun, coff_final_link_postscript,
+  coff_canonicalize_one_symbol,
+#ifdef DYNAMIC_LINKING
+  coff_swap_dyn_in, coff_swap_dyn_out,
+  coff_swap_verdef_in, coff_swap_verdef_out,
+  coff_swap_verdaux_in, coff_swap_verdaux_out,
+  coff_swap_verneed_in, coff_swap_verneed_out,
+  coff_swap_vernaux_in, coff_swap_vernaux_out,
+  coff_swap_versym_in, coff_swap_versym_out,
+  coff_backend_link_create_dynamic_sections, coff_backend_check_relocs, 
+  coff_backend_adjust_dynamic_symbol, coff_backend_size_dynamic_sections,
+  coff_backend_finish_dynamic_symbol, coff_backend_finish_dynamic_sections,
+#endif
 };
 
 #ifndef coff_close_and_cleanup
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/coffgen.c bfd/coffgen.c
--- bfd.pre.dynlink/coffgen.c	Wed Feb  6 10:10:03 2002
+++ bfd/coffgen.c	Wed Feb  6 16:04:09 2002
@@ -58,7 +58,7 @@ static boolean coff_write_native_symbol
 static void coff_pointerize_aux
   PARAMS ((bfd *, combined_entry_type *, combined_entry_type *,
 	   unsigned int, combined_entry_type *));
-static boolean make_a_section_from_file
+static asection *make_a_section_from_file
   PARAMS ((bfd *, struct internal_scnhdr *, unsigned int));
 const bfd_target *coff_real_object_p
   PARAMS ((bfd *, unsigned, struct internal_filehdr *,
@@ -74,7 +74,7 @@ static char *copy_name
 
 /* Take a section header read from a coff file (in HOST byte order),
    and make a BFD "section" out of it.  This is used by ECOFF.  */
-static boolean
+static asection *
 make_a_section_from_file (abfd, hdr, target_index)
      bfd *abfd;
      struct internal_scnhdr *hdr;
@@ -120,15 +120,15 @@ make_a_section_from_file (abfd, hdr, tar
       /* Assorted wastage to null-terminate the name, thanks AT&T! */
       name = bfd_alloc (abfd, (bfd_size_type) sizeof (hdr->s_name) + 1);
       if (name == NULL)
-	return false;
+	return NULL;
       strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));
       name[sizeof (hdr->s_name)] = 0;
     }
 
   return_section = bfd_make_section_anyway (abfd, name);
   if (return_section == NULL)
-    return false;
-
+    return NULL;
+
   return_section->vma = hdr->s_vaddr;
   return_section->lma = hdr->s_paddr;
   return_section->_raw_size = hdr->s_size;
@@ -162,9 +162,12 @@ make_a_section_from_file (abfd, hdr, tar
   if (hdr->s_scnptr != 0)
     return_section->flags |= SEC_HAS_CONTENTS;
 
-  return result;
-}
-
+  if (!result)
+    return NULL;
+  else
+    return return_section;
+}
+
 /* Read in a COFF object and make it into a BFD.  This is used by
    ECOFF as well.  */
 
@@ -181,7 +184,10 @@ coff_real_object_p (abfd, nscns, interna
   bfd_size_type readsize;	/* length of file_info */
   unsigned int scnhsz;
   char *external_sections;
-
+#ifdef DYNAMIC_LINKING
+  boolean dynamic;
+#endif
+
   if (!(internal_f->f_flags & F_RELFLG))
     abfd->flags |= HAS_RELOC;
   if ((internal_f->f_flags & F_EXEC))
@@ -210,6 +216,14 @@ coff_real_object_p (abfd, nscns, interna
   if (tdata == NULL)
     return 0;
 
+#ifdef DYNAMIC_LINKING
+  dynamic = (abfd->flags & DYNAMIC) != 0;
+
+  if (dynamic)
+    dyn_data(abfd) =
+      (struct dynamic_info *) bfd_zalloc(abfd, sizeof (struct dynamic_info));
+#endif
+
   scnhsz = bfd_coff_scnhsz (abfd);
   readsize = (bfd_size_type) nscns * scnhsz;
   external_sections = (char *) bfd_alloc (abfd, readsize);
@@ -228,17 +242,103 @@ coff_real_object_p (abfd, nscns, interna
   if (nscns != 0)
     {
       unsigned int i;
+#ifdef DYNAMIC_LINKING
+      asection *sec;
+      const char *name;
+      coff_coffsections(abfd) = 
+	  (asection **)bfd_alloc(abfd, sizeof(asection *) * nscns);
+#endif
       for (i = 0; i < nscns; i++)
 	{
 	  struct internal_scnhdr tmp;
 	  bfd_coff_swap_scnhdr_in (abfd,
 				   (PTR) (external_sections + i * scnhsz),
 				   (PTR) & tmp);
-	  if (! make_a_section_from_file (abfd, &tmp, i + 1))
+#ifdef DYNAMIC_LINKING /* [ */
+	  sec = make_a_section_from_file (abfd, &tmp, i + 1);
+
+	  if (sec == NULL)
 	    goto fail;
+
+	  coff_coffsections(abfd)[i] = sec;
+
+	  if (dynamic)
+	    {
+	      name=bfd_get_section_name(abfd, sec);
+
+	      /* we need quick access to certain sections, so we do the name
+		 lookup once, and some other housekeeping along the way. */
+
+	      if (strcmp(name, ".dynamic") == 0)
+		{
+		  coff_dynamic(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".dynsym") == 0)
+		{
+		  coff_dynsymtab(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".dynstr") == 0)
+		{
+		  coff_dynstrtab(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".gnu.version_d") == 0)
+		{
+		  coff_dynverdef(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".gnu.version_r") == 0)
+		{
+		  coff_dynverref(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	      else if (strcmp(name, ".gnu.version") == 0)
+		{
+		  coff_dynversym(abfd) = sec;
+		  sec->info_r = sec->reloc_count;
+		  sec->info_l = sec->lineno_count;
+		  sec->lineno_count = 0;
+		  sec->reloc_count = 0;
+		}
+	    }
+
+#else /* ][ */
+	  if (make_a_section_from_file (abfd, &tmp, i + 1) == NULL)
+	    goto fail;
+#endif /* ] */
 	}
     }
 
+#ifdef DYNAMIC_LINKING
+  if (dynamic)
+    {
+      if (coff_dynamic(abfd) != NULL && coff_dynstrtab(abfd) != NULL)
+	  coff_dynamic(abfd)->link_index = coff_dynstrtab(abfd)->index;
+
+      if (coff_dynsymtab(abfd) != NULL && coff_dynstrtab(abfd) != NULL)
+	  coff_dynsymtab(abfd)->link_index = coff_dynstrtab(abfd)->index;
+
+      if (coff_dynverdef(abfd) != NULL && coff_dynversym(abfd) != NULL)
+	  coff_dynverdef(abfd)->link_index = coff_dynversym(abfd)->index;
+    }
+#endif
   /*  make_abs_section (abfd); */
 
   return abfd->xvec;
@@ -324,8 +424,10 @@ coff_section_from_bfd_index (abfd, index
      bfd *abfd;
      int index;
 {
+#ifndef DYNAMIC_LINKING
   struct sec *answer = abfd->sections;
-
+#endif
+
   if (index == N_ABS)
     return bfd_abs_section_ptr;
   if (index == N_UNDEF)
@@ -333,6 +435,13 @@ coff_section_from_bfd_index (abfd, index
   if (index == N_DEBUG)
     return bfd_abs_section_ptr;
 
+#ifdef DYNAMIC_LINKING
+  /* range check; special negatives were eliminated above */
+  if (index < 0 || index > (int)abfd->section_count)
+    return bfd_und_section_ptr;
+
+  return coff_coffsections(abfd)[index-1];
+#else
   while (answer)
     {
       if (answer->target_index == index)
@@ -343,8 +452,9 @@ coff_section_from_bfd_index (abfd, index
   /* We should not reach this point, but the SCO 3.2v4 /lib/libc_s.a
      has a bad symbol table in biglitpow.o.  */
   return bfd_und_section_ptr;
-}
-
+#endif
+}
+
 /* Get the upper bound of a COFF symbol table.  */
 
 long
@@ -593,7 +703,7 @@ coff_symbol_from (ignore_abfd, symbol)
 
 static void
 fixup_symbol_value (abfd, coff_symbol_ptr, syment)
-     bfd *abfd;
+     bfd *abfd ATTRIBUTE_UNUSED;
      coff_symbol_type *coff_symbol_ptr;
      struct internal_syment *syment;
 {
@@ -1076,7 +1186,7 @@ coff_write_alien_symbol (abfd, symbol, w
   if (symbol->flags & BSF_LOCAL)
     native->u.syment.n_sclass = C_STAT;
   else if (symbol->flags & BSF_WEAK)
-    native->u.syment.n_sclass = obj_pe (abfd) ? C_NT_WEAK : C_WEAKEXT;
+    native->u.syment.n_sclass = C_WEAKEXT;
   else
     native->u.syment.n_sclass = C_EXT;
   native->u.syment.n_numaux = 0;
@@ -2022,12 +2132,13 @@ bfd_coff_get_auxent (abfd, symbol, indx,
 /* Print out information about COFF symbol.  */
 
 void
-coff_print_symbol (abfd, filep, symbol, how)
+coff_print_symbol (abfd, filep, symbol, how, base)
      bfd *abfd;
      PTR filep;
      asymbol *symbol;
      bfd_print_symbol_type how;
-{
+     asymbol *base;
+{
   FILE *file = (FILE *) filep;
 
   switch (how)
@@ -2048,9 +2159,9 @@ coff_print_symbol (abfd, filep, symbol, 
 	  bfd_vma val;
 	  unsigned int aux;
 	  combined_entry_type *combined = coffsymbol (symbol)->native;
-	  combined_entry_type *root = obj_raw_syments (abfd);
 	  struct lineno_cache_entry *l = coffsymbol (symbol)->lineno;
-
+  	  combined_entry_type *root = coffsymbol (base)->native;
+
 	  fprintf (file, "[%3ld]", (long) (combined - root));
 
 	  if (! combined->fix_value)
@@ -2491,3 +2602,496 @@ bfd_coff_set_symbol_class (abfd, symbol,
 
   return true;
 }
+
+
+#ifdef DYNAMIC_LINKING /* [ */
+/* Create some sections which will be filled in with dynamic linking
+   information.  ABFD is an input file which requires dynamic sections
+   to be created.  The dynamic sections take up virtual memory space
+   when the final executable is run, so we need to create them before
+   addresses are assigned to the output sections.  We work out the
+   actual contents and size of these sections later.  */
+
+long
+coff_get_dynamic_symtab_upper_bound (abfd)
+     bfd *abfd;
+{
+  long symcount;
+  long symtab_size;
+  asection *hdr;
+
+  hdr = coff_dynsymtab(abfd);
+
+  if (hdr == NULL)
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      return -1;
+    }
+
+  symcount = bfd_section_size(abfd, hdr) / bfd_coff_symesz (abfd);
+  symtab_size = (symcount - 1 + 1) * (sizeof (asymbol *));
+
+  return symtab_size;
+}
+
+long
+coff_canonicalize_dynamic_symtab (abfd, alocation)
+     bfd *abfd;
+     asymbol **alocation;
+{
+  unsigned long size;
+  unsigned long strtab_size;
+  asection *dynsym;
+  asection *dynstr;
+  char *raw_src;
+  char *raw_end;
+  int sym_count;
+  bfd_size_type symesz;
+  char *string_table = NULL;
+  coff_symbol_type *cached_area;
+  int syt_index = 0;
+  combined_entry_type *isyms;
+  combined_entry_type *internal;
+  combined_entry_type *symbol_ptr;
+  unsigned int n_tmask;
+  unsigned int n_btshft;
+  unsigned int n_btmask;
+  int i;
+
+
+  n_tmask = coff_data (abfd)->local_n_tmask;
+  n_btshft = coff_data (abfd)->local_n_btshft;
+  n_btmask = coff_data (abfd)->local_n_btmask;
+
+  symesz = bfd_coff_symesz (abfd);
+
+  /* First get the dynamic symbol table */
+  dynsym = coff_dynsymtab(abfd);
+
+  if (dynsym == NULL) 
+     return 0;
+
+  sym_count = dynsym->info_r;
+
+  if (sym_count == 0)
+     return 0;
+
+  size = sym_count * symesz;
+
+  raw_src = (PTR) bfd_malloc (size);
+  if (raw_src == NULL)
+     return -1;
+  
+  if (! bfd_get_section_contents (abfd, dynsym, raw_src, (file_ptr) 0, size))
+     return -1;
+
+  /* mark the end of the symbols */
+  raw_end = (char *) raw_src + sym_count * symesz;
+
+  dynstr = coff_dynstrtab(abfd);
+
+  string_table = NULL;
+  strtab_size = 0;
+
+  if (dynstr != NULL)
+    {
+      strtab_size = bfd_section_size(abfd, dynstr); 
+      if (strtab_size == 0) abort();
+      string_table = (PTR) bfd_malloc (strtab_size);
+      if (string_table == NULL)
+          return -1;
+  
+      if (! bfd_get_section_contents (abfd, dynstr, string_table, 
+	      (file_ptr) 0, strtab_size))
+	return -1;
+    }
+
+  /* Allocate enough room for all the symbols in cached form */
+  cached_area = (coff_symbol_type *)
+	 bfd_alloc (abfd, (sym_count * sizeof (coff_symbol_type)));
+
+  if (cached_area == NULL)
+    return -1;
+
+  internal = isyms = (combined_entry_type *)
+	 bfd_alloc (abfd, (sym_count * sizeof (combined_entry_type)));
+
+  if (isyms == NULL)
+    return -1;
+
+  /* Swap all the raw entries */
+  for (; raw_src < raw_end; raw_src += symesz)
+    {
+      coff_symbol_type *dst = &cached_area[syt_index];
+
+      bfd_coff_swap_sym_in (abfd, (PTR) raw_src, (PTR)&isyms->u.syment);
+
+      /* canonicalize the name; can't use other code because it's from
+	 the dynamic symbol table here. */
+      if (isyms->u.syment._n._n_n._n_zeroes != 0)
+	{
+	  /* This is a "short" name.  Make it long.  */
+	  unsigned long i = 0;
+	  char *newstring = NULL;
+
+	  /* find the length of this string without walking into memory
+	     that isn't ours.  */
+	  for (i = 0; i < 8; ++i)
+	    {
+	      if (isyms->u.syment._n._n_name[i] == '\0')
+		{
+		  break;
+		}		/* if end of string */
+	    }		/* possible lengths of this string. */
+
+	  if ((newstring = (PTR) bfd_alloc (abfd, ++i)) == NULL)
+	    return -1;
+	  memset (newstring, 0, i);
+	  strncpy (newstring, isyms->u.syment._n._n_name, i - 1);
+	  isyms->u.syment._n._n_n._n_offset = (long int) newstring;
+	  isyms->u.syment._n._n_n._n_zeroes = 0;
+	}
+      else if (isyms->u.syment._n._n_n._n_offset == 0)
+	isyms->u.syment._n._n_n._n_offset = (long int) "";
+      else
+	{
+	  /* Long name already.  Point symbol at the string in the
+	     table.  */
+	  if (string_table == NULL)
+	    {
+		return -1;
+	    }
+	  if ((unsigned long)isyms->u.syment._n._n_n._n_offset > strtab_size
+	     || isyms->u.syment._n._n_n._n_offset < 0)
+	    {
+	        isyms->u.syment._n._n_n._n_offset = (int)"BAD SYMBOL";
+	    }
+	  isyms->u.syment._n._n_n._n_offset =
+	    ((long int)
+	     (string_table
+	      + isyms->u.syment._n._n_n._n_offset));
+	}
+
+      bfd_coff_canonicalize_one_symbol(abfd, isyms, dst);
+
+      alocation[syt_index] = (asymbol *)dst;
+
+      /* Because of C_NT_WEAK n_numaux isn't always zero. */
+      symbol_ptr = isyms;
+      for (i = 0;
+	   i < isyms->u.syment.n_numaux;
+	   i++)
+	{
+	  raw_src += symesz;
+	  isyms++;
+	  bfd_coff_swap_aux_in (abfd, (PTR) raw_src,
+				symbol_ptr->u.syment.n_type,
+				symbol_ptr->u.syment.n_sclass,
+				i, symbol_ptr->u.syment.n_numaux,
+				&(isyms->u.auxent));
+	  coff_pointerize_aux (abfd, internal, symbol_ptr, i,
+			       isyms);
+         syt_index += 1;
+	  alocation[syt_index] = NULL;
+	}
+      syt_index += 1;
+      isyms++;
+    }				/* bfdize the native symtab */
+
+  return syt_index; 
+} 			/* coff_canonicalize_dynamic_symtab() */
+
+
+/* Return the size required for the dynamic reloc entries.  Any
+   section that was actually installed in the BFD, and has type
+   SHT_REL or SHT_RELA, and uses the dynamic symbol table, is
+   considered to be a dynamic reloc section.  */
+
+long
+coff_get_dynamic_reloc_upper_bound (abfd)
+     bfd *abfd;
+{
+  long ret;
+  asection *s;
+
+  if (dyn_data (abfd) == 0)
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      return -1;
+    }
+
+  ret = sizeof (arelent *);
+  for (s = abfd->sections; s != NULL; s = s->next)
+   if (strncmp(s->name, ".rel.", 5) == 0)
+      {
+          ret += ((pei_section_data(abfd,s)->virt_size 
+		   / bfd_coff_relsz(abfd)) * sizeof (arelent *));
+      }
+
+  return ret;
+}
+
+/* A special case that assures that the first slot is used, so "real"
+   entries can assume the offset is not zero; only some stringtabs
+   (.dynstr and others derived from ELF) rely on this assumption, and
+   it could be removed, but it'd take more hunting than it's worth. */
+struct bfd_strtab_hash *
+_bfd_coff_stringtab_init ()
+{
+  struct bfd_strtab_hash *ret;
+
+  ret = _bfd_stringtab_init ();
+  if (ret != NULL)
+    {
+      bfd_size_type loc;
+
+      loc = _bfd_stringtab_add (ret, "", true, false);
+      BFD_ASSERT (loc == 0 || loc == (bfd_size_type) -1);
+      if (loc == (bfd_size_type) -1)
+        {
+          _bfd_stringtab_free (ret);
+          ret = NULL;
+        }
+    }
+  return ret;
+}
+
+/* get a string-table section */
+char *
+bfd_coff_get_str_section (abfd, shindex)
+     bfd * abfd;
+     unsigned int shindex;
+{
+  asection **i_shdrp;
+  char *shstrtab = NULL;
+  unsigned int shstrtabsize;
+  asection *sec;
+
+  i_shdrp = coff_coffsections (abfd);
+  if (i_shdrp == 0 || i_shdrp[shindex] == 0)
+    return 0;
+
+  sec = i_shdrp[shindex];
+  shstrtab = (char *) sec->contents;
+
+  if (shstrtab == NULL)
+    {
+      /* No cached one, attempt to read, and cache what we read. */
+
+      shstrtabsize = bfd_section_size(abfd, sec);
+      shstrtab = (char *) bfd_malloc (shstrtabsize);
+      if (shstrtab == NULL)
+	 return NULL;
+  
+      if (! bfd_get_section_contents (abfd, sec, shstrtab, 
+	      (file_ptr) 0, shstrtabsize))
+	 return NULL;
+
+      sec->contents = (PTR) shstrtab;
+    }
+  return shstrtab;
+}
+
+/* This is how we pick strings out of a string table section;
+   not used for the main coff string table. */
+char *
+bfd_coff_string_from_coff_section (abfd, shindex, strindex)
+     bfd * abfd;
+     unsigned int shindex;
+     unsigned int strindex;
+{
+  asection *hdr;
+
+  if (strindex == 0)
+    return "";
+
+  hdr = coff_coffsections (abfd)[shindex];
+
+  if (hdr->contents == NULL
+      && bfd_coff_get_str_section (abfd, shindex) == NULL)
+    return NULL;
+
+  return ((char *) hdr->contents) + strindex;
+}
+
+
+/* Read in the version information.  */
+
+boolean
+_bfd_coff_slurp_version_tables (abfd)
+     bfd *abfd;
+{
+  bfd_byte *contents = NULL;
+
+  if (coff_dynverdef (abfd) != 0)
+    {
+      asection *hdr;
+      coff_external_verdef *everdef;
+      coff_internal_verdef *iverdef;
+      unsigned int i;
+
+      hdr = coff_dynverdef(abfd);
+
+      dyn_data (abfd)->verdef =
+	((coff_internal_verdef *)
+	 bfd_zalloc (abfd, hdr->info_r * sizeof (coff_internal_verdef)));
+      if (dyn_data (abfd)->verdef == NULL)
+	goto error_return;
+
+      dyn_data (abfd)->cverdefs = hdr->info_r;
+
+      contents = (bfd_byte *) bfd_malloc (bfd_section_size(abfd, hdr));
+      if (contents == NULL)
+	goto error_return;
+
+      if (!bfd_get_section_contents (abfd, hdr, contents,
+	  (file_ptr) 0, bfd_section_size(abfd, hdr)))
+        goto error_return;
+
+      everdef = (coff_external_verdef *) contents;
+      iverdef = dyn_data (abfd)->verdef;
+      for (i = 0; i < hdr->info_r; i++, iverdef++)
+	{
+	  coff_external_verdaux *everdaux;
+	  coff_internal_verdaux *iverdaux;
+	  unsigned int j;
+
+	  bfd_coff_swap_verdef_in (abfd, everdef, iverdef);
+
+	  iverdef->vd_bfd = abfd;
+
+	  iverdef->vd_auxptr = ((coff_internal_verdaux *)
+				bfd_alloc (abfd,
+					   (iverdef->vd_cnt
+					    * sizeof (coff_internal_verdaux))));
+	  if (iverdef->vd_auxptr == NULL)
+	    goto error_return;
+
+	  everdaux = ((coff_external_verdaux *)
+		      ((bfd_byte *) everdef + iverdef->vd_aux));
+	  iverdaux = iverdef->vd_auxptr;
+	  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)
+	    {
+	      bfd_coff_swap_verdaux_in (abfd, everdaux, iverdaux);
+
+	      iverdaux->vda_nodename =
+		bfd_coff_string_from_coff_section (abfd, hdr->link_index,
+						 iverdaux->vda_name);
+	      if (iverdaux->vda_nodename == NULL)
+		goto error_return;
+
+	      if (j + 1 < iverdef->vd_cnt)
+		iverdaux->vda_nextptr = iverdaux + 1;
+	      else
+		iverdaux->vda_nextptr = NULL;
+
+	      everdaux = ((coff_external_verdaux *)
+			  ((bfd_byte *) everdaux + iverdaux->vda_next));
+	    }
+
+	  iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;
+
+	  if (i + 1 < hdr->info_r)
+	    iverdef->vd_nextdef = iverdef + 1;
+	  else
+	    iverdef->vd_nextdef = NULL;
+
+	  everdef = ((coff_external_verdef *)
+		     ((bfd_byte *) everdef + iverdef->vd_next));
+	}
+
+      free (contents);
+      contents = NULL;
+    }
+
+  if (coff_dynverref (abfd) != 0)
+    {
+      asection *hdr;
+      coff_external_verneed *everneed;
+      coff_internal_verneed *iverneed;
+      unsigned int i;
+
+      hdr = coff_dynverref(abfd);
+
+      dyn_data (abfd)->verref =
+	((coff_internal_verneed *)
+	 bfd_zalloc (abfd, hdr->info_r * sizeof (coff_internal_verneed)));
+      if (dyn_data (abfd)->verref == NULL)
+	goto error_return;
+
+      dyn_data (abfd)->cverrefs = hdr->info_r;
+
+      contents = (bfd_byte *) bfd_malloc (bfd_section_size(abfd, hdr));
+      if (contents == NULL)
+	goto error_return;
+
+      if (!bfd_get_section_contents (abfd, hdr, contents,
+	  (file_ptr) 0, bfd_section_size(abfd, hdr)))
+        goto error_return;
+
+      everneed = (coff_external_verneed *) contents;
+      iverneed = dyn_data (abfd)->verref;
+      for (i = 0; i < hdr->info_r; i++, iverneed++)
+	{
+	  coff_external_vernaux *evernaux;
+	  coff_internal_vernaux *ivernaux;
+	  unsigned int j;
+
+	  bfd_coff_swap_verneed_in (abfd, everneed, iverneed);
+
+	  iverneed->vn_bfd = abfd;
+
+	  iverneed->vn_filename =
+	    bfd_coff_string_from_coff_section (abfd, hdr->link_index,
+					     iverneed->vn_file);
+	  if (iverneed->vn_filename == NULL)
+	    goto error_return;
+
+	  iverneed->vn_auxptr =
+	    ((coff_internal_vernaux *)
+	     bfd_alloc (abfd,
+			iverneed->vn_cnt * sizeof (coff_internal_vernaux)));
+
+	  evernaux = ((coff_external_vernaux *)
+		      ((bfd_byte *) everneed + iverneed->vn_aux));
+	  ivernaux = iverneed->vn_auxptr;
+	  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)
+	    {
+	      bfd_coff_swap_vernaux_in (abfd, evernaux, ivernaux);
+
+	      ivernaux->vna_nodename =
+		bfd_coff_string_from_coff_section (abfd, hdr->link_index,
+						 ivernaux->vna_name);
+	      if (ivernaux->vna_nodename == NULL)
+		goto error_return;
+
+	      if (j + 1 < iverneed->vn_cnt)
+		ivernaux->vna_nextptr = ivernaux + 1;
+	      else
+		ivernaux->vna_nextptr = NULL;
+
+	      evernaux = ((coff_external_vernaux *)
+			  ((bfd_byte *) evernaux + ivernaux->vna_next));
+	    }
+
+	  if (i + 1 < hdr->info_r)
+	    iverneed->vn_nextref = iverneed + 1;
+	  else
+	    iverneed->vn_nextref = NULL;
+
+	  everneed = ((coff_external_verneed *)
+		      ((bfd_byte *) everneed + iverneed->vn_next));
+	}
+
+      free (contents);
+      contents = NULL;
+    }
+
+  return true;
+
+ error_return:
+  if (contents == NULL)
+    free (contents);
+  return false;
+}
+#endif /* ] */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/cofflink.c bfd/cofflink.c
--- bfd/cofflink.c.orig	Mon Apr  1 14:44:53 2002
+++ bfd/cofflink.c	Mon Apr  1 15:02:36 2002
@@ -28,6 +28,32 @@ Foundation, Inc., 59 Temple Place - Suit
 #include "coff/internal.h"
 #include "libcoff.h"
 
+#if defined(DYNAMIC_LINKING) && defined(USE_DLLS)
+/* DLL's require some special treatment.  There are two problems: the
+   "mechanism" symbols (e.g. __IMPORT_DESCRIPTOR_*) cannot be allowed
+   out of the the shared libs, as they will mess up subsequent links
+   against the same DLL.  (__imp_ symbols may or may not also fall under
+   this, but for different reasons.)
+
+   Secondly, it's not clear whether we want to export the DLL symbols
+   at all: do we wish to be able to override them at runtime?  If we don't
+   export, they cannot be overridden at runtime.  (This is very like
+   a "symbolic" link, except that they're not callable, either.)
+
+   Current decision: don't export any DLL symbols.  If/when we want to
+   export them, USE_DLLS should be used as a guide; mostly, that change
+   implies turning off the define.  However, a filter to remove the mechanism
+   symbols, and possibly the __imp_ symbols, needs to be added.
+   (The symbolic flag may still need to be involved?)
+
+   The runtime linker may want the __imp_ symbols to handle double
+   thunks that occur when a .so calls a DLL, and the DLL symbols were
+   provided in the main program.
+
+   Note: currently, if is_DLL_module doesn't get set, it's equivalent
+   to never recognizing that a symbol is a DLL symbol.  */
+#endif
+
 static boolean coff_link_add_object_symbols
   PARAMS ((bfd *, struct bfd_link_info *));
 static boolean coff_link_check_archive_element
@@ -40,12 +66,19 @@ static char *get_name PARAMS ((char *, c
 static int process_embedded_commands
   PARAMS ((bfd *, struct bfd_link_info *, bfd *));
 static void mark_relocs PARAMS ((struct coff_final_link_info *, bfd *));
-
-/* Return true if SYM is a weak, external symbol.  */
+static boolean coff_merge_symbol
+  PARAMS ((bfd *, struct bfd_link_info *, const char *, 
+	   struct internal_syment *,
+	   enum coff_symbol_classification,
+	   asection **, bfd_vma *, struct coff_link_hash_entry **,
+	   boolean, boolean *, boolean *, boolean *));
+
+/* Return true if SYM is a weak, external symbol. C_NT_WEAK, being really
+   an alias, should not be tested for this way because it almost always
+   is wrong. */
 #define IS_WEAK_EXTERNAL(abfd, sym)			\
-  ((sym).n_sclass == C_WEAKEXT				\
-   || (obj_pe (abfd) && (sym).n_sclass == C_NT_WEAK))
-
+  ((sym).n_sclass == C_WEAKEXT)
+
 /* Return true if SYM is an external symbol.  */
 #define IS_EXTERNAL(abfd, sym)				\
   ((sym).n_sclass == C_EXT || IS_WEAK_EXTERNAL (abfd, sym))
@@ -91,6 +124,27 @@ _bfd_coff_link_hash_newfunc (entry, tabl
       ret->numaux = 0;
       ret->auxbfd = NULL;
       ret->aux = NULL;
+#ifdef DYNAMIC_LINKING
+      ret->dynindx = -1;
+      ret->dynstr_index = 0;
+#ifdef USE_WEAK
+      ret->weakdef = NULL;
+#endif
+      ret->got_offset = -1;
+      ret->plt_offset = -1;
+      ret->coff_link_hash_flags = 0;
+      ret->num_long_relocs_needed = 0;
+      ret->num_relative_relocs_needed = 0;
+#ifdef USE_SIZE
+      ret->size = 0;
+#endif
+      ret->verinfo.verdef = NULL;
+      /* Assume that we have been called by a non-COFF symbol reader.
+         This flag is then reset by the code which reads a COFF input
+         file.  This ensures that a symbol created by a non-COFF symbol
+         reader will have the flag set correctly.  */
+      ret->coff_link_hash_flags = COFF_LINK_NON_COFF;
+#endif
     }
 
   return (struct bfd_hash_entry *) ret;
@@ -107,6 +161,19 @@ _bfd_coff_link_hash_table_init (table, a
 						const char *));
 {
   table->stab_info = NULL;
+#ifdef DYNAMIC_LINKING
+  table->dynamic_sections_created = false;
+  table->dynobj = NULL;
+  table->dynsymcount = 1; /* Dummy entry for special info. */
+  table->dynstr = NULL;
+  table->needed = NULL;
+  table->hgot = NULL;
+  table->sreloc = NULL;
+  table->sgot = NULL;
+  table->sgotplt = NULL;
+  table->srelgot = NULL;
+  table->dynamic = NULL;
+#endif
   return _bfd_link_hash_table_init (&table->root, abfd, newfunc);
 }
 
@@ -184,6 +251,478 @@ _bfd_coff_link_add_symbols (abfd, info)
     }
 }
 
+/* This function is called when we want to define a new symbol.  It
+   handles the various cases which arise when we find a definition in
+   a dynamic object, or when there is already a definition in a
+   dynamic object.  The new symbol is described by NAME, SYM, PSEC,
+   and PVALUE.  We set SYM_HASH to the hash table entry.  We set
+   OVERRIDE if the old symbol is overriding a new definition.  We set
+   TYPE_CHANGE_OK if it is OK for the type to change.  We set
+   SIZE_CHANGE_OK if it is OK for the size to change.  By OK to
+   change, we mean that we shouldn't warn if the type or size does
+   change.  */
+
+static boolean
+coff_merge_symbol (abfd, info, name, sym, classification, psec, pvalue, 
+                  sym_hash, copy, override, type_change_ok, size_change_ok)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     const char *name;
+     struct internal_syment *sym;
+     enum coff_symbol_classification classification;
+     asection **psec;
+     bfd_vma *pvalue ATTRIBUTE_UNUSED;
+     struct coff_link_hash_entry **sym_hash;
+     boolean copy;
+     boolean *override;
+     boolean *type_change_ok;
+     boolean *size_change_ok;
+{
+  asection *sec;
+  struct coff_link_hash_entry *h;
+  struct coff_link_hash_entry *h_real;
+  boolean new_is_weak;
+  boolean old_is_weak_def;
+  bfd *oldbfd;
+  boolean newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
+
+  unsigned int n_tmask = coff_data (abfd)->local_n_tmask;
+  unsigned int n_btshft = coff_data (abfd)->local_n_btshft;
+
+  *override = false;
+
+  sec = *psec;
+
+  if (! bfd_is_und_section (sec))
+    h = coff_link_hash_lookup 
+	  (coff_hash_table (info), name, true, copy, false);
+  else
+    h = ((struct coff_link_hash_entry *)
+	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, copy, false));
+
+  if (h == NULL)
+    return false;
+
+  *sym_hash = h;
+
+  /* This code is for coping with dynamic objects, and is only useful
+     if we are doing an COFF link.  */
+  if (abfd->xvec != info->hash->creator
+     && abfd->xvec != info->hash->creator->input_format)
+    return true;
+
+  /* For merging, we only care about real symbols.
+
+     For PE Weaks, we work on the alias name.  (Weakness is a 
+     property of the alias.) */
+  while ((h->root.type == bfd_link_hash_indirect
+	   && !h->root.u.i.info.alias)
+	 || h->root.type == bfd_link_hash_warning)
+    h = (struct coff_link_hash_entry *) h->root.u.i.link;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    {
+      /* Implicitly it's an alias! */
+      old_is_weak_def = true;
+    }
+  else
+    old_is_weak_def = (h->root.type == bfd_link_hash_defweak);
+
+  new_is_weak = sym->n_sclass == C_WEAKEXT
+	  || (obj_pe (abfd) && sym->n_sclass == C_NT_WEAK);
+
+
+  /* If we just created the symbol, mark it as being a COFF symbol.
+     Other than that, there is nothing to do--there is no merge issue
+     with a newly defined symbol--so we just return.  */
+
+  if (h->root.type == bfd_link_hash_new)
+    {
+      h->coff_link_hash_flags &= ~COFF_LINK_NON_COFF;
+      return true;
+    }
+
+  /* OLDBFD is a BFD associated with the existing symbol.  For 
+     indirects and warnings, we'll get it from the real symbol. 
+     Don't care if it's an alias or not. */
+  h_real = h;
+  while (h_real->root.type == bfd_link_hash_indirect
+	 || h_real->root.type == bfd_link_hash_warning)
+    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+  switch (h_real->root.type)
+    {
+    default:
+      oldbfd = NULL;
+      break;
+
+    case bfd_link_hash_undefined:
+    case bfd_link_hash_undefweak:
+      oldbfd = h_real->root.u.undef.abfd;
+      break;
+
+    case bfd_link_hash_defined:
+    case bfd_link_hash_defweak:
+      oldbfd = h_real->root.u.def.section->owner;
+      break;
+
+    case bfd_link_hash_common:
+      oldbfd = h_real->root.u.c.p->section->owner;
+      break;
+    }
+
+  /* In cases involving weak versioned symbols, we may wind up trying
+     to merge a symbol with itself.  Catch that here, to avoid the
+     confusion that results if we try to override a symbol with
+     itself.  The additional tests catch cases like
+     _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a
+     dynamic object, which we do want to handle here.  */
+  if (abfd == oldbfd
+      && ((abfd->flags & DYNAMIC) == 0
+	  || (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0))
+    return true;
+
+  /* NEWDYN and OLDDYN indicate whether the new or old symbol,
+     respectively, is from a dynamic object.  */
+
+  if ((abfd->flags & DYNAMIC) != 0)
+    newdyn = true;
+  else
+    newdyn = false;
+
+  if (oldbfd != NULL)
+    olddyn = (oldbfd->flags & DYNAMIC) != 0;
+  else
+    {
+      /* This should be a pretty rare event.  Imposible? */
+      olddyn = false;
+    }
+
+  /* NEWDEF and OLDDEF indicate whether the new or old symbol,
+     respectively, appear to be a definition rather than reference.  */
+
+  newdef = (classification == COFF_SYMBOL_GLOBAL);
+
+  if (h->root.type == bfd_link_hash_undefined
+      || h->root.type == bfd_link_hash_undefweak
+      || h->root.type == bfd_link_hash_common)
+    olddef = false;
+  else
+    olddef = true;
+
+  /* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old
+     symbol, respectively, appears to be a common symbol in a dynamic
+     object.  If a symbol appears in an uninitialized section, and is
+     not weak, and is not a function, then it may be a common symbol
+     which was resolved when the dynamic object was created.  We want
+     to treat such symbols specially, because they raise special
+     considerations when setting the symbol size: if the symbol
+     appears as a common symbol in a regular object, and the size in
+     the regular object is larger, we must make sure that we use the
+     larger size.  This problematic case can always be avoided in C,
+     but it must be handled correctly when using Fortran shared
+     libraries.
+
+     Note that if NEWDYNCOMMON is set, NEWDEF will be set, and
+     likewise for OLDDYNCOMMON and OLDDEF.
+
+     Note that this test is just a heuristic, and that it is quite
+     possible to have an uninitialized symbol in a shared object which
+     is really a definition, rather than a common symbol.  This could
+     lead to some minor confusion when the symbol really is a common
+     symbol in some regular object.  However, I think it will be
+     harmless.  */
+
+  if (newdyn
+      && newdef
+      && (sec->flags & SEC_ALLOC) != 0
+      && (sec->flags & SEC_LOAD) == 0
+#ifdef USE_SIZE
+      && sym->st_size > 0
+#endif
+      && !new_is_weak
+      && !ISFCN(sym->n_type))
+    newdyncommon = true;
+  else
+    newdyncommon = false;
+
+  if (olddyn
+      && olddef
+      && h->root.type == bfd_link_hash_defined
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+      && (h->root.u.def.section->flags & SEC_ALLOC) != 0
+      && (h->root.u.def.section->flags & SEC_LOAD) == 0
+#ifdef USE_SIZE
+      && h->size > 0
+#endif
+      && !ISFCN(h->type))
+    olddyncommon = true;
+  else
+    olddyncommon = false;
+
+  /* It's OK to change the type if either the existing symbol or the
+     new symbol is weak.  */
+
+  if (old_is_weak_def
+      || h->root.type == bfd_link_hash_undefweak
+      || new_is_weak)
+    *type_change_ok = true;
+
+  /* It's OK to change the size if either the existing symbol or the
+     new symbol is weak, or if the old symbol is undefined.  */
+
+  if (*type_change_ok
+      || h->root.type == bfd_link_hash_undefined)
+    *size_change_ok = true;
+
+#ifdef USE_SIZE
+  /* If both the old and the new symbols look like common symbols in a
+     dynamic object, set the size of the symbol to the larger of the
+     two.  */
+
+  if (olddyncommon
+      && newdyncommon
+      && sym->st_size != h->size)
+    {
+      /* Since we think we have two common symbols, issue a multiple
+         common warning if desired.  Note that we only warn if the
+         size is different.  If the size is the same, we simply let
+         the old symbol override the new one as normally happens with
+         symbols defined in dynamic objects.  */
+
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->size, abfd, bfd_link_hash_common, sym->st_size)))
+	return false;
+
+      if (sym->st_size > h->size)
+	h->size = sym->st_size;
+
+      *size_change_ok = true;
+    }
+#endif
+
+  /* If we are looking at a dynamic object, and we have found a
+     definition, we need to see if the symbol was already defined by
+     some other object.  If so, we want to use the existing
+     definition, and we do not want to report a multiple symbol
+     definition error; we do this by clobbering *PSEC to be
+     bfd_und_section_ptr.
+
+     We treat a common symbol as a definition if the symbol in the
+     shared library is a function, since common symbols always
+     represent variables; this can cause confusion in principle, but
+     any such confusion would seem to indicate an erroneous program or
+     shared library.  We also permit a common symbol in a regular
+     object to override a weak symbol in a shared object.
+
+     We prefer a non-weak definition in a shared library to a weak
+     definition in the executable.  */
+
+  if (newdyn
+      && newdef
+      && (olddef
+	  || (h->root.type == bfd_link_hash_common
+	      && (new_is_weak
+                  || ISFCN(sym->n_type))))
+      && (!old_is_weak_def
+	  || new_is_weak))
+    {
+      *override = true;
+      newdef = false;
+      newdyncommon = false;
+
+      *psec = sec = bfd_und_section_ptr;
+      *size_change_ok = true;
+
+      /* If we get here when the old symbol is a common symbol, then
+         we are explicitly letting it override a weak symbol or
+         function in a dynamic object, and we don't want to warn about
+         a type change.  If the old symbol is a defined symbol, a type
+         change warning may still be appropriate.  */
+
+      if (h->root.type == bfd_link_hash_common)
+	*type_change_ok = true;
+    }
+
+  /* Handle the special case of an old common symbol merging with a
+     new symbol which looks like a common symbol in a shared object.
+     We change *PSEC and *PVALUE to make the new symbol look like a
+     common symbol, and let _bfd_generic_link_add_one_symbol will do
+     the right thing.  */
+
+  if (newdyncommon
+      && h->root.type == bfd_link_hash_common)
+    {
+      *override = true;
+      newdef = false;
+      newdyncommon = false;
+#ifdef USE_SIZE
+      *pvalue = sym->st_size;
+#endif
+      *psec = sec = bfd_com_section_ptr;
+      *size_change_ok = true;
+    }
+
+  /* If the old symbol is from a dynamic object, and the new symbol is
+     a definition which is not from a dynamic object, then the new
+     symbol overrides the old symbol.  Symbols from regular files
+     always take precedence over symbols from dynamic objects, even if
+     they are defined after the dynamic object in the link.
+
+     As above, we again permit a common symbol in a regular object to
+     override a definition in a shared object if the shared object
+     symbol is a function or is weak.
+
+     As above, we permit a non-weak definition in a shared object to
+     override a weak definition in a regular object. 
+
+     Elf doesn't permit a strong symbol which follows a weak definition
+     to override the weak definition if shared libs are not involved.
+     We do.  */
+
+  if (! newdyn
+      && (newdef
+	  || (bfd_is_com_section (sec)
+	      && (old_is_weak_def
+                  || ISFCN(h->type))))
+      && olddyn
+      && olddef
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+      && !new_is_weak)
+    {
+      /* Change the hash table entry to undefined, and let
+	 _bfd_generic_link_add_one_symbol do the right thing with the
+	 new definition.  */
+
+      h->root.type = bfd_link_hash_undefined;
+      /* grub the owner (of the target of the alias, really) out
+	 of the alias link.  (Or here, if not an indirect!) */
+      if (h_real->root.type == bfd_link_hash_undefined)
+	h->root.u.undef.abfd = h_real->root.u.undef.abfd;
+      else
+	h->root.u.undef.abfd = h_real->root.u.def.section->owner;
+
+      /* To make this work we have to frob the flags so that the rest
+         of the code does not think we are using the prior type
+	 of definition (regular or dynamic).  Elf doesn't care, but
+	 the relocation counting code is very touchy about this. */
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+      else if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_DYNAMIC;
+      h->coff_link_hash_flags &= ~ (COFF_LINK_HASH_DEF_REGULAR
+				   | COFF_LINK_HASH_DEF_DYNAMIC);
+      *size_change_ok = true;
+
+      olddef = false;
+      olddyncommon = false;
+
+      /* We again permit a type change when a common symbol may be
+         overriding a function.  */
+
+      if (bfd_is_com_section (sec))
+	*type_change_ok = true;
+
+      /* This union may have been set to be non-NULL when this symbol
+	 was seen in a dynamic object.  We must force the union to be
+	 NULL, so that it is correct for a regular symbol.  */
+
+      h->verinfo.vertree = NULL;
+
+      /* In this special case, if H is the target of an indirection,
+         we want the caller to frob with H rather than with the
+         indirect symbol.  That will permit the caller to redefine the
+         target of the indirection, rather than the indirect symbol
+         itself.  FIXME: This will break the -y option if we store a
+         symbol with a different name.  */
+      *sym_hash = h;
+    }
+
+  /* Handle the special case of a new common symbol merging with an
+     old symbol that looks like it might be a common symbol defined in
+     a shared object.  Note that we have already handled the case in
+     which a new common symbol should simply override the definition
+     in the shared library.  */
+
+  if (! newdyn
+      && bfd_is_com_section (sec)
+      && olddyncommon)
+    {
+      /* It would be best if we could set the hash table entry to a
+	 common symbol, but we don't know what to use for the section
+	 or the alignment.  */
+      if (! ((*info->callbacks->multiple_common)
+	     (info, h->root.root.string, oldbfd, bfd_link_hash_common,
+	      h->root.u.c.size, abfd, bfd_link_hash_common, sym->n_value)))
+	return false;
+
+#ifdef USE_SIZE
+      /* If the presumed common symbol in the dynamic object is
+         larger, pretend that the new symbol has its size.  */
+
+      if (h->size > *pvalue)
+	*pvalue = h->size;
+#endif
+
+      /* FIXME: We no longer know the alignment required by the symbol
+	 in the dynamic object, so we just wind up using the one from
+	 the regular object.  */
+
+      olddef = false;
+      olddyncommon = false;
+
+      h->root.type = bfd_link_hash_undefined;
+      h->root.u.undef.abfd = h->root.u.def.section->owner;
+
+      *size_change_ok = true;
+      *type_change_ok = true;
+
+      h->verinfo.vertree = NULL;
+    }
+
+  /* Handle the special case of a weak definition in a regular object
+     followed by a non-weak definition in a shared object.  In this
+     case, we prefer the definition in the shared object.  */
+  if (olddef
+      && old_is_weak_def
+      && newdef
+      && newdyn
+      && !new_is_weak)
+    {
+      /* To make this work we have to frob the flags so that the rest
+         of the code does not think we are using the regular
+         definition.  */
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+      else if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_DYNAMIC;
+      h->coff_link_hash_flags &= ~ (COFF_LINK_HASH_DEF_REGULAR
+				   | COFF_LINK_HASH_DEF_DYNAMIC);
+
+      /* If H is the target of an indirection, we want the caller to
+         use H rather than the indirect symbol.  Otherwise if we are
+         defining a new indirect symbol we will wind up attaching it
+         to the entry we are overriding.  */
+      *sym_hash = h;
+    }
+
+  /* Handle the special case of a non-weak definition in a shared
+     object followed by a weak definition in a regular object.  In
+     this case we prefer to definition in the shared object.  To make
+     this work we have to tell the caller to not treat the new symbol
+     as a definition.  */
+  if (olddef
+      && olddyn
+      && ! old_is_weak_def
+      && newdef
+      && ! newdyn
+      && new_is_weak)
+    *override = true;
+
+  return true;
+}
+
 /* Add symbols from a COFF object file.  */
 
 static boolean
@@ -308,6 +847,11 @@ coff_link_check_ar_symbols (abfd, info, 
   return true;
 }
 
+#ifdef DYNAMIC_LINKING
+static boolean coff_link_create_dynamic_sections
+  PARAMS ((bfd *abfd, struct bfd_link_info *info));
+#endif
+
 /* Add all the symbols from an object file to the hash table.  */
 
 static boolean
@@ -326,7 +870,23 @@ coff_link_add_symbols (abfd, info)
   bfd_byte *esym;
   bfd_byte *esym_end;
   bfd_size_type amt;
-
+  long sym_idx;
+  boolean size_change_ok, type_change_ok;
+#ifdef DYNAMIC_LINKING
+  bfd_byte *buf = NULL; /* For housekeeping purposes */
+  boolean dynamic;
+  boolean using_dynsymtab;
+  asection *dynsym = NULL;
+  char *dynstrings = NULL;
+  coff_external_versym *extversym = NULL;
+  coff_external_versym *ever;
+
+  coff_external_dyn *dynbuf = NULL;
+#ifdef USE_DLLS
+  boolean is_DLL_module;
+#endif
+#endif
+
   /* Keep the symbols during this function, in case the linker needs
      to read the generic symbols in order to report an error message.  */
   keep_syms = obj_coff_keep_syms (abfd);
@@ -337,8 +897,217 @@ coff_link_add_symbols (abfd, info)
   else
     default_copy = true;
 
-  symcount = obj_raw_syment_count (abfd);
-
+#ifdef DYNAMIC_LINKING /* [ */
+#ifdef USE_DLLS
+
+  /* Properly this belongs in the archive reading code, but since this
+     is the only place that uses it, I'll let locality dominate. */
+  if (bfd_my_archive(abfd) != NULL)
+    {
+       struct dll_info {
+	  boolean is_DLL;
+       };
+#define ar_dllinfo(abfd) ((struct dll_info *)bfd_my_archive(abfd)->tdata.aout_ar_data->tdata)
+
+       if (ar_dllinfo(abfd) == NULL)
+	 {
+            (bfd_my_archive(abfd)->tdata.aout_ar_data->tdata)
+	       = bfd_alloc(abfd, sizeof(struct dll_info));
+	    if (bfd_my_archive(abfd)->tdata.aout_ar_data->tdata == NULL)
+	       return false;
+            ar_dllinfo(abfd)->is_DLL =
+                     bfd_get_section_by_name (abfd, ".idata$6") != NULL
+                  || bfd_get_section_by_name (abfd, ".idata$2") != NULL
+                  || bfd_get_section_by_name (abfd, ".idata$3") != NULL;
+	 }
+       is_DLL_module = ar_dllinfo(abfd)->is_DLL;
+    }
+  else
+       is_DLL_module = false;
+
+#endif
+
+  if ((abfd->flags & DYNAMIC) == 0)
+    dynamic = false;
+  else
+    {
+      dynamic = true;
+
+      if ((abfd->flags & NO_LINK) != 0)
+	{
+	  (*_bfd_error_handler)
+		(_("%s: Linking with this file is prohibited.\n"), abfd->filename);
+	  bfd_set_error (bfd_error_invalid_operation);
+	  goto error_return;
+	}
+      /* You can't use -r against a dynamic object.  Also, there's no
+	 hope of using a dynamic object which does not exactly match
+	 the format of the output file.  */
+      /* A PE shared executable is PEI, so this works for PE. */
+      if (info->relocateable || info->hash->creator != abfd->xvec)
+	{
+	  bfd_set_error (bfd_error_invalid_operation);
+	  goto error_return;
+	}
+    }
+
+  /* As a GNU extension, any input sections which are named
+     .gnu.warning.SYMBOL are treated as warning symbols for the given
+     symbol.  This differs from .gnu.warning sections, which generate
+     warnings when they are included in an output file.  */
+  if (! info->shared)
+    {
+      asection *s;
+
+      for (s = abfd->sections; s != NULL; s = s->next)
+	{
+	  const char *name;
+
+	  name = bfd_get_section_name (abfd, s);
+	  if (strncmp (name, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0)
+	    {
+	      char *msg;
+	      bfd_size_type sz;
+
+	      name += sizeof ".gnu.warning." - 1;
+
+	      /* If this is a shared object, then look up the symbol
+		 in the hash table.  If it is there, and it is already
+		 been defined, then we will not be using the entry
+		 from this shared object, so we don't need to warn.
+		 FIXME: If we see the definition in a regular object
+		 later on, we will warn, but we shouldn't.  The only
+		 fix is to keep track of what warnings we are supposed
+		 to emit, and then handle them all at the end of the
+		 link.  */
+	      if (dynamic
+		  && (abfd->xvec == info->hash->creator
+		     || abfd->xvec == info->hash->creator->input_format))
+		{
+		  struct coff_link_hash_entry *h;
+
+		  h = coff_link_hash_lookup (coff_hash_table (info), name,
+					    false, false, true);
+
+		  /* FIXME: What about bfd_link_hash_common?  */
+		  if (h != NULL
+		      && (h->root.type == bfd_link_hash_defined
+			  || h->root.type == bfd_link_hash_defweak))
+		    {
+		      /* We don't want to issue this warning.  Clobber
+                         the section size so that the warning does not
+                         get copied into the output file.  */
+		      s->_raw_size = 0;
+		      continue;
+		    }
+		}
+
+	      sz = bfd_section_size (abfd, s);
+	      msg = (char *) bfd_alloc (abfd, sz);
+	      if (msg == NULL)
+		goto error_return;
+
+	      if (! bfd_get_section_contents (abfd, s, msg, (file_ptr) 0, sz))
+		goto error_return;
+
+	      if (! (bfd_coff_link_add_one_symbol
+		     (info, abfd, name, BSF_WARNING, s, (bfd_vma) 0, msg,
+		      false, false,
+		      (struct bfd_link_hash_entry **) NULL)))
+		goto error_return;
+
+	      if (! info->relocateable)
+		{
+		  /* Clobber the section size so that the warning does
+                     not get copied into the output file.  */
+		  s->_raw_size = 0;
+		}
+	    }
+	}
+    }
+
+
+  if (dynamic)
+    {
+      /* Read in any version definitions.  */
+
+      /* Elf now uses a slurp... we could if we needed to. */
+      if (coff_dynverdef (abfd) != 0)
+	{
+	  asection *verdefhdr;
+	  bfd_byte *dynver;
+	  unsigned int i;
+	  const coff_external_verdef *extverdef;
+	  coff_internal_verdef *intverdef;
+
+	  /* allocate space for the internals */
+	  verdefhdr = coff_dynverdef(abfd);
+	  dyn_data (abfd)->verdef =
+	    ((coff_internal_verdef *)
+	     bfd_zalloc (abfd,
+			 verdefhdr->info_r * sizeof (coff_internal_verdef)));
+	  if (dyn_data (abfd)->verdef == NULL)
+	    goto error_return;
+
+	  /* make temp space for the externals */
+	  dynver = (bfd_byte *) bfd_malloc (bfd_section_size(abfd, verdefhdr));
+	  if (dynver == NULL)
+	    goto error_return;
+
+          if (!bfd_get_section_contents (abfd, verdefhdr, dynver, 
+	      (file_ptr) 0, bfd_section_size(abfd, verdefhdr)))
+	    goto error_return;
+
+	  extverdef = (const coff_external_verdef *) dynver;
+	  intverdef = dyn_data (abfd)->verdef;
+	  for (i = 0; i < verdefhdr->info_r; i++, intverdef++)
+	    {
+	      const coff_external_verdaux *extverdaux;
+	      coff_internal_verdaux intverdaux;
+
+	      bfd_coff_swap_verdef_in (abfd, extverdef, intverdef);
+
+	      /* Pick up the name of the version.  */
+	      extverdaux = ((const coff_external_verdaux *)
+			    ((bfd_byte *) extverdef + intverdef->vd_aux));
+	      bfd_coff_swap_verdaux_in (abfd, extverdaux, &intverdaux);
+
+	      intverdef->vd_bfd = abfd;
+	      intverdef->vd_nodename =
+		bfd_coff_string_from_coff_section (abfd, verdefhdr->link_index,
+						 intverdaux.vda_name);
+
+	      extverdef = ((const coff_external_verdef *)
+			   ((bfd_byte *) extverdef + intverdef->vd_next));
+	    }
+
+	  free (dynver);
+	  dynver = NULL;
+	}
+
+      /* Read in the symbol versions, but don't bother to convert them
+         to internal format.  */
+      if (coff_dynversym (abfd) != 0)
+	{
+	  asection *versymhdr;
+
+	  versymhdr = coff_dynversym(abfd);
+	  extversym = (coff_external_versym *) 
+	      bfd_malloc (bfd_section_size(abfd, versymhdr));
+	  if (extversym == NULL)
+	    goto error_return;
+          if (!bfd_get_section_contents (abfd, versymhdr, extversym, 
+	      (file_ptr) 0, bfd_section_size(abfd, versymhdr)))
+	    goto error_return;
+	}
+    }
+
+  if (dynamic)
+      symcount = coff_get_dynamic_symtab_upper_bound (abfd);
+    else
+#endif /* ] */
+      symcount = obj_raw_syment_count (abfd);
+
   /* We keep a list of the linker hash table entries that correspond
      to particular symbols.  */
   amt = symcount * sizeof (struct coff_link_hash_entry *);
@@ -351,16 +1120,284 @@ coff_link_add_symbols (abfd, info)
 
   symesz = bfd_coff_symesz (abfd);
   BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));
+
+#ifdef DYNAMIC_LINKING /* [ */
+  /* If this is a dynamic object, we always link against the .dynsym
+     symbol table, not the main symbol table.  The dynamic linker
+     will only see the .dynsym symbol table, so there is no reason to
+     look at the main one for a dynamic object. 
+
+     This must be done at this point, because if this is the first
+     bfd which is dynamic, the code below will "recycle" it to use
+     it to hold the output dynamic sections, after having tossed
+     the input sections (which, rightly, should not participate
+     in the link.)  */
+
+  if (dynamic) 
+      dynsym = coff_dynsymtab(abfd);
+  if (! dynamic || dynsym == NULL)
+    {
+      esym = (bfd_byte *) obj_coff_external_syms (abfd);
+      esym_end = esym + symcount * symesz;
+      using_dynsymtab = false;
+      sym_idx=0;
+    }
+  else
+    {
+      int size;
+
+      /* We have to get the actual count from the header, rather than dealing
+	 with the size, because we don't have an "actual" size, but rather
+	 a rounded one. */
+      symcount = dynsym->info_r;
+
+      if (symcount == 0)
+	 goto error_return;
+
+      size = symcount * symesz;
+      buf = esym = (bfd_byte *) bfd_malloc (size);
+      if (esym == NULL)
+	 goto error_return;
+      
+      if (! bfd_get_section_contents (abfd, dynsym, 
+				      (bfd_byte *)esym, (file_ptr) 0, size))
+	 goto error_return;
+
+      esym_end = esym + symcount * symesz;
+
+      /* Skip the first (junk) entry */
+      esym = esym + symesz;
+      /* But the hash table has to match. */
+      sym_hash++;
+
+      dynstrings = bfd_coff_get_str_section (abfd, dynsym->link_index);
+
+      using_dynsymtab = true;
+      sym_idx=1;
+    }
+#else /* ][ */
   esym = (bfd_byte *) obj_coff_external_syms (abfd);
   esym_end = esym + symcount * symesz;
+  sym_idx=0;
+#endif /* ] */
+
+
+#ifdef DYNAMIC_LINKING /* [ */
+  if (! dynamic)
+    {
+      /* If we are creating a shared library, create all the dynamic
+         sections immediately.  We need to attach them to something,
+         so we attach them to this BFD, provided it is the right
+         format.  FIXME: If there are no input BFD's of the same
+         format as the output, we can't make a shared library.  */
+      if (info->shared
+	  && ! coff_hash_table (info)->dynamic_sections_created
+	  && (abfd->xvec == info->hash->creator
+	     || abfd->xvec == info->hash->creator->input_format)
+	  )
+	{
+	  if (! coff_link_create_dynamic_sections (abfd, info))
+	    goto error_return;
+	}
+    }
+  else
+    {
+      asection *s;
+      boolean add_needed;
+      const char *name;
+      bfd_size_type oldsize;
+      bfd_size_type strindex;
+
+      /* Find the name to use in a DT_NEEDED entry that refers to this
+	 object.  If the object has a DT_SONAME entry, we use it.
+	 Otherwise, if the generic linker stuck something in
+	 coff_dt_name, we use that.  Otherwise, we just use the file
+	 name.  If the generic linker put a null string into
+	 coff_dt_name, we don't make a DT_NEEDED entry at all, even if
+	 there is a DT_SONAME entry.  */
+      add_needed = true;
+      name = bfd_get_filename (abfd);
+      if (coff_dt_name (abfd) != NULL)
+	{
+	  name = coff_dt_name (abfd);
+	  if (*name == '\0')
+	    add_needed = false;
+	}
+
+      /* Now get the .dynamic section from this file and merge it into ours. */
+      s = coff_dynamic(abfd);
+      if (s != NULL)
+	{
+	  coff_external_dyn *extdyn;
+	  coff_external_dyn *extdynend;
+	  unsigned long link;
+
+	  dynbuf = (coff_external_dyn *) bfd_malloc ((size_t) s->_raw_size);
+	  if (dynbuf == NULL)
+	    goto error_return;
+
+	  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf,
+					  (file_ptr) 0, s->_raw_size))
+	    goto error_return;
+
+	  link = s->link_index;
+
+	  extdyn = dynbuf;
+	  extdynend = extdyn + s->_raw_size / sizeof (coff_external_dyn);
+	  for (; extdyn < extdynend; extdyn++)
+	    {
+	      coff_internal_dyn dyn;
+
+	      bfd_coff_swap_dyn_in (abfd, extdyn, &dyn);
+	      if (dyn.d_tag == DT_SONAME)
+		{
+		  name = bfd_coff_string_from_coff_section (abfd, link,
+							  dyn.d_un.d_val);
+		  if (name == NULL)
+		    goto error_return;
+		}
+	      if (dyn.d_tag == DT_NEEDED)
+		{
+		  struct bfd_link_needed_list *n, **pn;
+		  char *fnm, *anm;
+
+		  n = ((struct bfd_link_needed_list *)
+		       bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
+		  fnm = bfd_coff_string_from_coff_section (abfd, link,
+							 dyn.d_un.d_val);
+		  if (n == NULL || fnm == NULL)
+		    goto error_return;
+		  anm = bfd_alloc (abfd, strlen (fnm) + 1);
+		  if (anm == NULL)
+		    goto error_return;
+		  strcpy (anm, fnm);
+		  n->name = anm;
+		  n->by = abfd;
+		  n->next = NULL;
+		  for (pn = &coff_hash_table (info)->needed;
+		       *pn != NULL;
+		       pn = &(*pn)->next)
+		    ;
+		  *pn = n;
+		}
+	    }
+
+	  free (dynbuf);
+	  dynbuf = NULL;
+	}
+
+      /* If this is the first dynamic object found in the link, create
+	 the special sections required for dynamic linking.  */
+      if (! coff_hash_table (info)->dynamic_sections_created)
+	{
+	  if (! coff_link_create_dynamic_sections (abfd, info))
+	    goto error_return;
+	}
+
+      if (add_needed)
+	{
+	  /* Add a DT_NEEDED entry for this dynamic object.  */
+	  oldsize = _bfd_stringtab_size (coff_hash_table (info)->dynstr);
+	  strindex = _bfd_stringtab_add (coff_hash_table (info)->dynstr, name,
+					 true, false);
+	  if (strindex == (bfd_size_type) -1)
+	    goto error_return;
+
+	  if (oldsize == _bfd_stringtab_size (coff_hash_table (info)->dynstr))
+	    {
+	      asection *sdyn;
+	      coff_external_dyn *dyncon, *dynconend;
+
+	      /* The hash table size did not change, which means that
+		 the dynamic object name was already entered.  If we
+		 have already included this dynamic object in the
+		 link, just ignore it.  There is no reason to include
+		 a particular dynamic object more than once.  */
+	      sdyn = coff_hash_table (info)->dynamic;
+	      BFD_ASSERT (sdyn != NULL);
+
+	      dyncon = (coff_external_dyn *) sdyn->contents;
+	      dynconend = (coff_external_dyn *) (sdyn->contents +
+						sdyn->_raw_size);
+	      for (; dyncon < dynconend; dyncon++)
+		{
+		  coff_internal_dyn dyn;
+
+		  bfd_coff_swap_dyn_in (coff_hash_table (info)->dynobj, dyncon,
+				   &dyn);
+		  if (dyn.d_tag == DT_NEEDED
+		      && dyn.d_un.d_val == strindex)
+		    {
+		      if (buf != NULL)
+			free (buf);
+		      if (extversym != NULL)
+			free (extversym);
+
+		      /* We do not want to include any of the sections in a
+			 dynamic object in the output file.  We hack by simply
+			 clobbering the list of sections in the BFD.  This could
+			 be handled more cleanly by, say, a new section flag;
+			 the existing SEC_NEVER_LOAD flag is not the one we
+			 want, because that one still implies that the section
+			 takes up space in the output file.  We do this after
+			 having extracted the section information from the
+			 symbol table.  Because we need the section information
+			 until after the symbols are examined, we do this here
+			 and after they are examined */
+		      abfd->sections = NULL;
+		      abfd->section_count = 0;
+
+		      return true;
+		    }
+		}
+	    }
+
+	  if (! coff_add_dynamic_entry (info, DT_NEEDED, strindex))
+	    goto error_return;
+	}
+
+      /* Save the SONAME, if there is one, because sometimes the
+         linker emulation code will need to know it.  */
+      if (*name == '\0')
+	name = bfd_get_filename (abfd);
+      coff_dt_name (abfd) = name;
+    }
+
+#ifdef USE_WEAK
+    weaks = NULL;
+#endif
+
+    ever = extversym;
+#endif /* ] */
+
   while (esym < esym_end)
     {
       struct internal_syment sym;
       enum coff_symbol_classification classification;
-      boolean copy;
-
+      boolean copy = false;
+#ifdef DYNAMIC_LINKING
+      boolean definition;
+      struct coff_link_hash_entry *h = NULL;
+      struct coff_link_hash_entry *h_real;
+
+      if (ever != NULL) ever++;
+#endif
+
       bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);
 
+#ifdef DYNAMIC_LINKING
+      /* A symbol coming from a .so can be one of three things:
+	 A definition (in that .so).
+	 An (as yet) unsatisfied symbol 
+	 A reference from that .so to some other .so it was linked against.
+
+	 The latter two both look like undefined symbols at this point.
+
+	 The third class is transformed into the first (or second) because the 
+	 generic linker looks thru the DT_NEEDED entries of all .so's and 
+	 calls this routine for all the libraries thus mentioned.
+       */
+#endif
       classification = bfd_coff_classify_symbol (abfd, &sym);
       if (classification != COFF_SYMBOL_LOCAL)
 	{
@@ -370,9 +1407,29 @@ coff_link_add_symbols (abfd, info)
 	  asection *section;
 	  bfd_vma value;
 	  boolean addit;
-
+	  const char *alias_target_name = NULL;
+
 	  /* This symbol is externally visible.  */
 
+#ifdef DYNAMIC_LINKING
+	  if (using_dynsymtab)
+	    {
+	      if (sym._n._n_n._n_zeroes != 0
+		  || sym._n._n_n._n_offset == 0)
+		{
+		   memcpy (buf, sym._n._n_name, SYMNMLEN);
+		   buf[SYMNMLEN] = '\0';
+		   name=buf;
+		   copy=true;
+		}
+	      else
+		{
+		   name = dynstrings + sym._n._n_n._n_offset;
+		}
+	    }
+	  else
+#endif
+            { // NOTE: more delayed indentation fix
 	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
 	  if (name == NULL)
 	    goto error_return;
@@ -383,7 +1440,8 @@ coff_link_add_symbols (abfd, info)
 	  if (sym._n._n_n._n_zeroes != 0
 	      || sym._n._n_n._n_offset == 0)
 	    copy = true;
-
+	    } // END DELAY.
+
 	  value = sym.n_value;
  
 	  /* This is horrible, but I can't think of a better way to do it.
@@ -480,30 +1538,237 @@ coff_link_add_symbols (abfd, info)
 	      break;
 	    }
 
-	  if (IS_WEAK_EXTERNAL (abfd, sym))
-	    flags = BSF_WEAK;
-
+#ifdef DYNAMIC_LINKING /* [ */
+	  definition = (classification == COFF_SYMBOL_GLOBAL);
+	  /* Common is not a definition (in this sense); if defined in a 
+	     shared lib it's become an ordinary symbol.  Defined ordinary
+	     symbol plus common has the ordinary symbol dominate anyway,
+	     which is generally what we want.
+
+	     USE_COPY_RELOC may affect this.  */
+
+#ifdef USE_SIZE
+	  size_change_ok = false;
+	  /* type_chang_ok is a kluge left over from ELF where certain
+	     machines misrecorded types; that seems more likely in COFF,
+	     so that is left as a guide. */
+	  type_change_ok = get_elf_backend_data (abfd)->type_change_ok;
+#else
+	  type_change_ok = false;
+	  size_change_ok = false;
+#endif
+#endif /* ] */
+	  if (info->hash->creator->flavour == bfd_target_coff_flavour)
+	    {
+	      boolean override;
+#ifdef DYNAMIC_LINKING /* [ */
+	      coff_internal_versym iver;
+	      unsigned int vernum = -1;
+
+	      if (ever != NULL)
+		{
+		  bfd_coff_swap_versym_in (abfd, ever, &iver);
+		  vernum = iver.vs_vers & VERSYM_VERSION;
+
+		  /* If this is a hidden symbol, or if it is not version
+		     1, we append the version name to the symbol name.
+		     However, we do not modify a non-hidden absolute
+		     symbol, because it might be the version symbol
+		     itself.  FIXME: What if it isn't?  */
+		  if ((iver.vs_vers & VERSYM_HIDDEN) != 0
+		      || (vernum > 1 && ! bfd_is_abs_section (section)))
+		    {
+		      const char *verstr;
+		      int namelen, newlen;
+		      char *newname, *p;
+
+		      if (sym.n_scnum != N_UNDEF)
+			{
+			  if (vernum > dyn_data (abfd)->dynverdef->info_r)
+			    {
+			      (*_bfd_error_handler)
+				(_("%s: %s: invalid version %d (max %d)"),
+				 abfd->filename, name, vernum,
+				 dyn_data (abfd)->dynverdef->info_r);
+			      bfd_set_error (bfd_error_bad_value);
+			      goto error_return;
+			    }
+			  else if (vernum > 1)
+			    verstr = 
+			       dyn_data (abfd)->verdef[vernum - 1].vd_nodename;
+			  else
+			    verstr = "";
+			}
+		      else
+			{
+			  /* We cannot simply test for the number of
+			     entries in the VERNEED section since the
+			     numbers for the needed versions do not start
+			     at 0.  */
+			  coff_internal_verneed *t;
+
+			  verstr = NULL;
+			  for (t = dyn_data (abfd)->verref;
+			       t != NULL;
+			       t = t->vn_nextref)
+			    {
+			      coff_internal_vernaux *a;
+
+			      for (a = t->vn_auxptr; 
+				   a != NULL; 
+				   a = a->vna_nextptr)
+				{
+				  if (a->vna_other == vernum)
+				    {
+				      verstr = a->vna_nodename;
+				      break;
+				    }
+				}
+			      if (a != NULL)
+				break;
+			    }
+			  if (verstr == NULL)
+			    {
+			      (*_bfd_error_handler)
+				(_("%s: %s: invalid needed version %d"),
+				 bfd_get_filename (abfd), name, vernum);
+			      bfd_set_error (bfd_error_bad_value);
+			      goto error_return;
+			    }
+			}
+
+		      namelen = strlen (name);
+		      newlen = namelen + strlen (verstr) + 2;
+		      if ((iver.vs_vers & VERSYM_HIDDEN) == 0)
+			++newlen;
+
+		      newname = (char *) bfd_alloc (abfd, newlen);
+		      if (newname == NULL)
+			goto error_return;
+		      strcpy (newname, name);
+		      p = newname + namelen;
+		      *p++ = COFF_VER_CHR;
+		      /* If this is a defined non-hidden version symbol,
+			 we add another @ to the name.  This indicates the
+			 default version of the symbol.  */
+		      if ((iver.vs_vers & VERSYM_HIDDEN) == 0
+                          && sym.n_scnum != N_UNDEF)
+			*p++ = COFF_VER_CHR;
+		      strcpy (p, verstr);
+
+		      name = newname;
+		    }
+		}
+
+#endif /* ] */
+	      /* PE weak symbols are aliases... we need to get the aliased
+		 real symbol. */
+	      if (obj_pe(abfd) && sym.n_sclass == C_NT_WEAK)
+		{
+		  /* It's a PE weak symbol (type IMAGE_WEAK_EXTERN_SEARCH_ALIAS)
+		     That's implemented as an indirect in our parlance. 
+		     Find the aux entry, get the referenced symbol, and insert
+		     its name.  */
+
+		  int target_idx;
+		  union internal_auxent auxent;
+
+		  BFD_ASSERT (sym.n_numaux == 1);
+
+		  /* Read in the aux information */
+
+		  bfd_coff_swap_aux_in (abfd, (PTR) (esym + symesz), sym.n_type,
+				        sym.n_sclass, 0, sym.n_numaux,
+				        (PTR) &auxent);
+		  /* From the aux information, get the backing "strong"
+		     local symbol index. */
+		  target_idx = auxent.x_sym.x_tagndx.l;
+
+		  /* Check for IMAGE_WEAK_EXTERN_SEARCH_ALIAS; it's all
+		     we currently support.  (See the 3/98 or later PE docs;
+		     there used to be only two types.) */
+		  BFD_ASSERT (auxent.x_sym.x_misc.x_fsize == 3);
+
+		  /* Now that we've caught it... 
+
+		     For the moment (unless/until proven otherwise) we'll
+		     assume the real symbol is already declared in this
+		     file (possibly as an UNDEF, but it exists). */
+
+		  BFD_ASSERT(target_idx < sym_idx);
+
+		  /* It's an alias (weak symbol).  Treat it that way. */
+		  flags = BSF_WEAK | BSF_INDIRECT;
+
+		  /* From the aux entry, get the name as a string. */
+		  alias_target_name = 
+		      (obj_coff_sym_hashes (abfd))[target_idx]->
+				    root.root.string;
+		  /* We'll add the symbol later (after symbol merge). */
+		}
+
+	      if (! coff_merge_symbol (abfd, info, name, &sym, classification,
+				       &section, &value,
+				       sym_hash, copy,
+				       &override, &type_change_ok,
+				       &size_change_ok))
+		goto error_return;
+
+	      if (override)
+		definition = false;
+
+	      h = *sym_hash;
+
+	      while ((h->root.type == bfd_link_hash_indirect
+	  	       && !h->root.u.i.info.alias)
+		     || h->root.type == bfd_link_hash_warning)
+		h = (struct coff_link_hash_entry *) h->root.u.i.link;
+
+#ifdef DYNAMIC_LINKING /* [ */
+	      if (dynamic
+		  && dyn_data (abfd)->verdef != NULL
+		  && ! override
+		  && vernum > 1
+		  && definition)
+		h->verinfo.verdef = &dyn_data (abfd)->verdef[vernum - 1];
+#endif /* ] */
+
+	      /* If it's a section definition, we now know the section;
+		 Above, we may have munged the section name in the
+		 symbol table, but it's not munged in the section entry
+		 itself.  There are two possible places to put it;
+		 the section name entry itself, or in the section symbol
+		 name.  We use the latter as less likely to cause
+		 side effects.  We wait until now so we both have the
+		 section, and so we have a permanent copy of the munged
+		 name handy (without duplication). */
+	      if (classification == COFF_SYMBOL_PE_SECTION)
+		{
+		   section->symbol->name = h->root.root.string;
+		}
+	    }
 	  addit = true;
 
+	  if (sym.n_sclass == C_WEAKEXT) /* NOT NT_WEAK! */
+	    flags = BSF_WEAK;
+
 	  /* In the PE format, section symbols actually refer to the
              start of the output section.  We handle them specially
-             here.  */
-	  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)
+             here. */
+	  if ((flags & BSF_SECTION_SYM) != 0
+	      && obj_pe (abfd) 
+	      && (*sym_hash)->root.type != bfd_link_hash_new)
 	    {
-	      *sym_hash = coff_link_hash_lookup (coff_hash_table (info),
-						 name, false, copy, false);
-	      if (*sym_hash != NULL)
-		{
-		  if (((*sym_hash)->coff_link_hash_flags
-		       & COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0
-		      && (*sym_hash)->root.type != bfd_link_hash_undefined
-		      && (*sym_hash)->root.type != bfd_link_hash_undefweak)
-		    (*_bfd_error_handler)
-		      ("Warning: symbol `%s' is both section and non-section",
-		       name);
-
-		  addit = false;
-		}
+
+	      if ((*sym_hash)->root.type != bfd_link_hash_undefined
+	      && (*sym_hash)->root.type != bfd_link_hash_undefweak
+	      && ((*sym_hash)->coff_link_hash_flags
+		   & COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0)
+		(*_bfd_error_handler)
+		  (_("Warning: symbol `%s' is both section and non-section"),
+		   name);
+
+	      addit = false;
 	    }
 
 	  /* The Microsoft Visual C compiler does string pooling by
@@ -550,7 +1815,7 @@ coff_link_add_symbols (abfd, info)
 	    {
 	      if (! (bfd_coff_link_add_one_symbol
 		     (info, abfd, name, flags, section, value,
-		      (const char *) NULL, copy, false,
+		      alias_target_name, copy, false,
 		      (struct bfd_link_hash_entry **) sym_hash)))
 		goto error_return;
 	    }
@@ -559,6 +1824,58 @@ coff_link_add_symbols (abfd, info)
 	    (*sym_hash)->coff_link_hash_flags |=
 	      COFF_LINK_HASH_PE_SECTION_SYMBOL;
 
+	  /* If this is a weak alias, propigate the REF flags into
+	     the corresponding strong symbol, so it gets properly
+	     emitted as well. */
+	  h_real = *sym_hash;
+	  while ((h_real->root.type == bfd_link_hash_indirect
+		   && h_real->root.u.i.info.alias))
+	    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+	  h_real->coff_link_hash_flags |=
+	    h->coff_link_hash_flags & 
+			      (COFF_LINK_HASH_REF_DYNAMIC |
+			      COFF_LINK_HASH_REF_REGULAR);
+         /* We're going to remember h_real for later use (way
+            down below). */
+
+          /* Now deal with real indirect symbols. */
+	  h = *sym_hash;
+	  while ((h->root.type == bfd_link_hash_indirect
+		   && !h->root.u.i.info.alias)
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct coff_link_hash_entry *) h->root.u.i.link;
+	  *sym_hash = h;
+
+#ifdef DYNAMIC_LINKING /* [ */
+
+#ifdef USE_WEAK
+	  new_weakdef = false;
+	  if (dynamic
+	      && definition
+	      && (flags & BSF_WEAK) != 0
+	      && ELF_ST_TYPE (sym.st_info) != STT_FUNC
+	      && info->hash->creator->flavour == bfd_target_elf_flavour
+	      && h->weakdef == NULL)
+	    {
+	      /* Keep a list of all weak defined non function symbols from
+		 a dynamic object, using the weakdef field.  Later in this
+		 function we will set the weakdef field to the correct
+		 value.  We only put non-function symbols from dynamic
+		 objects on this list, because that happens to be the only
+		 time we need to know the normal symbol corresponding to a
+		 weak symbol, and the information is time consuming to
+		 figure out.  If the weakdef field is not already NULL,
+		 then this symbol was already defined by some previous
+		 dynamic object, and we will be using that previous
+		 definition anyhow.  */
+
+	      h->weakdef = weaks;
+	      weaks = h;
+	      new_weakdef = true;
+	    }
+#endif
+#endif /* ] */
+
 	  /* Limit the alignment of a common symbol to the possible
              alignment of a section.  There is no point to permitting
              a higher alignment for a common symbol: we can not
@@ -573,6 +1890,11 @@ coff_link_add_symbols (abfd, info)
 
 	  if (info->hash->creator->flavour == bfd_get_flavour (abfd))
 	    {
+#ifdef DYNAMIC_LINKING
+	      int old_flags;
+	      boolean is_dynsym;
+	      int new_flag;
+#endif
 	      /* If we don't have any symbol information currently in
                  the hash table, or if we are looking at a symbol
                  definition, then update the symbol class and type in
@@ -634,9 +1956,374 @@ coff_link_add_symbols (abfd, info)
 		      (*sym_hash)->aux = alloc;
 		    }
 		}
+
+
+#ifdef DYNAMIC_LINKING /* [ */
+#ifdef USE_SIZE
+	      /* If USE_COPY_RELOC is defined, this code probably needs
+		 to be turned on as well, and if it is, the relationship
+		 between the type checking here and that already present
+		 for native coff */
+	      /* Remember the symbol size and type.  */
+	      if (sym.st_size != 0
+		  && (definition || h->size == 0))
+		{
+		  if (h->size != 0 && h->size != sym.st_size && ! size_change_ok)
+		    (*_bfd_error_handler)
+		      (_("Warning: size of symbol `%s' changed from %lu to %lu in %s"),
+		       name, (unsigned long) h->size, (unsigned long) sym.st_size,
+		       bfd_get_filename (abfd));
+
+		  h->size = sym.st_size;
+		}
+	      if (ELF_ST_TYPE (sym.st_info) != STT_NOTYPE
+		  && (definition || h->type == STT_NOTYPE))
+		{
+		  if (h->type != STT_NOTYPE
+		      && h->type != ELF_ST_TYPE (sym.st_info)
+		      && ! type_change_ok)
+		    (*_bfd_error_handler)
+		      (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
+		       name, h->type, ELF_ST_TYPE (sym.st_info),
+		       bfd_get_filename (abfd));
+
+		  h->type = ELF_ST_TYPE (sym.st_info);
+		}
+
+	      if (sym.st_other != 0
+		  && (definition || h->other == 0))
+		h->other = sym.st_other;
+#endif
+
+	      /* Set a flag in the hash table entry indicating the type of
+		 reference or definition we just found.  Keep a count of
+		 the number of dynamic symbols we find.  A dynamic symbol
+		 is one which is referenced or defined by both a regular
+		 object and a shared object.  */
+	      old_flags = (*sym_hash)->coff_link_hash_flags;
+	      is_dynsym = false;
+		  
+	      if (! dynamic)
+		{
+		  if (! definition)
+		    new_flag = COFF_LINK_HASH_REF_REGULAR;
+		  else
+		    new_flag = COFF_LINK_HASH_DEF_REGULAR;
+		  if ((info->shared && classification != COFF_SYMBOL_PE_SECTION)
+		      || (old_flags & (COFF_LINK_HASH_DEF_DYNAMIC
+				       | COFF_LINK_HASH_REF_DYNAMIC)) != 0)
+		    {
+#ifdef USE_DLLS
+			/* If we find a symbol is a DLL symbol, hide it from
+			   the shared library stuff completely */
+			if (!is_DLL_module)
+#endif
+		            is_dynsym = true;
+		    }
+		}
+	      else
+		{
+		  if (! definition)
+		    new_flag = COFF_LINK_HASH_REF_DYNAMIC;
+		  else
+		    new_flag = COFF_LINK_HASH_DEF_DYNAMIC;
+		  if ((old_flags & (COFF_LINK_HASH_DEF_REGULAR
+				    | COFF_LINK_HASH_REF_REGULAR)) != 0
+#ifdef USE_WEAK
+		      || ((*sym_hash)->weakdef != NULL
+			  && ! new_weakdef
+			  && (*sym_hash)->weakdef->dynindx != -1)
+#endif
+			  )
+		    is_dynsym = true;
+		}
+
+#ifdef USE_DLLS
+	      /* We flag symbols defined in a DLL so we know to not export
+		 them; if we find the definition first (__imp_* symbols and
+		 the various housekeeping symbols) we skip entering them as
+		 dynamic symbols.  However, for forward refs, we can't know
+		 until later, thus a flag. We'll not flag sections, because
+		 they are neither definition nor reference, really, and it
+		 doesn't work if we do.
+
+		 BUT!!!, we treat __imp_ symbols as ordinary, as
+		 they will need a dynamic reloc, at least until we
+		 generate .reloc sections. */
+
+	      if (definition 
+		  && is_DLL_module 
+		  && classification != COFF_SYMBOL_PE_SECTION
+		  && strncmp(h->root.root.string, "__imp_",6) != 0)
+		    new_flag |= COFF_LINK_HASH_DLL_DEFINED;
+#endif
+
+	      (*sym_hash)->coff_link_hash_flags |= new_flag;
+
+	      /* If this symbol has a version, and it is the default
+		 version, we create an indirect symbol from the default
+		 name to the fully decorated name.  This will cause
+		 external references which do not specify a version to be
+		 bound to this version of the symbol.  */
+	      if (definition)
+		{
+		  char *p;
+
+		  p = strchr (name, COFF_VER_CHR);
+		  /* MSVC compiler generated symbols can have @ in them,
+		     but they begin with ?, so leave them alone. */
+		  if (name[0] != '?' && p != NULL && p[1] == COFF_VER_CHR)
+		    {
+		      char *shortname;
+		      struct coff_link_hash_entry *hi;
+		      boolean override;
+
+		      shortname = bfd_hash_allocate (&info->hash->table,
+						     p - name + 1);
+		      if (shortname == NULL)
+			goto error_return;
+		      strncpy (shortname, name, p - name);
+		      shortname[p - name] = '\0';
+
+		      /* We are going to create a new symbol.  Merge it
+			 with any existing symbol with this name.  For the
+			 purposes of the merge, act as though we were
+			 defining the symbol we just defined, although we
+			 actually going to define an indirect symbol.  */
+		      type_change_ok = false;
+		      size_change_ok = false;
+		      if (! coff_merge_symbol (abfd, info, shortname, &sym, 
+					      classification,
+					      &section, &value, &hi, copy, &override,
+					      &type_change_ok, &size_change_ok))
+			goto error_return;
+
+		      if (! override)
+			{
+			  if (! (_bfd_generic_link_add_one_symbol
+				 (info, abfd, shortname, BSF_INDIRECT,
+				  bfd_ind_section_ptr, (bfd_vma) 0, name, false,
+				  false, (struct bfd_link_hash_entry **) &hi)))
+			    goto error_return;
+			}
+		      else
+			{
+			  /* In this case the symbol named SHORTNAME is
+			     overriding the indirect symbol we want to
+			     add.  We were planning on making SHORTNAME an
+			     indirect symbol referring to NAME.  SHORTNAME
+			     is the name without a version.  NAME is the
+			     fully versioned name, and it is the default
+			     version.
+
+			     Overriding means that we already saw a
+			     definition for the symbol SHORTNAME in a
+			     regular object, and it is overriding the
+			     symbol defined in the dynamic object.
+
+			     When this happens, we actually want to change
+			     NAME, the symbol we just added, to refer to
+			     SHORTNAME.  This will cause references to
+			     NAME in the shared object to become
+			     references to SHORTNAME in the regular
+			     object.  This is what we expect when we
+			     override a function in a shared object: that
+			     the references in the shared object will be
+			     mapped to the definition in the regular
+			     object.  */
+
+			  while ((hi->root.type == bfd_link_hash_indirect
+				   && !hi->root.u.i.info.alias)
+				 || hi->root.type == bfd_link_hash_warning)
+			    hi = 
+			      (struct coff_link_hash_entry *) hi->root.u.i.link;
+
+			  h->root.type = bfd_link_hash_indirect;
+			  h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
+			  h->root.u.i.info.alias = false;
+			  if (h->coff_link_hash_flags 
+			      & COFF_LINK_HASH_DEF_DYNAMIC)
+			    {
+			      h->coff_link_hash_flags 
+				  &=~ COFF_LINK_HASH_DEF_DYNAMIC;
+			      hi->coff_link_hash_flags 
+				  |= COFF_LINK_HASH_REF_DYNAMIC;
+			      if (hi->coff_link_hash_flags
+				  & (COFF_LINK_HASH_REF_REGULAR
+				     | COFF_LINK_HASH_DEF_REGULAR))
+				{
+				  if (! _bfd_coff_link_record_dynamic_symbol 
+					(info, hi))
+				    goto error_return;
+				}
+			    }
+
+			  /* Now set HI to H, so that the following code
+			     will set the other fields correctly.  */
+			  hi = h;
+			}
+
+		      /* If there is a duplicate definition somewhere,
+			 then HI may not point to an indirect symbol.  We
+			 will have reported an error to the user in that
+			 case.  */
+
+		      if (hi->root.type == bfd_link_hash_indirect
+			   && !hi->root.u.i.info.alias)
+			{
+			  struct coff_link_hash_entry *ht;
+
+			  /* If the symbol became indirect, then we assume
+			     that we have not seen a definition before.  */
+			  BFD_ASSERT ((hi->coff_link_hash_flags
+				       & (COFF_LINK_HASH_DEF_DYNAMIC
+					  | COFF_LINK_HASH_DEF_REGULAR))
+				      == 0);
+
+			  ht = 
+			      (struct coff_link_hash_entry *) hi->root.u.i.link;
+
+			  /* See if the new flags lead us to realize that
+			     the symbol must be dynamic.  */
+			  if (! is_dynsym)
+			    {
+			      if (! dynamic)
+				{
+				  if (info->shared
+				      || ((hi->coff_link_hash_flags
+					   & COFF_LINK_HASH_REF_DYNAMIC)
+					  != 0))
+				    is_dynsym = true;
+				}
+			      else
+				{
+				  if ((hi->coff_link_hash_flags
+				       & COFF_LINK_HASH_REF_REGULAR) != 0)
+				    is_dynsym = true;
+				}
+			    }
+			}
+
+		      /* We also need to define an indirection from the
+			 nondefault version of the symbol.  */
+
+		      shortname = bfd_hash_allocate (&info->hash->table,
+						     strlen (name));
+		      if (shortname == NULL)
+			goto error_return;
+		      strncpy (shortname, name, p - name);
+		      strcpy (shortname + (p - name), p + 1);
+
+		      /* Once again, merge with any existing symbol.  */
+		      type_change_ok = false;
+		      size_change_ok = false;
+		      if (! coff_merge_symbol (abfd, info, shortname, &sym,
+					      classification,
+					      &section, &value, &hi, copy, &override,
+					      &type_change_ok, &size_change_ok))
+			goto error_return;
+
+		      if (override)
+			{
+			  /* Here SHORTNAME is a versioned name, so we
+			     don't expect to see the type of override we
+			     do in the case above.  */
+			  (*_bfd_error_handler)
+			    (_("%s: warning: unexpected redefinition of `%s'"),
+			     bfd_get_filename (abfd), shortname);
+			}
+		      else
+			{
+			  if (! (bfd_coff_link_add_one_symbol
+				 (info, abfd, shortname, BSF_INDIRECT,
+				  bfd_ind_section_ptr, (bfd_vma) 0, name, 
+				  false, false,
+				  (struct bfd_link_hash_entry **) &hi)))
+			    goto error_return;
+
+			  /* If there is a duplicate definition somewhere,
+			     then HI may not point to an indirect symbol.
+			     We will have reported an error to the user in
+			     that case.  */
+
+			  if (hi->root.type == bfd_link_hash_indirect
+				&& !hi->root.u.i.info.alias)
+			    {
+			      /* If the symbol became indirect, then we
+				 assume that we have not seen a definition
+				 before.  */
+			      BFD_ASSERT ((hi->coff_link_hash_flags
+					   & (COFF_LINK_HASH_DEF_DYNAMIC
+					      | COFF_LINK_HASH_DEF_REGULAR))
+					  == 0);
+
+			      /* See if the new flags lead us to realize
+				 that the symbol must be dynamic.  */
+			      if (! is_dynsym)
+				{
+				  if (! dynamic)
+				    {
+				      if (info->shared
+					  || ((hi->coff_link_hash_flags
+					       & COFF_LINK_HASH_REF_DYNAMIC)
+					      != 0))
+					is_dynsym = true;
+				    }
+				  else
+				    {
+				      if ((hi->coff_link_hash_flags
+					   & COFF_LINK_HASH_REF_REGULAR) != 0)
+					is_dynsym = true;
+				    }
+				}
+			    }
+			}
+		    }
+		}
+
+	      if (is_dynsym)
+		{
+		  if ((*sym_hash)->dynindx == -1)
+		    {
+		      if (!_bfd_coff_link_record_dynamic_symbol (info, 
+			  (*sym_hash)))
+			goto error_return;
+#ifdef USE_WEAK
+		      if ((*sym_hash)->weakdef != NULL
+			  && ! new_weakdef
+			  && (*sym_hash)->weakdef->dynindx == -1)
+			{
+			  if (! _bfd_coff_link_record_dynamic_symbol 
+					   (info, (*sym_hash)->weakdef))
+			    goto error_return;
+			}
+#endif
+		    }
+		  /* If this is a weak/indirect symbol, we need to get
+		     the real symbol taken care of, too. (*sym_hash and
+		     h_real will be the same if this isn't weak, so
+		     don't do things twice.) */
+		  if (h_real != (*sym_hash)
+		      && h_real->dynindx == -1)
+		    {
+		      if (!_bfd_coff_link_record_dynamic_symbol (info, h_real))
+			goto error_return;
+#ifdef USE_WEAK
+		      if (h_real->weakdef != NULL
+			  && ! new_weakdef
+			  && h_real->weakdef->dynindx == -1)
+			{
+			  if (! _bfd_coff_link_record_dynamic_symbol 
+					   (info, h_real->weakdef))
+			    goto error_return;
+			}
+#endif
+		    }
+		}
 	    }
-
-	  if (classification == COFF_SYMBOL_PE_SECTION
+#endif /* ] */
+
+ 	  if (classification == COFF_SYMBOL_PE_SECTION
 	      && (*sym_hash)->numaux != 0)
 	    {
 	      /* Some PE sections (such as .bss) have a zero size in
@@ -659,8 +2346,154 @@ coff_link_add_symbols (abfd, info)
 
       esym += (sym.n_numaux + 1) * symesz;
       sym_hash += sym.n_numaux + 1;
+      sym_idx += sym.n_numaux + 1;
     }
 
+#ifdef USE_WEAK
+  /* Now set the weakdefs field correctly for all the weak defined
+     symbols we found.  The only way to do this is to search all the
+     symbols.  Since we only need the information for non functions in
+     dynamic objects, that's the only time we actually put anything on
+     the list WEAKS.  We need this information so that if a regular
+     object refers to a symbol defined weakly in a dynamic object, the
+     real symbol in the dynamic object is also put in the dynamic
+     symbols; we also must arrange for both symbols to point to the
+     same memory location.  We could handle the general case of symbol
+     aliasing, but a general symbol alias can only be generated in
+     assembler code, handling it correctly would be very time
+     consuming, and other ELF linkers don't handle general aliasing
+     either.  */
+  while (weaks != NULL)
+    {
+      struct elf_link_hash_entry *hlook;
+      asection *slook;
+      bfd_vma vlook;
+      struct elf_link_hash_entry **hpp;
+      struct elf_link_hash_entry **hppend;
+
+      hlook = weaks;
+      weaks = hlook->weakdef;
+      hlook->weakdef = NULL;
+
+      BFD_ASSERT (hlook->root.type == bfd_link_hash_defined
+		  || hlook->root.type == bfd_link_hash_defweak
+		  || hlook->root.type == bfd_link_hash_common
+		  || hlook->root.type == bfd_link_hash_indirect);
+      slook = hlook->root.u.def.section;
+      vlook = hlook->root.u.def.value;
+
+      hpp = elf_sym_hashes (abfd);
+      hppend = hpp + extsymcount;
+      for (; hpp < hppend; hpp++)
+	{
+	  struct elf_link_hash_entry *h;
+
+	  h = *hpp;
+	  if (h != NULL && h != hlook
+	      && h->root.type == bfd_link_hash_defined
+	      && h->root.u.def.section == slook
+	      && h->root.u.def.value == vlook)
+	    {
+	      hlook->weakdef = h;
+
+	      /* If the weak definition is in the list of dynamic
+		 symbols, make sure the real definition is put there
+		 as well.  */
+	      if (hlook->dynindx != -1
+		  && h->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
+		    goto error_return;
+		}
+
+	      /* If the real definition is in the list of dynamic
+                 symbols, make sure the weak definition is put there
+                 as well.  If we don't do this, then the dynamic
+                 loader might not merge the entries for the real
+                 definition and the weak definition.  */
+	      if (h->dynindx != -1
+		  && hlook->dynindx == -1)
+		{
+		  if (! _bfd_elf_link_record_dynamic_symbol (info, hlook))
+		    goto error_return;
+		}
+
+	      break;
+	    }
+	}
+    }
+#endif
+
+#ifdef DYNAMIC_LINKING /* [ */
+    if (dynamic) 
+      {
+	/* We do not want to include any of the sections in a dynamic
+	   object in the output file.  We hack by simply clobbering the
+	   list of sections in the BFD.  This could be handled more
+	   cleanly by, say, a new section flag; the existing
+	   SEC_NEVER_LOAD flag is not the one we want, because that one
+	   still implies that the section takes up space in the output
+	   file.  We do this after having extracted the section information
+	   from the symbol table. */
+
+	abfd->sections = NULL;
+	abfd->section_count = 0;
+      }
+
+    if (buf != NULL)
+      free (buf);
+
+  /* If this object is the same format as the output object, and it is
+     not a shared library, then let the backend look through the
+     relocs.
+
+     This is required to build global offset table entries and to
+     arrange for dynamic relocs.  It is not required for the
+     particular common case of linking non PIC code, even when linking
+     against shared libraries, but unfortunately there is no way of
+     knowing whether an object file has been compiled PIC or not.
+     Looking through the relocs is not particularly time consuming.
+     The problem is that we must either (1) keep the relocs in memory,
+     which causes the linker to require additional runtime memory or
+     (2) read the relocs twice from the input file, which wastes time.
+     This would be a good case for using mmap.
+
+     I have no idea how to handle linking PIC code into a file of a
+     different format.  It probably can't be done.  */
+
+  if (! dynamic
+      && (abfd->xvec == info->hash->creator
+         || abfd->xvec == info->hash->creator->input_format)
+      )
+    {
+      asection *o;
+
+      for (o = abfd->sections; o != NULL; o = o->next)
+	{
+	  struct internal_reloc *internal_relocs;
+	  boolean ok;
+
+	  if (o->reloc_count == 0)
+	     continue;
+
+	  internal_relocs = _bfd_coff_read_internal_relocs
+			     (abfd, o, info->keep_memory, NULL,
+			      false, NULL);
+
+	  if (internal_relocs == NULL)
+	    goto error_return;
+
+	  ok = bfd_coff_backend_check_relocs(abfd, info, o, internal_relocs);
+
+	  if (! info->keep_memory)
+	    free (internal_relocs);
+
+	  if (! ok)
+	    goto error_return;
+	}
+    }
+#endif /* ] */
+
   /* If this is a non-traditional, non-relocateable link, try to
      optimize the handling of any .stab/.stabstr sections.  */
   if (! info->relocateable
@@ -705,6 +2538,11 @@ coff_link_add_symbols (abfd, info)
   return true;
 
  error_return:
+#ifdef DYNAMIC_LINKING
+  if (buf != NULL)
+    free (buf);
+#endif
+
   obj_coff_keep_syms (abfd) = keep_syms;
   return false;
 }
@@ -716,6 +2554,10 @@ _bfd_coff_final_link (abfd, info)
      bfd *abfd;
      struct bfd_link_info *info;
 {
+#ifdef DYNAMIC_LINKING
+  boolean dynamic;
+  bfd *dynobj;
+#endif
   bfd_size_type symesz;
   struct coff_final_link_info finfo;
   boolean debug_merge_allocated;
@@ -736,6 +2578,14 @@ _bfd_coff_final_link (abfd, info)
   char strbuf[STRING_SIZE_SIZE];
   bfd_size_type amt;
 
+#ifdef DYNAMIC_LINKING
+  if (info->shared)
+    abfd->flags |= DYNAMIC;
+
+  dynamic = coff_hash_table (info)->dynamic_sections_created;
+  dynobj = coff_hash_table (info)->dynobj;
+#endif
+
   symesz = bfd_coff_symesz (abfd);
 
   finfo.info = info;
@@ -755,6 +2605,23 @@ _bfd_coff_final_link (abfd, info)
   finfo.global_to_static = false;
   debug_merge_allocated = false;
 
+#ifdef DYNAMIC_LINKING
+  if (! dynamic)
+    {
+      finfo.dynsym_sec = NULL;
+      finfo.hash_sec = NULL;
+      finfo.symver_sec = NULL;
+    }
+  else
+    {
+      finfo.dynsym_sec = bfd_get_section_by_name (dynobj, ".dynsym");
+      finfo.hash_sec = bfd_get_section_by_name (dynobj, ".hash");
+      BFD_ASSERT (finfo.dynsym_sec != NULL && finfo.hash_sec != NULL);
+      finfo.symver_sec = bfd_get_section_by_name (dynobj, ".gnu.version");
+      /* Note that it is OK if symver_sec is NULL.  */
+    }
+#endif
+
   coff_data (abfd)->link_info = info;
 
   finfo.strtab = _bfd_stringtab_init ();
@@ -1003,6 +2870,21 @@ _bfd_coff_final_link (abfd, info)
 	}
     }
 
+  /* Are there any input bfd's for which output_has_begun didn't
+     get set?  If so, the symbols still participate, but the 
+     sections don't.  The per-section linker_mark flag should
+     keep the individual sections from being linked.
+     This also covers the case of section-less .o files. */
+  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
+    {
+      if (! bfd_coff_link_output_has_begun (sub, & finfo))
+	{
+	  if (! _bfd_coff_link_input_bfd (&finfo, sub))
+	    goto error_return;
+	  sub->output_has_begun = true;
+	}
+    }
+
   if (! bfd_coff_final_link_postscript (abfd, & finfo))
     goto error_return;
 
@@ -1138,6 +3020,193 @@ _bfd_coff_final_link (abfd, info)
       external_relocs = NULL;
     }
 
+#ifdef DYNAMIC_LINKING /* [ */
+  /* If we are linking against a dynamic object, or generating a
+     shared library, finish up the dynamic linking information.  */
+  if (dynamic)
+    {
+      coff_external_dyn *dyncon, *dynconend;
+
+      /* Fix up .dynamic entries.  */
+      o = coff_hash_table (info)->dynamic;
+      BFD_ASSERT (o != NULL);
+
+      dyncon = (coff_external_dyn *) o->contents;
+      dynconend = (coff_external_dyn *) (o->contents + o->_raw_size);
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  coff_internal_dyn dyn;
+	  const char *name;
+
+	  bfd_coff_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  /* In the PE environment, the "addresses" here end up being
+	     RVAs (ImageBase not applied) */
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      break;
+
+	      /* SVR4 linkers seem to set DT_INIT and DT_FINI based on
+                 magic _init and _fini symbols.  This is pretty ugly,
+                 but we are compatible.  */
+	    case DT_INIT:
+	      name = &"__init"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1];
+	      goto get_sym;
+	    case DT_FINI:
+	      name = &"__fini"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1];
+	    get_sym:
+	      {
+		struct coff_link_hash_entry *h;
+
+		h = coff_link_hash_lookup (coff_hash_table (info), name,
+					  false, false, true);
+		if (h != NULL
+		    && (h->root.type == bfd_link_hash_defined
+			|| h->root.type == bfd_link_hash_defweak))
+		  {
+		    dyn.d_un.d_val = h->root.u.def.value;
+		    o = h->root.u.def.section;
+		    if (o->output_section != NULL
+      			&& (h->coff_link_hash_flags 
+			    & COFF_LINK_HASH_DEF_REGULAR) != 0)
+		      dyn.d_un.d_val += (o->output_section->vma
+					 + o->output_offset);
+		    else
+		      {
+			/* The symbol is imported from another shared
+			   library and does not apply to this one.  */
+			dyn.d_un.d_val = 0;
+		      }
+
+		    bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+		  }
+	      }
+	      break;
+
+	    case DT_HASH:
+	      name = ".hash";
+	      goto get_vma;
+	    case DT_STRTAB:
+	      name = ".dynstr";
+	      goto get_vma;
+	    case DT_SYMTAB:
+	      name = ".dynsym";
+	      goto get_vma;
+	    case DT_VERDEF:
+	      name = ".gnu.version_d";
+	      goto get_vma;
+	    case DT_VERNEED:
+	      name = ".gnu.version_r";
+	      goto get_vma;
+	    case DT_VERSYM:
+	      name = ".gnu.version";
+	    get_vma:
+	      o = bfd_get_section_by_name (dynobj, name);
+	      BFD_ASSERT (o != NULL);
+	      dyn.d_un.d_ptr = o->output_section->vma 
+			       + o->vma + o->output_offset;
+	      bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+	      break;
+
+	    case DT_RELSZ:
+	      {
+		 asection *sec;
+		/* Get the number of relocations */
+		sec = bfd_get_section_by_name(abfd, ".rel.dyn");
+		dyn.d_un.d_val = sec->_raw_size;
+		bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+		break;
+	      }
+
+	    case DT_REL:
+	      {
+		asection *sec;
+		/* Get the location of the dynamic relocation section */
+		sec = bfd_get_section_by_name(abfd, ".rel.dyn");
+		dyn.d_un.d_val = sec->vma + sec->output_offset;
+		bfd_coff_swap_dyn_out (dynobj, &dyn, dyncon);
+		break;
+		}
+	    }
+	}
+
+      if (! bfd_coff_backend_finish_dynamic_sections (abfd, info))
+	goto error_return;
+    }
+
+  /* This needs to be done even for simple static loads in case some
+     PIC code slipped into our world, but only if they actually did. */
+  if (dynobj != NULL)
+    {
+      for (o = dynobj->sections; o != NULL; o = o->next)
+	{
+	  if ((o->flags & SEC_HAS_CONTENTS) == 0
+	      || o->_raw_size == 0)
+	    continue;
+
+	  if ((o->flags & SEC_LINKER_CREATED) == 0)
+	    {
+	      /* At this point, we are only interested in sections
+		 created by coff_link_create_dynamic_sections.  */
+	      continue;
+	    }
+
+	  if (strcmp (bfd_get_section_name (abfd, o), ".rel.internal") == 0
+	      || strcmp (bfd_get_section_name (abfd, o), ".rel.got") == 0
+	      || strcmp (bfd_get_section_name (abfd, o), ".rel.plt") == 0)
+	    {
+    if(o->_raw_size != o->reloc_count*bfd_coff_relsz(abfd)) fprintf(stderr, "%s %ld %d:\n",bfd_get_section_name(abfd,o), o->_raw_size, o->reloc_count * bfd_coff_relsz(abfd)); //
+	       /* Dynamic reloc section */
+	       BFD_ASSERT(o->_raw_size == o->reloc_count*bfd_coff_relsz(abfd));
+
+	       /* even tho the assert fails, it returns, and not zeroing it
+		  out creates havoc later.  If the section was too short,
+		  the havoc has already happened. */
+	       if (o->_raw_size > o->reloc_count*bfd_coff_relsz(abfd))
+		   memset (o->contents+o->reloc_count*bfd_coff_relsz(abfd), 0, 
+		     o->_raw_size - o->reloc_count*bfd_coff_relsz(abfd));
+	       if (strcmp (bfd_get_section_name(abfd, o), ".rel.internal") == 0)
+		 {
+		   extern int reloc_compar(const void *, const void *);
+
+		   /* sort the relocations.  It only really works to sort
+		      rel.internal: GOT is in a separate section, and 
+		      merging them together is a pain.  PLT must be a separate
+		      chunk at runtime.  Both PLT and GOT should have only
+		      one entry per symbol.  Thus, we just sort .rel.internal.
+		      We sort it so that at runtime, the runtime linker
+		      can cluster symbol lookups to the same symbol. */
+
+		   qsort(o->contents, o->reloc_count, bfd_coff_relsz(abfd),
+		      reloc_compar);
+		 }
+	    }
+
+	  if (strcmp (bfd_get_section_name (abfd, o), ".dynstr") == 0)
+	    {
+	      file_ptr off;
+
+	      /* The contents of the .dynstr section are actually in a
+		 stringtab.  */
+	      off = o->output_section->filepos;
+	      if (bfd_seek (abfd, off, SEEK_SET) != 0
+		  || ! _bfd_stringtab_emit (abfd,
+					    coff_hash_table (info)->dynstr))
+		goto error_return;
+	    }
+	  else
+	    {
+	      /* all other sections are not string sections */
+	      if (! bfd_set_section_contents (abfd, o->output_section,
+					      o->contents, o->output_offset,
+					      o->_raw_size))
+		goto error_return;
+	    }
+	}
+    }
+#endif /* ] */
+
   /* Free up the section information.  */
   if (finfo.section_info != NULL)
     {
@@ -1415,6 +3484,151 @@ mark_relocs (finfo, input_bfd)
     }
 }
 
+#ifdef DYNAMIC_LINKING /* [ */
+/* Standard ELF hash function.  Could be changed for COFF, but why bother */
+static unsigned long bfd_coff_hash PARAMS((CONST unsigned char *name));
+static unsigned long
+bfd_coff_hash (name)
+     CONST unsigned char *name;
+{
+  unsigned long h = 0;
+  unsigned long g;
+  int ch;
+
+  while ((ch = *name++) != '\0')
+    {
+      h = (h << 4) + ch;
+      if ((g = (h & 0xf0000000)) != 0)
+        {
+          h ^= g >> 24;
+          h &= ~g;
+        }
+    }
+  return h;
+}
+
+static void _bfd_coff_output_dynamic_symbol PARAMS((struct internal_syment *, 
+    struct coff_link_hash_entry *, struct coff_final_link_info *finfo));
+
+/* Actually output the dynamic symbol (and it's hash and stringtable
+   supporting information) as needed */
+static void 
+_bfd_coff_output_dynamic_symbol(isym, h, finfo)
+    struct internal_syment *isym;
+    struct coff_link_hash_entry *h;
+    struct coff_final_link_info *finfo;
+{
+  char *p, *copy;
+  const char *name;
+  size_t bucketcount;
+  size_t bucket;
+  bfd_byte *bucketpos;
+  bfd_vma chain;
+  bfd_size_type symesz;
+
+  symesz = bfd_coff_symesz (finfo->output_bfd);
+
+  /* If this goes into a string table entry, we need to change the
+     index; if not, the inline symbol is just fine */
+  if (strlen (h->root.root.string) > SYMNMLEN)
+      isym->_n._n_n._n_offset = h->dynstr_index;
+
+  /* In general, we aren't interested in AUX entries.  However, for 
+     C_NT_WEAK we need the indirect symbol, which is in the AUX entry,
+     which needs to be updated for the dynindx.
+     Oh well...  */
+  if (h->root.type == bfd_link_hash_indirect
+	  && h->root.u.i.info.alias)
+    {
+      union internal_auxent aux;
+      struct coff_link_hash_entry *h_real = h;
+
+      /* Usually, an aux entry is present, but if the stars align just wrong,
+	 there isn't one.  Thus, just create one. */
+      while (h_real->root.type == bfd_link_hash_indirect
+	      && h_real->root.u.i.info.alias)
+	h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+      memset((PTR)&aux, 0, sizeof(aux));
+      aux.x_sym.x_tagndx.l = h_real->dynindx;
+      aux.x_sym.x_misc.x_fsize = 3;
+      isym->n_numaux = 1;
+
+      bfd_coff_swap_aux_out (finfo->output_bfd, (PTR)&aux, isym->n_type,
+			     isym->n_sclass, 0, 1,
+			     (PTR) (finfo->dynsym_sec->contents
+				  + (h->dynindx+1) * symesz));
+    }
+  else
+    {
+      isym->n_numaux = 0;
+    }
+
+  /* We're writing into an array here, so it's a bit more convenient
+     to write the real symbol after the AUX.  */
+
+  bfd_coff_swap_sym_out (finfo->output_bfd, isym,
+		       (PTR) (finfo->dynsym_sec->contents
+			      + h->dynindx * symesz));
+
+  /* We didn't include the version string in the dynamic string
+     table, so we must not consider it in the hash table.  */
+  name = h->root.root.string;
+  if (name[0] == '?' || (p = strchr (name, COFF_VER_CHR)) == NULL)
+    copy = NULL;
+  else
+    {
+      copy = bfd_alloc (finfo->output_bfd, p - name + 1);
+      strncpy (copy, name, p - name);
+      copy[p - name] = '\0';
+      name = copy;
+    }
+
+  bucketcount = coff_hash_table (finfo->info)->bucketcount;
+  bucket = bfd_coff_hash ((const unsigned char *) name) % bucketcount;
+  bucketpos = ((bfd_byte *) finfo->hash_sec->contents
+	       + (bucket + 2) * (ARCH_SIZE / 8));
+  chain = bfd_h_get_32 (finfo->output_bfd, bucketpos);
+  bfd_h_put_32 (finfo->output_bfd, h->dynindx, bucketpos);
+  bfd_h_put_32 (finfo->output_bfd, chain,
+	    ((bfd_byte *) finfo->hash_sec->contents
+	     + (bucketcount + 2 + h->dynindx) * (ARCH_SIZE / 8)));
+
+  if (copy != NULL)
+    bfd_release (finfo->output_bfd, copy);
+
+  if (finfo->symver_sec != NULL && finfo->symver_sec->contents != NULL)
+    {
+      coff_internal_versym iversym;
+
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+	{
+	  if (h->verinfo.verdef == NULL)
+	    iversym.vs_vers = 0;
+	  else
+	    iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
+	}
+      else
+	{
+	  if (h->verinfo.vertree == NULL)
+	    iversym.vs_vers = 1;
+	  else
+	    iversym.vs_vers = h->verinfo.vertree->vernum + 1;
+	}
+
+      if ((h->coff_link_hash_flags & COFF_LINK_HIDDEN) != 0)
+	iversym.vs_vers |= VERSYM_HIDDEN;
+
+      bfd_coff_swap_versym_out (finfo->output_bfd, &iversym,
+				(((coff_external_versym *)
+				  finfo->symver_sec->contents)
+				 + h->dynindx));
+    }
+    return;
+}
+#endif /* ] */
+
+
 /* Link an input file into the linker output file.  This function
    handles all the sections and relocations of the input file at once.  */
 
@@ -1447,7 +3661,18 @@ _bfd_coff_link_input_bfd (finfo, input_b
   bfd_byte *outsym;
   struct coff_link_hash_entry **sym_hash;
   asection *o;
-
+  struct coff_link_hash_entry *h;
+  long indx;
+
+
+#ifdef DYNAMIC_LINKING
+  /* If this is a dynamic object, we don't want to do anything here:
+     we don't want the local symbols, and we don't want the section
+     contents.  */
+  if ((input_bfd->flags & DYNAMIC) != 0)
+     return true;
+#endif
+
   /* Move all the symbols to the output file.  */
 
   output_bfd = finfo->output_bfd;
@@ -1549,6 +3774,16 @@ _bfd_coff_link_input_bfd (finfo, input_b
       if (finfo->info->strip == strip_all && ! dont_skip_symbol)
 	skip = true;
 
+      /* NT_WEAKs need to come out after the real symbol, so we skip
+	 them here; when we write globals we'll discover they're leftovers
+	 and write them then. */
+      if (obj_pe(input_bfd) && isym.n_sclass == C_NT_WEAK)
+	skip = true;
+
+      indx = (esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
+	   / isymesz;
+      h = obj_coff_sym_hashes (input_bfd)[indx];
+
       if (! skip)
 	{
 	  switch (classification)
@@ -1616,8 +3851,9 @@ _bfd_coff_link_input_bfd (finfo, input_b
 	skip = true;
 
       /* If some symbols are stripped based on the name, work out the
-	 name and decide whether to skip this symbol.  */
-      if (! skip
+	 name and decide whether to skip this symbol.  Symbol table
+	 symbols with an index of -2 are "must keep", so don't strip them. */
+      if (! skip && (h == NULL  || h->indx != -2)
 	  && (finfo->info->strip == strip_some
 	      || finfo->info->discard == discard_l))
 	{
@@ -1873,7 +4109,6 @@ _bfd_coff_link_input_bfd (finfo, input_b
 	    case C_EXT:
 	    case C_STAT:
 	    case C_SECTION:
-	    case C_NT_WEAK:
 	      /* Compute new symbol location.  */
 	    if (isym.n_scnum > 0)
 	      {
@@ -1932,6 +4167,10 @@ _bfd_coff_link_input_bfd (finfo, input_b
 	      finfo->last_file_index = output_index;
 	      finfo->last_file = isym;
 	      break;
+
+	    case C_NT_WEAK:
+	      BFD_ASSERT(false);
+
 	    }
 
 	  /* If doing task linking, convert normal global function symbols to
@@ -1947,12 +4186,6 @@ _bfd_coff_link_input_bfd (finfo, input_b
 
 	  if (global)
 	    {
-	      long indx;
-	      struct coff_link_hash_entry *h;
-
-	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
-		      / isymesz);
-	      h = obj_coff_sym_hashes (input_bfd)[indx];
 	      if (h == NULL)
 		{
 		  /* This can happen if there were errors earlier in
@@ -2064,6 +4297,18 @@ _bfd_coff_link_input_bfd (finfo, input_b
 		      auxp->x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;
 		    }
 		}
+	      else if (isymp->n_sclass == C_NT_WEAK)
+		{
+		  struct coff_link_hash_entry *h1 = *sym_hash;
+		  BFD_ASSERT(h1->root.type == bfd_link_hash_indirect
+	      		 && h1->root.u.i.info.alias)
+		  /* C_NT_WEAK needs to propigate the change in the AUX
+		     entry.  (Path used in .so case, only.) */
+		  while (h1->root.type == bfd_link_hash_indirect
+	      		 && h1->root.u.i.info.alias)
+		    h1 = (struct coff_link_hash_entry *) h1->root.u.i.link;
+		  auxp->x_sym.x_tagndx.l = h1->indx;
+		}
 	      else if (isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
 		{
 		  unsigned long indx;
@@ -2373,6 +4618,15 @@ _bfd_coff_link_input_bfd (finfo, input_b
 	  continue;
 	}
 
+#ifdef DYNAMIC_LINKING
+      if ((o->flags & SEC_LINKER_CREATED) != 0)
+        {
+          /* Section was created by coff_link_create_dynamic_sections
+             or somesuch.  */
+          continue;
+        }
+#endif
+
       if ((o->flags & SEC_HAS_CONTENTS) == 0
 	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
 	{
@@ -2561,6 +4815,21 @@ _bfd_coff_write_global_sym (h, data)
   unsigned int i;
   file_ptr pos;
 
+  boolean emit_classical = true;
+  boolean emit_dynamic = true;
+  struct coff_link_hash_entry *h_real = NULL;
+
+  /* This function performs two apparently related, but distinct, functions:
+     it outputs the global symbols for the conventional symbol table
+     (function local symbols and function symbols were handled above).
+
+     It also outputs the dynamic symbols needed for dynamic linking.
+
+     The criteria for determining when a symbol is actually output to each of 
+     the two symbol tables are somewhat different, but much of the preparation
+     is shared.  Note that this code will output symbols for functions in
+     the dynmaic symbol table, but never for the conventional one */
+
   output_bfd = finfo->output_bfd;
 
   if (h->root.type == bfd_link_hash_warning)
@@ -2570,17 +4839,90 @@ _bfd_coff_write_global_sym (h, data)
 	return true;
     }
 
+  /* There are situations where we might get called more than once, and
+     if that happens, the hash table (and plt) is, well..., hash. */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_EMITTED) != 0)
+      return true;
+  h->coff_link_hash_flags |= COFF_LINK_HASH_EMITTED;
+
+  if (h->root.type == bfd_link_hash_indirect
+	&& h->root.u.i.info.alias)
+    {
+      /* C_NT_WEAK needs to propigate the change in the AUX
+	 entry.  To do that, the indx value must already be set.
+	 If necessary, recursively call ourself to achieve that.
+	 (That is, be sure the strong symbol is emitted before the
+	 weak one, so we know its index.) */
+      h_real = h;
+      while (h_real->root.type == bfd_link_hash_indirect
+	     && h_real->root.u.i.info.alias)
+	h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+      if (h_real->indx < 0)
+	_bfd_coff_write_global_sym (h_real, data);
+    }
+
+#ifdef DYNAMIC_LINKING
+  /* If we are not creating a shared library, and this symbol is
+     referenced by a shared library but is not defined anywhere, then
+     warn that it is undefined.  If we do not do this, the runtime
+     linker will complain that the symbol is undefined when the
+     program is run.  We don't have to worry about symbols that are
+     referenced by regular files, because we will already have issued
+     warnings for them.  
+
+     Because of COFF order requirements, symbols are output in 2 places
+     (here and in ...link_input_bfd).  However, we didn't output any
+     undefined symbols there, so this is the only place we need the
+     check for undefined.  */
+  if (! finfo->info->relocateable
+      && ! finfo->info->shared
+      && h->root.type == bfd_link_hash_undefined
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) != 0
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) == 0)
+    {
+      if (! ((*finfo->info->callbacks->undefined_symbol)
+	     (finfo->info, h->root.root.string, h->root.u.undef.abfd,
+	      (asection *) NULL, 0, true)))
+	{
+	  return false;
+	}
+    }
+#endif
+
+  /* If it doesn't have a dynindx, we're surely not going to emit it */
+  emit_dynamic = h->dynindx != -1;
+
   if (h->indx >= 0)
-    return true;
-
-  if (h->indx != -2
-      && (finfo->info->strip == strip_all
-	  || (finfo->info->strip == strip_some
-	      && (bfd_hash_lookup (finfo->info->keep_hash,
-				   h->root.root.string, false, false)
-		  == NULL))))
-    return true;
-
+     /* If it was emitted previously..., skip it. */
+     emit_classical = false;
+  else if (h->indx == -2)
+    /* used by a reloc... must keep */
+    emit_classical = true;
+#ifdef DYNAMIC_LINKING
+  else if (((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+	    || (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) != 0)
+	   && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0
+	   && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) == 0)
+    {
+       /* Never mentioned by a regular file */
+       /* there's still work to do, so we can't return */
+       emit_classical = false;
+       emit_dynamic = false;
+    }
+#endif
+  else if (finfo->info->strip == strip_some
+	   && bfd_hash_lookup (finfo->info->keep_hash,
+				   h->root.root.string,
+				   false, false) == NULL)
+    /* it's a symbol we don't retain when selectively stripping */
+    emit_classical = false;
+  else if (finfo->info->strip == strip_all)
+    /* or if we just strip everything */
+    emit_classical = false;
+  else
+    /* otherwise, we'll keep it */
+    emit_classical = true;
+
   switch (h->root.type)
     {
     default:
@@ -2613,6 +4955,24 @@ _bfd_coff_write_global_sym (h, data)
 	asection *sec;
 
 	sec = h->root.u.def.section->output_section;
+#ifdef DYNAMIC_LINKING
+#ifndef USE_COPY_RELOC
+	/* When a symbol has no output section, it means that the symbol
+	   came in from a prior .so, and is completely defined there.  
+	   (That is, it's a data symbol, usually.  Code symbols get an
+	   output section, that of the thunk.) (Shouldn't ever happen 
+	   if COPY relocations are in use.)
+	   We want to output the symbol (so our relocations can see it) 
+	   but as an undefined symbol. */
+	if (sec == NULL)
+	  {
+	     isym.n_scnum = N_UNDEF;
+	     isym.n_value = 0;
+	  }
+        else
+#endif
+#endif
+	  { // NOTE: deferred indentation fix
 	if (bfd_is_abs_section (sec))
 	  isym.n_scnum = N_ABS;
 	else
@@ -2622,6 +4982,7 @@ _bfd_coff_write_global_sym (h, data)
 	isym.n_value = (h->root.u.def.value
 			+ sec->vma
 			+ h->root.u.def.section->output_offset);
+	  } // END
       }
       break;
 
@@ -2630,11 +4991,57 @@ _bfd_coff_write_global_sym (h, data)
       isym.n_value = h->root.u.c.size;
       break;
 
+#ifdef DYNAMIC_LINKING
     case bfd_link_hash_indirect:
-      /* Just ignore these.  They can't be handled anyhow.  */
-      return true;
+      /* These symbols are created in two ways... by symbol versioning
+	 and by C_NT_WEAK symbols.
+
+	 For symbol versioning, they point
+         to the decorated version of the name.  For example, if the
+         symbol foo@@GNU_1.2 is the default, which should be used when
+         foo is used with no version, then we add an indirect symbol
+         foo which points to foo@@GNU_1.2.  We ignore these symbols,
+         since the indirected symbol is already in the hash table.  If
+         the indirect symbol is non-COFF, fall through and output it.
+
+	 If it's a weak symbol, it need to be treated more-or-less
+	 normally.
+
+	 */
+      if (h->root.u.i.info.alias)
+	{
+	  isym.n_scnum = N_UNDEF;
+	  isym.n_value = 0;
+	  break;
+	}
+      if ((h->coff_link_hash_flags & COFF_LINK_NON_COFF) == 0)
+        return true;
+
+      if (h->root.u.i.link->type == bfd_link_hash_new)
+        return true;
+
+      return (_bfd_coff_write_global_sym
+              ((struct coff_link_hash_entry *) h->root.u.i.link, data));
+#else
+    case bfd_link_hash_indirect:
+        /* Just ignore these.  They can't be handled anyhow.  */
+        return true;
+#endif
     }
 
+#ifdef DYNAMIC_LINKING /* [ */
+  /* Give the processor backend a chance to tweak the symbol
+     value, and also to finish up anything that needs to be done
+     for this symbol.  All symbols require a peek, because some
+     symbols are forced local, but need work here anyway. */
+  if (coff_hash_table (finfo->info)->dynamic_sections_created
+      && !bfd_coff_backend_finish_dynamic_symbol
+	 (finfo->output_bfd, finfo->info, h, &isym))
+    {
+	emit_dynamic = false;
+    }
+#endif /* ] */
+
   if (strlen (h->root.root.string) <= SYMNMLEN)
     strncpy (isym._n._n_name, h->root.root.string, SYMNMLEN);
   else
@@ -2659,6 +5066,11 @@ _bfd_coff_write_global_sym (h, data)
   isym.n_sclass = h->class;
   isym.n_type = h->type;
 
+#ifdef COFF_WITH_PE  /// This is NOT DL; move elsewhere soon.  Yeah!
+  if (h->root.type == bfd_link_hash_undefweak)
+    isym.n_sclass = C_NT_WEAK;
+#endif
+
   if (isym.n_sclass == C_NULL)
     isym.n_sclass = C_EXT;
 
@@ -2682,6 +5094,8 @@ _bfd_coff_write_global_sym (h, data)
       && IS_WEAK_EXTERNAL (finfo->output_bfd, isym))
     isym.n_sclass = C_EXT;
 
+  if (emit_classical)
+    { // NOTE: Another deferred indentation.
   isym.n_numaux = h->numaux;
 
   bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) finfo->outsyms);
@@ -2758,6 +5172,15 @@ _bfd_coff_write_global_sym (h, data)
 	    }
 	}
 
+      if (h->root.type == bfd_link_hash_indirect
+	  && h->root.u.i.info.alias)
+	{
+          BFD_ASSERT(isym.n_sclass == C_NT_WEAK)
+	  /* C_NT_WEAK needs to propigate the change in the AUX
+	     entry.   We already have h_real from above. */
+	  auxp->x_sym.x_tagndx.l = h_real->indx;
+	}
+
       bfd_coff_swap_aux_out (output_bfd, (PTR) auxp, isym.n_type,
 			     isym.n_sclass, (int) i, isym.n_numaux,
 			     (PTR) finfo->outsyms);
@@ -2768,7 +5191,22 @@ _bfd_coff_write_global_sym (h, data)
 	}
       ++obj_raw_syment_count (output_bfd);
     }
-
+  }  // END DEFERRED INDENT
+
+#ifdef DYNAMIC_LINKING /* [ */
+  /* If this symbol should also be put in the .dynsym section, then put it
+     there now.  We have already know the symbol index.  We also fill
+     in the entry in the .hash section.  */
+  if (emit_dynamic)  
+    {
+      if (h->dynindx != -1
+	  && coff_hash_table (finfo->info)->dynamic_sections_created)
+	{
+	   _bfd_coff_output_dynamic_symbol(&isym, h, finfo);
+	}
+    }
+#endif /* ] */
+
   return true;
 }
 
@@ -2958,7 +5396,37 @@ _bfd_coff_generic_relocate_section (outp
   struct internal_reloc *rel;
   struct internal_reloc *relend;
   bfd_vma imagebase = 0;
-
+#ifdef DYNAMIC_LINKING
+  asection *sgot;
+  asection *splt = NULL;
+  asection *sreloc = NULL;
+  asection *srelgot = NULL;
+  boolean dynamic;
+  bfd *dynobj;
+  bfd_vma *local_got_offsets = NULL;
+  bfd_size_type symrsz = bfd_coff_relsz(output_bfd);
+  boolean is_stab_section = false;
+
+  dynamic = coff_hash_table (info)->dynamic_sections_created;
+  if (dynamic)
+    {
+      dynobj = coff_hash_table (info)->dynobj;
+      local_got_offsets = coff_local_got_offsets (input_bfd);
+      is_stab_section = 
+	  strncmp(bfd_get_section_name(input_bfd,input_section),".stab",5) == 0;
+
+      sreloc = coff_hash_table (info)->sreloc;
+      splt = coff_hash_table(info)->splt;
+      srelgot = coff_hash_table(info)->srelgot;
+      /* BFD_ASSERT (sreloc != NULL); -- it gets made on demand */
+      BFD_ASSERT (splt != NULL);
+      /* BFD_ASSERT (srelgot != NULL); -- it gets made on demand */
+    }
+    /* In case some PIC code slipped into our world when linking 
+       statically.  */
+    sgot = coff_hash_table(info)->sgot;
+#endif
+
   if (pe_data(output_bfd) != NULL)
       imagebase = pe_data(output_bfd)->pe_opthdr.ImageBase;
 
@@ -2968,6 +5436,7 @@ _bfd_coff_generic_relocate_section (outp
     {
       long symndx;
       struct coff_link_hash_entry *h;
+      struct coff_link_hash_entry *h_real;
       struct internal_syment *sym;
       bfd_vma addend;
       bfd_vma val;
@@ -2976,6 +5445,7 @@ _bfd_coff_generic_relocate_section (outp
       enum coff_symbol_classification classification;
       asection *sec;
       boolean need_imagebase;  /* Not all relocs get ImageBase */
+      boolean need_static_reloc, need_dynamic_reloc;  /* whether to omit them */
       boolean valIsValid;  /* whether the computed val is to be trusted */
       struct internal_reloc outrel;
 
@@ -3049,7 +5519,11 @@ _bfd_coff_generic_relocate_section (outp
       val = 0;
 
       valIsValid = true;
-
+      need_static_reloc = true;
+      need_dynamic_reloc = false;
+
+      h_real = h;
+
       if (h == NULL)
 	{
 	  if (symndx == -1)
@@ -3068,12 +5542,35 @@ _bfd_coff_generic_relocate_section (outp
 	}
       else
 	{
-	  switch (h->root.type)
+
+	  /* Here we chase down both indirects and aliases if we 
+	     find them; in the code below, we may want both
+	     h and h_real (h for names, h_real for values). */
+	  while (h_real->root.type == bfd_link_hash_indirect
+	     || h_real->root.type == bfd_link_hash_warning)
+	    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+  
+	  switch (h_real->root.type)
 	    {
 	    case bfd_link_hash_defined:
 	    case bfd_link_hash_defweak:
-	      sec = h->root.u.def.section;
-	      val = (h->root.u.def.value
+	      sec = h_real->root.u.def.section;
+#ifdef DYNAMIC_LINKING
+	      /* In some cases, we don't need the relocation
+		 value.  We check specially because in some
+		 obscure cases sec->output_section will be NULL.
+		 We'll sort that out in the switch on relocation type
+		 below, and then complain as needed.  */
+	      if (sec == NULL)
+		  valIsValid = false;
+	      else if (sec->output_section == NULL) 
+		{
+	          if ((h_real->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC)==0)
+		      valIsValid = false;
+	        }
+	      else
+#endif
+		  val = (h_real->root.u.def.value
 		     + sec->output_section->vma
 		     + sec->output_offset);
 	      break;
@@ -3086,16 +5583,30 @@ _bfd_coff_generic_relocate_section (outp
 	    case bfd_link_hash_undefined:
 	    case bfd_link_hash_new:
 	    case bfd_link_hash_common:
-	    case bfd_link_hash_indirect:
-	    case bfd_link_hash_warning:
-
+
 	      /* The symbol is undefined (in some way)... some of the above
 		 probably should never be able to happen. */
 
-	      valIsValid = false;
+#ifdef DYNAMIC_LINKING /* [ */
+	    /* If it has a dynamic index, let it thru (because presumably
+	       it'll get fixed at runtime), except in the special
+	       case of a -Bsymbolic shared lib link. */
+	      if (h->dynindx != -1 && (info->shared? !info->symbolic : true))
+		{
+	          val = 0;
+		  valIsValid = true;
+		}
+	      else
+#endif /* ] */
+                {
+  	          valIsValid = false;
+		}
 	      sec = NULL;
 	      break;
 
+	    /* Should be impossible. */
+  	    case bfd_link_hash_warning:
+  	    case bfd_link_hash_indirect:
 	    default:
 	      abort ();
 	    }
@@ -3107,9 +5618,322 @@ _bfd_coff_generic_relocate_section (outp
 	&& sec != NULL
 	&& !bfd_is_abs_section(sec->output_section);
   
+#ifdef DYNAMIC_LINKING /* [ */
+      /* In case some PIC code slipped in here, we have to do this */
+      switch (rel->r_type)
+	{
+	case R_GNU_GOT32:
+	  /* Relocation is to the entry for the original (not the resolved
+	     strong one) symbol in the global offset table.  */
+
+	  if (h != NULL)
+	    {
+	      bfd_vma off;
+
+	      off = h->got_offset;
+	      BFD_ASSERT (off != (bfd_vma) -1);
+
+	      if ( ! dynamic 
+		  || (info->shared
+		      && info->symbolic
+		      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR))
+	          || (h->coff_link_hash_flags & COFF_LINK_FORCED_LOCAL) != 0)
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally.  We must initialize this entry in the
+		     global offset table.  Since the offset must
+		     always be a multiple of 4, we use the least
+		     significant bit to record whether we have
+		     initialized it already.
+
+		     When doing a dynamic link, we create a .rel.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+
+      	          BFD_ASSERT (sgot != NULL);
+
+		  if ((off & 1) == 0)
+		    {
+		      /* All "relative" relocs are w.r.t. ImageBase,
+			 for consistency. */
+//fprintf(stderr, "got slot %d initialized for %s\n", off/4, h->root.root.string); //
+		      bfd_put_32 (output_bfd, val + imagebase,
+				  sgot->contents + off);
+		      h->got_offset |= 1;
+		    }
+		  off &= ~1;
+		  /* if !valIsValid, we'll compute trash above, and gripe
+		     later */
+		}
+	      else
+		{
+		  /* If we got into the true branch above, val is
+		     required to be valid.  This (false) case is
+		     that for a true dynamic link, but it's possible
+		     that the symbol doesn't have an output section,
+		     and we don't want to report an error. */
+		  valIsValid = true;
+		}
+
+	      val = sgot->output_offset + off;
+	    }
+	  else
+	    {
+	      /* h == NULL case */
+	      bfd_vma off;
+
+	      BFD_ASSERT (local_got_offsets != NULL
+			  && local_got_offsets[symndx] != (bfd_vma) -1);
+
+	      off = local_got_offsets[symndx];
+
+	      /* The offset must always be a multiple of 4.  We use
+                 the least significant bit to record whether we have
+                 already generated the necessary reloc.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  /* All "relative" relocs are w.r.t. ImageBase,
+		     for consistency. */
+		  bfd_put_32 (output_bfd, val+imagebase, sgot->contents + off);
+
+		  if (info->shared)
+		    {
+		      outrel.r_vaddr = (sgot->output_section->vma
+					 + sgot->output_offset
+					 + off);
+
+		      /* Note... writing to the GOT relocs, not the rest of the
+			 dynamic relocations */
+		      outrel.r_type = R_GNU_RELATIVE;
+		      outrel.r_symndx = 0;
+		      bfd_coff_swap_reloc_out (output_bfd, &outrel,
+			    (srelgot->contents + srelgot->reloc_count*symrsz));
+#undef DEBUG_COUNTING
+#ifdef DEBUG_COUNTING
+fprintf(stderr, "relgot emits reloc #%d slot %d, anonymous\n", srelgot->reloc_count, off/4); //
+#endif
+		      ++srelgot->reloc_count;
+		    }
+
+		  local_got_offsets[symndx] |= 1;
+		}
+
+	      /* Since h==NULL, valIsValid is already true */
+	      /* Gas puts the symbol's value in the instruction in this
+		 case, so back it out. */
+	      val = sgot->output_offset + off - sym->n_value;
+	    }
+
+	    need_imagebase = false;
+
+	  break;
+
+	case R_GNU_GOTOFF:
+	  /* Relocation is relative to the start of the global offset
+	     table.  */
+
+	  /* Note that sgot->output_offset is not involved in this
+	     calculation.  We always want the start of .got.  If we
+	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
+	     permitted by the ABI, we might have to change this
+	     calculation.  */
+
+	  /* If !valIsValid, the expression below will still operate, but
+	     the error will be detected below. */
+	  val -= sgot->output_section->vma;
+	  need_imagebase = false;
+
+	  break;
+
+	case R_GNU_GOTPC:
+	  /* Use global offset table as symbol value; for synthesizing
+	     the address of the GOT in procedure prologue */
+
+	  need_imagebase = false;
+	  val = sgot->output_section->vma;
+	  valIsValid = true;
+	  break;
+
+	case R_GNU_PLT32:
+	  /* Relocation is to the entry for this symbol in the
+	     procedure linkage table.  */
+
+	  /* Resolve a PLT32 reloc against a local symbol directly,
+             without using the procedure linkage table.  */
+	  if (h == NULL) {
+	      /* Gas puts the symbol's value in the instruction in this
+		 case, so back it out. */
+	      val -= sym->n_value;
+	      break;
+	    }
+
+	  if (h_real->plt_offset == (bfd_vma) -1)
+	    {
+	      /* We didn't make a PLT entry for this (strong) symbol.  This
+                 happens when statically linking PIC code, or when
+                 using -Bsymbolic.  */
+	      break;
+	    }
+
+	  val = (splt->output_section->vma
+			+ splt->output_offset
+			+ h_real->plt_offset);
+	  need_imagebase = false;
+	  valIsValid = true;
+
+	  break;
+
+	case R_PCRLONG:
+
+	   /* Skip local or localized (by symbolic mode) entries */
+	   if (h == NULL
+	     || (info->symbolic
+		&& (h_real->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0))
+	   break;
+
+	  /* drop thru */
+	case R_DIR32:
+#ifdef USE_COPY_RELOC
+	  /* Don't bother if not a shared lib */
+	  if (info->shared)
+	      break;
+#endif
+	  /* stabs don't need this */
+	  if (is_stab_section)
+	      break;
+
+	  /* When generating a shared object (or when not using
+	     COPY relocations), these relocations
+	     are copied into the output file to be resolved at run
+	     time.  Ditto if a non-shared object and COPY relocations
+	     are not being used. */
+
+#ifndef USE_COPY_RELOC
+	  /* if we don't use copy relocs, certain symbol types will have
+	     leaked thru above that for a main (==not shared) we want to
+	     skip */
+	  if (!info->shared && h != NULL)
+	    {
+	      if (h->dynindx == -1)
+		  break;
+	      /* An ordinary symbol doesn't need a dynamic reloc in main;
+		 we get here when a shared library calls back into main, 
+		 and there are also (ordinary) calls within main. */
+	      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR)!=0
+	          && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC)==0)
+		  break;
+	    }
+#endif
+
+	  outrel.r_vaddr = rel->r_vaddr
+			   + input_section->output_section->vma
+			   + input_section->output_offset;
+
+	  /* The basic idea here is that we may or may not want to
+	     emit either class of relocation; for static relocations,
+	     if this reloc is against an external symbol, we do
+	     not want to fiddle with the addend.  Otherwise, we
+	     need to include the symbol value so that it becomes
+	     an addend for the dynamic reloc.  */
+
+	  if (rel->r_type == R_PCRLONG)
+	    {
+	      if (h != NULL && h_real->dynindx == -1)
+		{
+		  /* The branch is already PC-relative so there's nothing to do
+		     at runtime. */
+		  need_static_reloc = true;
+		}
+	     else if (sec != NULL && bfd_is_abs_section(sec->output_section))
+		{
+		  need_static_reloc = true;
+		  valIsValid = true;
+		  need_dynamic_reloc = false;
+		}
+	      else
+		{
+		  need_static_reloc = false;
+		  valIsValid = true;
+		  need_dynamic_reloc = true;
+ 		  /* The side effect in this assert (and the similar ones below)
+ 		     is safe... we only count the counters back up for debug 
+		     anyway. */
+		  BFD_ASSERT(!h || ++h->num_relative_relocs_needed <= 0);
+		  outrel.r_type = R_PCRLONG;
+		  outrel.r_symndx = h_real->dynindx;
+		}
+	    }
+	  else
+	    {
+	      /* The only alternative is DIR32 */
+
+	      if (h == NULL)
+		{
+		  /* symbol is local to the .o */
+		  need_static_reloc = true;
+		  need_dynamic_reloc = info->shared &&
+			!bfd_is_abs_section(sec->output_section);
+		  outrel.r_type = R_GNU_RELATIVE;
+		  outrel.r_symndx = 0;
+		}
+	      else if ((info->symbolic || h->dynindx == -1)
+		      && (h->coff_link_hash_flags
+			  & COFF_LINK_HASH_DEF_REGULAR) != 0)
+		{
+		  /* symbol is local to the module because it's symbolic;
+		     h->dynindx may be -1 if this symbol was marked to
+		     become local. */
+		  need_static_reloc = true;
+#ifdef USE_COPY_RELOC
+		  /* Make this always true if main programs will be 
+		     dynamically relocated (and if .reloc is still
+		     not being generated (for main); currently this only 
+		     happens if ld.so is used as a "run" command, and then
+		     randomly.  It may be necessary to tweak the relocation
+		     counting stuff accordingly. */
+		  need_dynamic_reloc = true;
+#else
+		  need_dynamic_reloc = info->shared;
+#endif
+		  /* no relocs for module local, absolute symbols */
+		  need_dynamic_reloc &= 
+			!bfd_is_abs_section(sec->output_section);
+		  BFD_ASSERT(!need_dynamic_reloc 
+			     || ++h->num_long_relocs_needed <= 0);
+		  outrel.r_type = R_GNU_RELATIVE;
+		  outrel.r_symndx = 0;
+		}
+	      else if (((h->coff_link_hash_flags 
+			& COFF_LINK_HASH_DEF_REGULAR) == 0)
+		       || (info->shared && !info->symbolic))
+		{
+		  /* Not defined in this module, or this is a shared 
+		     library (not symbolic), so we need a dynamic reloc;
+		     if it is defined in a main, it always wins even
+		     if there's also a dynamic version. */
+		  BFD_ASSERT (h->dynindx != -1);
+		  need_static_reloc = false;
+		  need_dynamic_reloc = true;
+		  BFD_ASSERT(++h->num_long_relocs_needed <= 0);
+		  valIsValid = true;
+		  outrel.r_type = R_DIR32;
+		  outrel.r_symndx = h->dynindx;
+		}
+	      /* else it gets a static reloc */
+	    }
+	  break;
+
+	default:
+	  break;
+	}
+#endif /* ] */
+
       if (!valIsValid)
 	{
-	  if (h->root.type == bfd_link_hash_undefined)
+	  if (h_real->root.type == bfd_link_hash_undefined)
 	    {
 	      if (!info->relocateable)
 		{
@@ -3130,7 +5954,35 @@ _bfd_coff_generic_relocate_section (outp
 	  val = 0;
 	}
 
-      if (need_imagebase)
+#ifdef DYNAMIC_LINKING
+
+      if (need_dynamic_reloc)
+	{
+	  bfd_coff_swap_reloc_out (output_bfd, &outrel,
+				    (struct external_reloc *)
+				      (sreloc->contents
+				     + sreloc->reloc_count * symrsz));
+	  ++sreloc->reloc_count;
+#ifdef DEBUG_COUNTING  // !!
+{
+struct coff_link_hash_entry *hh;
+char buf[SYMNMLEN + 1];
+fprintf(stderr, "added reloc # %d (%d) for %s / %s ", sreloc->reloc_count, outrel.r_type, symndx==-1?"local-symbol":h_real?h->root.root.string:"suppressed-symbol",_bfd_coff_internal_syment_name (input_bfd, sym, buf));
+
+if (symndx!=-1){
+hh = obj_coff_sym_hashes (input_bfd)[symndx];
+if (hh) fprintf(stderr, "%d %d %d\n", (hh->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) != 0, (hh->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0, hh->root.type);
+else fprintf(stderr, "nohash\n");
+}
+}
+#endif
+	}
+
+      if (!need_static_reloc)
+	  continue;
+#endif
+
+    if (need_imagebase)
 	addend += imagebase;
 
       if (info->base_file)
@@ -3202,3 +6054,1883 @@ _bfd_coff_generic_relocate_section (outp
     }
   return true;
 }
+
+#ifdef DYNAMIC_LINKING /* [ */
+/* This struct is used to pass information to routines called via
+   coff_link_hash_traverse which must return failure.  */
+struct coff_info_failed
+{
+  boolean failed;
+  struct bfd_link_info *info;
+};
+/* Create some sections which will be filled in with dynamic linking
+   information.  ABFD is an input file which requires dynamic sections
+   to be created.  The dynamic sections take up virtual memory space
+   when the final executable is run, so we need to create them before
+   addresses are assigned to the output sections.  We work out the
+   actual contents and size of these sections later.  */
+
+static boolean
+coff_link_create_dynamic_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  flagword flags;
+  register asection *s;
+
+  if (coff_hash_table (info)->dynamic_sections_created)
+    return true;
+
+  /* Make sure that all dynamic sections use the same input BFD.
+     It's likely (almost inevitable) that check_relocs (backend part)
+     captured some file for use as the anchor point for the dynamic sections
+     that wasn't itself a dynamic library.  We'll take what it used. */
+  if (coff_hash_table (info)->dynobj == NULL)
+    coff_hash_table (info)->dynobj = abfd;
+  else
+    abfd = coff_hash_table (info)->dynobj;
+
+  /* If this bfd doesn't have the dynamic data add-on, make one for it.
+     (This might be an ordinary .o) */
+
+  if (dyn_data(abfd) == NULL)
+      dyn_data(abfd) =
+        (struct dynamic_info *) bfd_zalloc(abfd, sizeof (struct dynamic_info));
+
+  /* Note that we set the SEC_IN_MEMORY flag for all of these
+     sections.  SEC_DEBUGGING was used to avoid unprotecting at runtime,
+     at the cost of breaking the strip command. */
+  flags = ( SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED | SEC_DATA);
+
+  /* A dynamically linked executable has a .interp section, but a
+     shared library does not.  */
+  if (! info->shared)
+    {
+      s = bfd_make_section (abfd, ".interp");
+      if (s == NULL
+	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY))
+	return false;
+    }
+
+  /* Create sections to hold version informations.  These are removed
+     if they are not needed.  */
+  s = bfd_make_section (abfd, ".gnu.version_d");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_NEVER_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return false;
+  coff_dynverdef(abfd) = s;
+
+  s = bfd_make_section (abfd, ".gnu.version");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_NEVER_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 1))
+    return false;
+  coff_dynversym(abfd) = s;
+
+  s = bfd_make_section (abfd, ".gnu.version_r");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_NEVER_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return false;
+
+  s = bfd_make_section (abfd, ".dynsym");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+	      flags | SEC_READONLY | SEC_ALLOC | SEC_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return false;
+  coff_dynsymtab(abfd) = s;
+
+  s = bfd_make_section (abfd, ".dynstr");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+	      flags | SEC_READONLY | SEC_ALLOC | SEC_LOAD))
+    return false;
+  coff_dynstrtab(abfd) = s;
+
+  /* Create a strtab to hold the dynamic symbol names.  */
+  if (coff_hash_table (info)->dynstr == NULL)
+    {
+      coff_hash_table (info)->dynstr = _bfd_coff_stringtab_init ();
+      if (coff_hash_table (info)->dynstr == NULL)
+	return false;
+    }
+
+  s = bfd_make_section (abfd, ".dynamic");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s, 
+	      flags | SEC_READONLY | SEC_ALLOC | SEC_LOAD)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return false;
+  coff_hash_table (info)->dynamic = s;
+
+  /* symbol _DYNAMIC is handled in the back end */
+
+  s = bfd_make_section (abfd, ".hash");
+  if (s == NULL
+      || ! bfd_set_section_flags (abfd, s,
+	      flags | SEC_READONLY)
+      || ! bfd_set_section_alignment (abfd, s, 2))
+    return false;
+
+  /* Let the backend create the rest of the sections.  This lets the
+     backend set the right flags.  The backend will normally create
+     the .got and .plt sections.  */
+  if (! bfd_coff_backend_link_create_dynamic_sections(abfd, info))
+    return false;
+
+  coff_hash_table (info)->dynamic_sections_created = true;
+
+  return true;
+}
+
+/* This structure is used to pass information to
+   coff_link_assign_sym_version.  */
+
+struct coff_assign_sym_version_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* Version tree.  */
+  struct bfd_elf_version_tree *verdefs;
+  /* Whether we are exporting all dynamic symbols.  */
+  boolean export_dynamic;
+  /* Whether we removed any symbols from the dynamic symbol table.  */
+  boolean removed_dynamic;
+  /* Whether we had a failure.  */
+  boolean failed;
+};
+
+/* This structure is used to pass information to
+   coff_link_find_version_dependencies.  */
+
+struct coff_find_verdep_info
+{
+  /* Output BFD.  */
+  bfd *output_bfd;
+  /* General link information.  */
+  struct bfd_link_info *info;
+  /* The number of dependencies.  */
+  unsigned int vers;
+  /* Whether we had a failure.  */
+  boolean failed;
+};
+
+/* Figure out appropriate versions for all the symbols.  We may not
+   have the version number script until we have read all of the input
+   files, so until that point we don't know which symbols should be
+   local.  This function is called via coff_link_hash_traverse.  */
+
+static boolean coff_link_assign_sym_version 
+  PARAMS((struct coff_link_hash_entry *, PTR));
+
+static boolean
+coff_link_assign_sym_version (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct coff_assign_sym_version_info *sinfo =
+    (struct coff_assign_sym_version_info *) data;
+  struct bfd_link_info *info = sinfo->info;
+  char *p;
+
+#ifdef USE_DLLS
+  /* If this showed up in a DLL after we added it to the dynamic link
+     table... drop it.  However, __imp_* symbols were already treated. */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) != 0 
+       && h->dynindx != -1)
+     {
+	sinfo->removed_dynamic = true;
+	h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	h->dynindx = -1;
+	/* FIXME: The name of the symbol (if long enough) has
+	   already been recorded in the dynamic
+	   string table section.  */
+	return true;
+     }
+#endif
+
+  /* If asked to strip specific definitions by name (actually, keep), we 
+     will honor that, we just can't do that for references, however.
+     This allows creation of shared libs with controlled export lists.
+     ...MAYBE_FORCED_LOCAL got set in ...record_dynamic_symbol
+     and found that it was one we might strip.  However, we
+     can only strip locally defined symbols, and since we didn't
+     know at the time, we check again now.   ...MAYBE_FORCED_LOCAL
+     isn't strictly necessary (the hash lookup could be done here) but it
+     helps a little in keeping trash out of the dynamic symbol table;
+     if that's ever fixed, it might be done away with. */
+  if ((h->coff_link_hash_flags & COFF_LINK_MAYBE_FORCED_LOCAL) != 0)
+    {
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0 )
+	{
+	   sinfo->removed_dynamic = true;
+	   h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	   h->dynindx = -1;
+	   /* FIXME: The name of the symbol (if long enough) has
+	      already been recorded in the dynamic
+	      string table section.  */
+	   return true;
+	}
+      else
+	{
+	   /* The user asked us to strip an undef or dynamic;
+	      we can't do that. */
+	   h->coff_link_hash_flags &= ~COFF_LINK_MAYBE_FORCED_LOCAL;
+	   (*_bfd_error_handler)
+	     (_("Warning: --retain-symbols would strip %s but it is not "
+	      "locally defined and must be retained."),
+	      h->root.root.string);
+	   h->indx = -2;
+	}
+    }
+
+  /* We only need version numbers for symbols defined in regular
+     objects.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0)
+    return true;
+
+  p = strchr (h->root.root.string, COFF_VER_CHR);
+  if (h->root.root.string[0] != '?' && p != NULL && h->verinfo.vertree == NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      boolean hidden;
+
+      hidden = true;
+
+      /* There are two consecutive COFF_VER_CHR characters if this is
+         not a hidden symbol.  */
+      ++p;
+      if (*p == COFF_VER_CHR)
+	{
+	  hidden = false;
+	  ++p;
+	}
+
+      /* If there is no version string, we can just return out.  */
+      if (*p == '\0')
+	{
+	  if (hidden)
+	    h->coff_link_hash_flags |= COFF_LINK_HIDDEN;
+	  return true;
+	}
+
+      /* Look for the version.  If we find it, it is no longer weak.  */
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (strcmp (t->name, p) == 0)
+	    {
+	      int len;
+	      char *alc;
+	      struct bfd_elf_version_expr *d;
+
+	      len = p - h->root.root.string;
+	      alc = bfd_alloc (sinfo->output_bfd, len);
+	      if (alc == NULL)
+	        return false;
+	      strncpy (alc, h->root.root.string, len - 1);
+	      alc[len - 1] = '\0';
+	      if (alc[len - 2] == COFF_VER_CHR)
+	        alc[len - 2] = '\0';
+
+	      h->verinfo.vertree = t;
+	      t->used = true;
+	      d = NULL;
+
+	      if (t->globals != NULL)
+		{
+		  for (d = t->globals; d != NULL; d = d->next)
+		    if ((*d->match) (d, alc))
+		      break;
+		}
+
+	      /* See if there is anything to force this symbol to
+                 local scope.  */
+	      if (d == NULL && t->locals != NULL)
+		{
+		  for (d = t->locals; d != NULL; d = d->next)
+		    {
+		      if ((*d->match) (d, alc))
+			{
+			  if (h->dynindx != -1
+			      && info->shared
+			      && ! sinfo->export_dynamic)
+			    {
+			      sinfo->removed_dynamic = true;
+			      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			      h->coff_link_hash_flags &=~
+				COFF_LINK_HASH_NEEDS_PLT;
+			      h->dynindx = -1;
+			      // h->plt.offset = (bfd_vma) -1;
+			      /* FIXME: The name of the symbol has
+				 already been recorded in the dynamic
+				 string table section.  */
+			    }
+
+			  break;
+			}
+		    }
+		}
+
+	      bfd_release (sinfo->output_bfd, alc);
+	      break;
+	    }
+	}
+#if 0 // discard
+------------
+      /* Look for the version.  If we find it, it is no longer weak.  */
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (strcmp (t->name, p) == 0)
+	    {
+	      h->verinfo.vertree = t;
+	      t->used = true;
+
+	      /* See if there is anything to force this symbol to
+                 local scope.  */
+	      if (t->locals != NULL)
+		{
+		  int len;
+		  char *alc;
+		  struct bfd_elf_version_expr *d;
+
+		  len = p - h->root.root.string;
+		  alc = bfd_alloc (sinfo->output_bfd, len);
+		  if (alc == NULL)
+		    return false;
+		  strncpy (alc, h->root.root.string, len - 1);
+		  alc[len - 1] = '\0';
+		  if (alc[len - 2] == COFF_VER_CHR)
+		    alc[len - 2] = '\0';
+
+		  for (d = t->locals; d != NULL; d = d->next)
+		    {
+		      if ((d->match[0] == '*' && d->match[1] == '\0')
+			  || fnmatch (d->match, alc, 0) == 0)
+			{
+			  if (h->dynindx != -1
+			      && info->shared
+			      && ! sinfo->export_dynamic
+			      && (h->coff_link_hash_flags
+				  & COFF_LINK_HASH_NEEDS_PLT) == 0)
+			    {
+			      sinfo->removed_dynamic = true;
+			      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			      h->dynindx = -1;
+			      /* FIXME: The name of the symbol has
+				 already been recorded in the dynamic
+				 string table section.  */
+			    }
+
+			  break;
+			}
+		    }
+
+		  bfd_release (sinfo->output_bfd, alc);
+		}
+
+	      break;
+	    }
+	}
+#endif // end discard
+
+      /* If we are building an application, we need to create a
+         version node for this version.  */
+      if (t == NULL && ! info->shared)
+	{
+	  struct bfd_elf_version_tree **pp;
+	  int version_index;
+
+	  /* If we aren't going to export this symbol, we don't need
+             to worry about it. */
+	  if (h->dynindx == -1)
+	    return true;
+
+	  t = ((struct bfd_elf_version_tree *)
+	       bfd_alloc (sinfo->output_bfd, sizeof *t));
+	  if (t == NULL)
+	    {
+	      sinfo->failed = true;
+	      return false;
+	    }
+
+	  t->next = NULL;
+	  t->name = p;
+	  t->globals = NULL;
+	  t->locals = NULL;
+	  t->deps = NULL;
+	  t->name_indx = (unsigned int) -1;
+	  t->used = true;
+
+	  version_index = 1;
+	  for (pp = &sinfo->verdefs; *pp != NULL; pp = &(*pp)->next)
+	    ++version_index;
+	  t->vernum = version_index;
+
+	  *pp = t;
+
+	  h->verinfo.vertree = t;
+	}
+      else if (t == NULL)
+	{
+	  /* We could not find the version for a symbol when
+             generating a shared archive.  Return an error.  */
+	  (*_bfd_error_handler)
+	    (_("%s: undefined version name %s"),
+	     bfd_get_filename (sinfo->output_bfd), h->root.root.string);
+	  bfd_set_error (bfd_error_bad_value);
+	  sinfo->failed = true;
+	  return false;
+	}
+
+      if (hidden)
+	h->coff_link_hash_flags |= COFF_LINK_HIDDEN;
+    }
+
+  /* If we don't have a version for this symbol, see if we can find
+     something.  */
+  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_tree *deflt;
+      struct bfd_elf_version_expr *d;
+
+      /* See if can find what version this symbol is in.  If the
+         symbol is supposed to be local, then don't actually register
+         it.  */
+      deflt = NULL;
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (t->globals != NULL)
+	    {
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if ((*d->match) (d, h->root.root.string))
+		    {
+		      h->verinfo.vertree = t;
+		      break;
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	    }
+
+	  if (t->locals != NULL)
+	    {
+	      for (d = t->locals; d != NULL; d = d->next)
+		{
+		  if (d->pattern[0] == '*' && d->pattern[1] == '\0')
+		    deflt = t;
+		  else if ((*d->match) (d, h->root.root.string))
+		    {
+		      h->verinfo.vertree = t;
+		      if (h->dynindx != -1
+			  && info->shared
+			  && ! sinfo->export_dynamic)
+			{
+			  sinfo->removed_dynamic = true;
+			  h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			  h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+			  h->dynindx = -1;
+			  // h->plt.offset = (bfd_vma) -1;
+			  /* FIXME: The name of the symbol has already
+			     been recorded in the dynamic string table
+			     section.  */
+			}
+		      break;
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	    }
+	}
+
+      if (deflt != NULL && h->verinfo.vertree == NULL)
+	{
+	  h->verinfo.vertree = deflt;
+	  if (h->dynindx != -1
+	      && info->shared
+	      && ! sinfo->export_dynamic)
+	    {
+	      sinfo->removed_dynamic = true;
+	      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	      h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+	      h->dynindx = -1;
+	      //h->plt.offset = (bfd_vma) -1;
+	      /* FIXME: The name of the symbol has already been
+		 recorded in the dynamic string table section.  */
+	    }
+	}
+    }
+#if 0 // discard
+  /* If we don't have a version for this symbol, see if we can find
+     something.  */
+  if (h->verinfo.vertree == NULL && sinfo->verdefs != NULL)
+    {
+      struct bfd_elf_version_tree *t;
+      struct bfd_elf_version_tree *deflt;
+      struct bfd_elf_version_expr *d;
+
+      /* See if can find what version this symbol is in.  If the
+         symbol is supposed to eb local, then don't actually register
+         it.  */
+      deflt = NULL;
+      for (t = sinfo->verdefs; t != NULL; t = t->next)
+	{
+	  if (t->globals != NULL)
+	    {
+	      for (d = t->globals; d != NULL; d = d->next)
+		{
+		  if (fnmatch (d->match, h->root.root.string, 0) == 0)
+		    {
+		      h->verinfo.vertree = t;
+		      break;
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	    }
+
+	  if (t->locals != NULL)
+	    {
+	      for (d = t->locals; d != NULL; d = d->next)
+		{
+		  if (d->match[0] == '*' && d->match[1] == '\0')
+		    deflt = t;
+		  else if (fnmatch (d->match, h->root.root.string, 0) == 0)
+		    {
+		      h->verinfo.vertree = t;
+		      if (h->dynindx != -1
+			  && info->shared
+			  && ! sinfo->export_dynamic
+			  && (h->coff_link_hash_flags
+			      & COFF_LINK_HASH_NEEDS_PLT) == 0)
+			{
+			  sinfo->removed_dynamic = true;
+			  h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+			  h->dynindx = -1;
+			  /* FIXME: The name of the symbol has already
+			     been recorded in the dynamic string table
+			     section.  */
+			}
+		      break;
+		    }
+		}
+
+	      if (d != NULL)
+		break;
+	    }
+	}
+
+      if (deflt != NULL && h->verinfo.vertree == NULL)
+	{
+	  h->verinfo.vertree = deflt;
+	  if (h->dynindx != -1
+	      && info->shared
+	      && ! sinfo->export_dynamic
+	      && (h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) == 0)
+	    {
+	      sinfo->removed_dynamic = true;
+	      h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	      h->dynindx = -1;
+	      /* FIXME: The name of the symbol has already been
+		 recorded in the dynamic string table section.  */
+	    }
+	}
+    }
+#endif // discard
+
+  return true;
+}
+
+/* This routine is used to export all defined symbols into the dynamic
+   symbol table.  It is called via coff_link_hash_traverse.  */
+
+static boolean coff_export_symbol 
+  PARAMS((struct coff_link_hash_entry *, PTR));
+
+static boolean
+coff_export_symbol (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct coff_info_failed *eif = (struct coff_info_failed *) data;
+
+  /* Ignore indirect symbols.  These are added by the versioning code.  */
+  if (h->root.type == bfd_link_hash_indirect
+      && !h->root.u.i.info.alias)
+    return true;
+
+  if (h->dynindx == -1
+      && (h->coff_link_hash_flags
+          & (COFF_LINK_HASH_DEF_REGULAR | COFF_LINK_HASH_REF_REGULAR)) != 0)
+    {
+      if (! _bfd_coff_link_record_dynamic_symbol (eif->info, h))
+        {
+          eif->failed = true;
+          return false;
+        }    
+    }
+
+  return true;
+}
+
+/* This function is used to renumber the dynamic symbols, if some of
+   them are removed because they are marked as local.  This is called
+   via coff_link_hash_traverse.   Since we also want alias symbols
+   to follow the "real" definition, we look for them and emit them
+   in the proper order. */
+
+static boolean coff_link_renumber_dynsyms
+  PARAMS((struct coff_link_hash_entry *, PTR));
+
+static boolean
+coff_link_renumber_dynsyms (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct bfd_link_info *info = (struct bfd_link_info *) data;
+
+  if (h->dynindx != -1
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_RENUMBERED) == 0)
+    {
+      if (h->root.type == bfd_link_hash_indirect
+	  && h->root.u.i.info.alias) 
+	{
+	  struct coff_link_hash_entry *h_real = h;
+
+	  if ((h->coff_link_hash_flags 
+		   & (COFF_LINK_HASH_DEF_DYNAMIC | COFF_LINK_HASH_REF_DYNAMIC)) == 0
+	       && !info->shared)
+	    {
+	       /* Under certain circumstances a weak symbol that starts
+		  out as dynmamic can completely disappear into a static symbol.
+		  (When it is a weak for a static strong, e.g. environ.) */
+	       h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	       h->dynindx = -1;
+	       return true;
+	    }
+
+	  while (h_real->root.type == bfd_link_hash_indirect
+		  && h_real->root.u.i.info.alias)
+	    h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+	  if (h_real->dynindx == -1)
+	    {
+              BFD_ASSERT(false); // leave for a while, then delete. (9/00)
+              /* Someone tossed the strong symbol ... the weak one goes too,
+                 or the symbol table structure is bad.
+                 However the weak may have prevented the strong one from
+                 being deleted earlier. */
+	       h->dynindx = -1;
+	       h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	       return true;
+	    }
+
+          if ((h_real->coff_link_hash_flags & COFF_LINK_HASH_RENUMBERED) == 0)
+	    {
+              h_real->coff_link_hash_flags |= COFF_LINK_HASH_RENUMBERED;
+	      h_real->dynindx = coff_hash_table (info)->dynsymcount;
+	      ++coff_hash_table (info)->dynsymcount;
+	    }
+
+	  h->dynindx = coff_hash_table (info)->dynsymcount;
+	  /* The alias itself takes another slot */
+	  coff_hash_table (info)->dynsymcount += 2;
+	}
+      else 
+	{
+	  h->dynindx = coff_hash_table (info)->dynsymcount;
+	  ++coff_hash_table (info)->dynsymcount;
+	}
+      h->coff_link_hash_flags |= COFF_LINK_HASH_RENUMBERED;
+    }
+
+  return true;
+}
+
+
+/* Look through the symbols which are defined in other shared
+   libraries and referenced here.  Update the list of version
+   dependencies.  This will be put into the .gnu.version_r section.
+   This function is called via coff_link_hash_traverse.  */
+
+static boolean coff_link_find_version_dependencies
+  PARAMS((struct coff_link_hash_entry *, PTR));
+
+static boolean
+coff_link_find_version_dependencies (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct coff_find_verdep_info *rinfo = (struct coff_find_verdep_info *) data;
+  coff_internal_verneed *t;
+  coff_internal_vernaux *a;
+
+  /* We only care about symbols defined in shared objects with version
+     information.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+      || (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0
+      || h->dynindx == -1
+      || h->verinfo.verdef == NULL)
+    return true;
+
+  /* See if we already know about this version.  */
+  for (t = dyn_data (rinfo->output_bfd)->verref; t != NULL; t = t->vn_nextref)
+    {
+      if (t->vn_bfd == h->verinfo.verdef->vd_bfd)
+	continue;
+
+      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
+	  return true;
+
+      break;
+    }
+
+  /* This is a new version.  Add it to tree we are building.  */
+
+  if (t == NULL)
+    {
+      t = (coff_internal_verneed *) bfd_zalloc (rinfo->output_bfd, sizeof *t);
+      if (t == NULL)
+	{
+	  rinfo->failed = true;
+	  return false;
+	}
+
+      t->vn_bfd = h->verinfo.verdef->vd_bfd;
+      t->vn_nextref = dyn_data (rinfo->output_bfd)->verref;
+      dyn_data (rinfo->output_bfd)->verref = t;
+    }
+
+  a = (coff_internal_vernaux *) bfd_zalloc (rinfo->output_bfd, sizeof *a);
+
+  /* Note that we are copying a string pointer here, and testing it
+     above.  If bfd_coff_string_from_coff_section is ever changed to
+     discard the string data when low in memory, this will have to be
+     fixed.  */
+  a->vna_nodename = h->verinfo.verdef->vd_nodename;
+
+  a->vna_flags = h->verinfo.verdef->vd_flags;
+  a->vna_nextptr = t->vn_auxptr;
+
+  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
+  ++rinfo->vers;
+
+  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;
+
+  t->vn_auxptr = a;
+
+  return true;
+}
+
+static boolean coff_adjust_dynamic_symbol
+  PARAMS ((struct coff_link_hash_entry *, PTR));
+
+/* Make the backend pick a good value for a dynamic symbol.  This is
+   called via coff_link_hash_traverse, and also calls itself
+   recursively.  */
+static boolean
+coff_adjust_dynamic_symbol (h, data)
+     struct coff_link_hash_entry *h;
+     PTR data;
+{
+  struct coff_info_failed *eif = (struct coff_info_failed *) data;
+  bfd *dynobj = coff_hash_table (eif->info)->dynobj;
+  boolean skip = false;
+
+  /* If it's a weak symbol, we may need to touch up the corresponding
+     strong symbol, or the weak itself. */
+  if (h->root.type == bfd_link_hash_indirect
+      && h->root.u.i.info.alias)
+    {
+      struct coff_link_hash_entry *h_real = h;
+
+      while (h_real->root.type == bfd_link_hash_indirect
+             && h_real->root.u.i.info.alias)
+       h_real = (struct coff_link_hash_entry *) h_real->root.u.i.link;
+
+#ifdef USE_DLLS
+      /* If it's a weak symbol that's not a DLL symbol then clear out the DLL 
+	 flag on the strong one... the user really did want it. */
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) == 0)
+          h_real->coff_link_hash_flags &= ~COFF_LINK_HASH_DLL_DEFINED;
+#endif
+
+      /* The strong symbol needs to be referenced from anywhere the weak
+	 one was. */
+      h_real->coff_link_hash_flags 
+	  |= h->coff_link_hash_flags 
+	     & (COFF_LINK_HASH_REF_REGULAR | COFF_LINK_HASH_REF_DYNAMIC);
+
+      /* The weak symbol needs to appear to come from the same source
+	 as the strong one. */
+      h->coff_link_hash_flags 
+	  &= ~(COFF_LINK_HASH_DEF_REGULAR | COFF_LINK_HASH_DEF_DYNAMIC);
+      h->coff_link_hash_flags 
+	  |= h_real->coff_link_hash_flags 
+	     & (COFF_LINK_HASH_DEF_REGULAR | COFF_LINK_HASH_DEF_DYNAMIC);
+
+      if (!(eif->info)->shared
+         && (h->coff_link_hash_flags 
+	     & (COFF_LINK_HASH_REF_DYNAMIC | COFF_LINK_HASH_DEF_DYNAMIC)) == 0)
+	{
+	   /* Both the strong and weak symbol must be properly present,
+	      or the symbol table structure is bad.
+	      However the weak may have prevented the strong one from
+	      being deleted earlier. */
+	   h->dynindx = -1;
+	   h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+	   skip = true;
+	   goto done;
+	}
+
+      if ((!(eif->info)->shared || (eif->info)->symbolic)
+	  && (h->coff_link_hash_flags 
+	      & (COFF_LINK_HASH_DEF_DYNAMIC | COFF_LINK_HASH_REF_DYNAMIC)) != 0)
+	{
+	   /* We're building an executable; at this point weak refs
+	      to dynamic symbols need to be converted to ordinary
+	      references, so clone the critical info.  Gdb needs type,
+	      but so does subsequent code here. */
+
+	   h->root.type = h_real->root.type;
+	   h->root.u = h_real->root.u;
+	   h->type = h_real->type;
+	   h->class = C_EXT;
+	   h->numaux = 0;
+	}
+    }
+  /* Ignore (remaining) indirect symbols (both).  
+     Weak indirects don't need further processing.
+     Real indirects are added by the versioning code. */
+  if (h->root.type == bfd_link_hash_indirect)
+    {
+       skip=true;
+       goto done;
+    }
+
+  /* If this symbol was mentioned in a non-COFF file, try to set
+     DEF_REGULAR and REF_REGULAR correctly.  This is the only way to
+     permit a non-COFF file to correctly refer to a symbol defined in
+     an COFF dynamic object.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_NON_COFF) != 0)
+    {
+      if (h->root.type != bfd_link_hash_defined
+	  && h->root.type != bfd_link_hash_defweak)
+	h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+      else
+	{
+	  if (h->root.u.def.section->owner != NULL
+	      && (bfd_get_flavour (h->root.u.def.section->owner)
+		  == bfd_target_coff_flavour)
+		  )
+	    h->coff_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+	  else
+	    h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+	}
+
+      if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) != 0
+	  || (h->coff_link_hash_flags & COFF_LINK_HASH_REF_DYNAMIC) != 0)
+	{
+	  if (! _bfd_coff_link_record_dynamic_symbol (eif->info, h))
+	    {
+	      eif->failed = true;
+	      return false;
+	    }
+	}
+    }
+
+  /* If this is a final link, and the symbol was defined as a common
+     symbol in a regular object file, and there was no definition in
+     any dynamic object, then the linker will have allocated space for
+     the symbol in a common section but the COFF_LINK_HASH_DEF_REGULAR
+     flag will not have been set.  */
+  if (h->root.type == bfd_link_hash_defined
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) == 0
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) != 0
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+      && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)
+    h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+
+  /* If -Bsymbolic was used (which means to bind references to global
+     symbols to the definition within the shared object), and this
+     symbol was defined in a regular object, then it actually doesn't
+     need a PLT entry.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) != 0
+      && eif->info->shared
+      && eif->info->symbolic
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+    h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+
+  /* If this symbol does not require a PLT entry, and it is not
+     defined by a dynamic object, or is not referenced by a regular
+     object, ignore it.  We do have to handle a weak defined symbol,
+     even if no regular object refers to it, if we decided to add it
+     to the dynamic symbol table.  FIXME: Do we normally need to worry
+     about symbols which are defined by one dynamic object and
+     referenced by another one?  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_NEEDS_PLT) == 0
+      && ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0
+	  || (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC) == 0
+	  || ((h->coff_link_hash_flags & COFF_LINK_HASH_REF_REGULAR) == 0
+#ifdef USE_WEAK
+	       && (h->weakdef == NULL || h->weakdef->dynindx == -1)
+#endif
+	      )))
+    {
+       skip=true;
+       goto done;
+    }
+
+  /* if the symbol is defined in a dll, it doesn't need a PLT entry;
+     it's ignorable */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DLL_DEFINED) != 0)
+    {
+       h->coff_link_hash_flags &=~ COFF_LINK_HASH_NEEDS_PLT;
+       skip=true;
+       goto done;
+    }
+
+  /* If we've already adjusted this symbol, don't do it again.  This
+     can happen via a recursive call.  */
+  if ((h->coff_link_hash_flags & COFF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
+    {
+       skip=true;
+       goto done;
+    }
+
+  /* Don't look at this symbol again.  Note that we must set this
+     after checking the above conditions, because we may look at a
+     symbol once, decide not to do anything, and then get called
+     recursively later after REF_REGULAR is set below.  */
+  h->coff_link_hash_flags |= COFF_LINK_HASH_DYNAMIC_ADJUSTED;
+
+#ifdef USE_WEAK /* [ */
+  /* If this is a weak definition, and we know a real definition, and
+     the real symbol is not itself defined by a regular object file,
+     then get a good value for the real definition.  We handle the
+     real symbol first, for the convenience of the backend routine.
+
+     Note that there is a confusing case here.  If the real definition
+     is defined by a regular object file, we don't get the real symbol
+     from the dynamic object, but we do get the weak symbol.  If the
+     processor backend uses a COPY reloc, then if some routine in the
+     dynamic object changes the real symbol, we will not see that
+     change in the corresponding weak symbol.  This is the way other
+     ELF linkers work as well, and seems to be a result of the shared
+     library model.
+
+     I will clarify this issue.  Most SVR4 shared libraries define the
+     variable _timezone and define timezone as a weak synonym.  The
+     tzset call changes _timezone.  If you write
+       extern int timezone;
+       int _timezone = 5;
+       int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }
+     you might expect that, since timezone is a synonym for _timezone,
+     the same number will print both times.  However, if the processor
+     backend uses a COPY reloc, then actually timezone will be copied
+     into your process image, and, since you define _timezone
+     yourself, _timezone will not.  Thus timezone and _timezone will
+     wind up at different memory locations.  The tzset call will set
+     _timezone, leaving timezone unchanged.  */
+
+  if (h->weakdef != NULL)
+    {
+      struct elf_link_hash_entry *weakdef;
+
+      BFD_ASSERT (h->root.type == bfd_link_hash_defined
+		  || h->root.type == bfd_link_hash_defweak);
+      weakdef = h->weakdef;
+      BFD_ASSERT (weakdef->root.type == bfd_link_hash_defined
+		  || weakdef->root.type == bfd_link_hash_defweak);
+      BFD_ASSERT (weakdef->elf_link_hash_flags & COFF_LINK_HASH_DEF_DYNAMIC);
+      if ((weakdef->elf_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+	{
+	  /* This symbol is defined by a regular object file, so we
+	     will not do anything special.  Clear weakdef for the
+	     convenience of the processor backend.  */
+	  h->weakdef = NULL;
+	}
+      else
+	{
+	  /* There is an implicit reference by a regular object file
+	     via the weak symbol.  */
+	  weakdef->elf_link_hash_flags |= COFF_LINK_HASH_REF_REGULAR;
+	  if (! elf_adjust_dynamic_symbol (weakdef, (PTR) eif))
+	    return false;
+	}
+    }
+#endif /* ] */
+
+done:
+  if (! bfd_coff_backend_adjust_dynamic_symbol (dynobj, eif->info, h, skip))
+    {
+      eif->failed = true;
+      return false;
+    }
+
+  return true;
+}
+
+/* Array used to determine the number of hash table buckets to use
+   based on the number of symbols there are.  If there are fewer than
+   3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,
+   fewer than 37 we use 17 buckets, and so forth.  We never use more
+   than 32771 buckets.  */
+
+static const size_t coff_buckets[] =
+{
+  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
+  16411, 32771, 0
+};
+
+
+/* Set up the sizes and contents of the COFF dynamic sections.  This is
+   called by the COFF linker emulation before_allocation routine.  We
+   must set the sizes of the sections before the linker sets the
+   addresses of the various sections.  */
+
+boolean
+bfd_coff_size_dynamic_sections (output_bfd, soname, rpath,
+				     filter_shlib,
+				     auxiliary_filters, info, sinterpptr,
+				     verdefs)
+     bfd *output_bfd;
+     const char *soname;
+     const char *rpath;
+     const char *filter_shlib;
+     const char * const *auxiliary_filters;
+     struct bfd_link_info *info;
+     asection **sinterpptr;
+     struct bfd_elf_version_tree *verdefs;
+{
+  bfd_size_type soname_indx;
+  bfd *dynobj;
+  bfd_size_type old_dynsymcount;
+
+  struct coff_info_failed eif;
+  struct coff_link_hash_entry *h;
+  bfd_size_type strsize;
+
+  size_t dynsymcount;
+  asection *verdef_section;
+  asection *verref_section;
+  asection *version_section;
+  asection *dynsym_section;
+  asection *hash_section;
+  size_t i;
+  size_t bucketcount = 0;
+  struct internal_syment isym;
+  struct coff_assign_sym_version_info sinfo;
+
+  *sinterpptr = NULL;
+
+  soname_indx = (bfd_size_type)-1;
+
+  if (info->hash->creator->flavour != bfd_target_coff_flavour)
+    return true;
+
+  /* If there were no dynamic objects in the link, there is little to
+     do here.  However, in case we got some PIC in the program, we
+     need to create a GOT, etc. as needed.  We'll wait until
+     we're ready, otherwise. */
+  if (!coff_hash_table(info)->dynamic_sections_created)
+    {
+      if (!bfd_coff_backend_size_dynamic_sections (output_bfd, info))
+	return false;
+      return true;
+    }
+
+  if (dyn_data(output_bfd) == NULL)
+      dyn_data(output_bfd) =
+        (struct dynamic_info *) bfd_zalloc(output_bfd, sizeof (struct dynamic_info));
+
+  output_bfd->flags |= DYNAMIC;
+  dynobj = coff_hash_table (info)->dynobj;
+
+  /* If we are supposed to export all symbols into the dynamic symbol
+     table (this is not the normal case), then do so.  */
+  if (info->export_dynamic)
+    {
+      struct coff_info_failed eif;
+
+      eif.failed = false;
+      eif.info = info;
+      coff_link_hash_traverse (coff_hash_table (info), coff_export_symbol,
+			      (PTR) &eif);
+      if (eif.failed)
+	return false;
+    }
+
+
+  *sinterpptr = bfd_get_section_by_name (dynobj, ".interp");
+  BFD_ASSERT (*sinterpptr != NULL || info->shared);
+
+  if (soname != NULL)
+    {
+      soname_indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+					soname, true, true);
+      if (soname_indx == (bfd_size_type) -1
+	  || ! coff_add_dynamic_entry (info, DT_SONAME, soname_indx))
+	return false;
+    }
+
+  if (info->symbolic)
+    {
+      if (! coff_add_dynamic_entry (info, DT_SYMBOLIC, 0))
+	return false;
+    }
+
+  if (rpath != NULL)
+    {
+      bfd_size_type indx;
+
+      indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr, rpath,
+				 true, true);
+      if (indx == (bfd_size_type) -1
+	  || ! coff_add_dynamic_entry (info, DT_RPATH, indx))
+	return false;
+    }
+
+  if (filter_shlib != NULL)
+    {
+      bfd_size_type indx;
+
+      indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+				 filter_shlib, true, true);
+      if (indx == (bfd_size_type) -1
+	  || ! coff_add_dynamic_entry (info, DT_FILTER, indx))
+	return false;
+    }
+
+  if (auxiliary_filters != NULL)
+    {
+      const char * const *p;
+
+      for (p = auxiliary_filters; *p != NULL; p++)
+	{
+	  bfd_size_type indx;
+
+	  indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+				     *p, true, true);
+	  if (indx == (bfd_size_type) -1
+	      || ! coff_add_dynamic_entry (info, DT_AUXILIARY, indx))
+	    return false;
+	}
+    }
+
+  /* Find all symbols which were defined in a dynamic object and make
+     the backend pick a reasonable value for them.  */
+  eif.failed = false;
+  eif.info = info;
+  coff_link_hash_traverse (coff_hash_table (info),
+			  coff_adjust_dynamic_symbol,
+			  (PTR) &eif);
+  if (eif.failed)
+    return false;
+
+  /* Add some entries to the .dynamic section.  We fill in some of the
+     values later, in coff_bfd_final_link, but we must add the entries
+     now so that we know the final size of the .dynamic section.  */
+  h =  coff_link_hash_lookup (coff_hash_table (info), 
+	      &"__init"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1],
+	      false, false, false);
+  if (h != NULL
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+    {
+      if (! coff_add_dynamic_entry (info, DT_INIT, 0))
+	return false;
+    }
+  h =  coff_link_hash_lookup (coff_hash_table (info), 
+	      &"__fini"[bfd_get_symbol_leading_char(dynobj)=='_'?0:1],
+	      false, false, false);
+  if (h != NULL
+      && (h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0)
+    {
+      if (! coff_add_dynamic_entry (info, DT_FINI, 0))
+	return false;
+    }
+  strsize = _bfd_stringtab_size (coff_hash_table (info)->dynstr);
+  if (! coff_add_dynamic_entry (info, DT_HASH, 0)
+      || ! coff_add_dynamic_entry (info, DT_STRTAB, 0)
+      || ! coff_add_dynamic_entry (info, DT_SYMTAB, 0)
+      || ! coff_add_dynamic_entry (info, DT_STRSZ, strsize)
+      || ! coff_add_dynamic_entry (info, DT_SYMENT,
+				  bfd_coff_symesz (output_bfd)))
+    return false;
+
+  /* The backend must work out the sizes of all the other dynamic
+     sections.  */
+  old_dynsymcount = coff_hash_table (info)->dynsymcount;
+  if (!bfd_coff_backend_size_dynamic_sections (output_bfd, info))
+    return false;
+
+  /* Set up the version definition section.  */
+  verdef_section = bfd_get_section_by_name (dynobj, ".gnu.version_d");
+  BFD_ASSERT (verdef_section != NULL);
+
+  /* Attach all the symbols to their version information.  This
+     may cause some symbols to be unexported.  */
+  sinfo.output_bfd = output_bfd;
+  sinfo.info = info;
+  sinfo.verdefs = verdefs;
+  sinfo.export_dynamic = info->export_dynamic;
+  sinfo.removed_dynamic = false;
+  sinfo.failed = false;
+
+  coff_link_hash_traverse (coff_hash_table (info),
+			  coff_link_assign_sym_version,
+			  (PTR) &sinfo);
+  if (sinfo.failed)
+    return false;
+
+  /* Some dynamic symbols were changed to be local
+     symbols.  In this case, we renumber all of the
+     dynamic symbols, so that we don't have a hole.  If
+     the backend changed dynsymcount, then assume that the
+     new symbols are at the start.  This is the case on
+     the MIPS.  FIXME: The names of the removed symbols
+     will still be in the dynamic string table, wasting
+     space.   Althoug sinfo.removed_dynamic tells us that
+     it's needed for symbol deletions, we do it unconditionally
+     to reorder alias symbols at the same time. */
+  coff_hash_table (info)->dynsymcount =
+    1 + (coff_hash_table (info)->dynsymcount - old_dynsymcount);
+  coff_link_hash_traverse (coff_hash_table (info),
+			  coff_link_renumber_dynsyms,
+			  (PTR) info);
+
+  /* We may have created additional version definitions if we are
+     just linking a regular application.  */
+  verdefs = sinfo.verdefs;
+
+  if (verdefs == NULL)
+    {
+      asection **spp;
+
+      /* Don't include this section in the output file.  */
+      for (spp = &output_bfd->sections;
+	   *spp != NULL;
+	   spp = &(*spp)->next)
+	{
+	  if (*spp == verdef_section->output_section)
+	    {
+	      *spp = verdef_section->output_section->next;
+	      --output_bfd->section_count;
+	      break;
+	    }
+	}
+    }
+  else
+    {
+      unsigned int cdefs;
+      bfd_size_type size;
+      struct bfd_elf_version_tree *t;
+      bfd_byte *p;
+      coff_internal_verdef def;
+      coff_internal_verdaux defaux;
+
+
+      cdefs = 0;
+      size = 0;
+
+      /* Make space for the base version.  */
+      size += sizeof (coff_external_verdef);
+      size += sizeof (coff_external_verdaux);
+      ++cdefs;
+
+      for (t = verdefs; t != NULL; t = t->next)
+	{
+	  struct bfd_elf_version_deps *n;
+
+	  size += sizeof (coff_external_verdef);
+	  size += sizeof (coff_external_verdaux);
+	  ++cdefs;
+
+	  for (n = t->deps; n != NULL; n = n->next)
+	    size += sizeof (coff_external_verdaux);
+	}
+
+      verdef_section->_raw_size = size;
+      verdef_section->contents = (bfd_byte *) bfd_alloc (output_bfd, verdef_section->_raw_size);
+      if (verdef_section->contents == NULL && verdef_section->_raw_size != 0)
+	return false;
+
+      /* Fill in the version definition section.  */
+
+      p = verdef_section->contents;
+
+      def.vd_version = VER_DEF_CURRENT;
+      def.vd_flags = VER_FLG_BASE;
+      def.vd_ndx = 1;
+      def.vd_cnt = 1;
+      def.vd_aux = sizeof (coff_external_verdef);
+      def.vd_next = (sizeof (coff_external_verdef)
+		     + sizeof (coff_external_verdaux));
+
+      if (soname_indx != (bfd_size_type)-1)
+	{
+	  def.vd_hash = bfd_coff_hash ((const unsigned char *) soname);
+	  defaux.vda_name = soname_indx;
+	}
+      else
+	{
+	  const char *name;
+	  bfd_size_type indx;
+
+	  name = output_bfd->filename;
+	  def.vd_hash = bfd_coff_hash ((const unsigned char *) name);
+	  indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+					name, true, false);
+	  if (indx == (bfd_size_type) -1)
+	    return false;
+	  defaux.vda_name = indx;
+	}
+      defaux.vda_next = 0;
+
+      bfd_coff_swap_verdef_out (output_bfd, &def,
+				(coff_external_verdef *)p);
+      p += sizeof (coff_external_verdef);
+      bfd_coff_swap_verdaux_out (output_bfd, &defaux,
+				 (coff_external_verdaux *) p);
+      p += sizeof (coff_external_verdaux);
+
+      for (t = verdefs; t != NULL; t = t->next)
+	{
+	  unsigned int cdeps;
+	  struct bfd_elf_version_deps *n;
+	  struct coff_link_hash_entry *h;
+
+	  cdeps = 0;
+	  for (n = t->deps; n != NULL; n = n->next)
+	    ++cdeps;
+
+	  /* Add a symbol representing this version.  */
+	  h = NULL;
+	  if (! (bfd_coff_link_add_one_symbol
+		 (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,
+		  (bfd_vma) 0, (const char *) NULL, 
+		  false, false,
+		  (struct bfd_link_hash_entry **) &h)))
+	    return false;
+	  h->coff_link_hash_flags &= ~ COFF_LINK_NON_COFF;
+	  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+	  h->type = 0;
+
+	  h->verinfo.vertree = t;
+
+	  if (! _bfd_coff_link_record_dynamic_symbol (info, h))
+	    return false;
+
+	  def.vd_version = VER_DEF_CURRENT;
+	  def.vd_flags = 0;
+	  if (t->globals == NULL && t->locals == NULL && ! t->used)
+	    def.vd_flags |= VER_FLG_WEAK;
+	  def.vd_ndx = t->vernum + 1;
+	  def.vd_cnt = cdeps + 1;
+	  def.vd_hash = bfd_coff_hash ((const unsigned char *) t->name);
+	  def.vd_aux = sizeof (coff_external_verdef);
+	  if (t->next != NULL)
+	    def.vd_next = (sizeof (coff_external_verdef)
+			   + (cdeps + 1) * sizeof (coff_external_verdaux));
+	  else
+	    def.vd_next = 0;
+
+	  bfd_coff_swap_verdef_out (output_bfd, &def,
+				    (coff_external_verdef *) p);
+	  p += sizeof (coff_external_verdef);
+
+	  defaux.vda_name = h->dynstr_index;
+	  if (t->deps == NULL)
+	    defaux.vda_next = 0;
+	  else
+	    defaux.vda_next = sizeof (coff_external_verdaux);
+	  t->name_indx = defaux.vda_name;
+
+	  bfd_coff_swap_verdaux_out (output_bfd, &defaux,
+				     (coff_external_verdaux *) p);
+	  p += sizeof (coff_external_verdaux);
+
+	  for (n = t->deps; n != NULL; n = n->next)
+	    {
+	      defaux.vda_name = n->version_needed->name_indx;
+	      if (n->next == NULL)
+		defaux.vda_next = 0;
+	      else
+		defaux.vda_next = sizeof (coff_external_verdaux);
+
+	      bfd_coff_swap_verdaux_out (output_bfd, &defaux,
+					 (coff_external_verdaux *) p);
+	      p += sizeof (coff_external_verdaux);
+	    }
+	}
+
+      if (! coff_add_dynamic_entry (info, DT_VERDEF, 0)
+	  || ! coff_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))
+	return false;
+
+      dyn_data (output_bfd)->cverdefs = cdefs;
+    }
+
+  /* Work out the size of the version reference section.  */
+
+  verref_section = bfd_get_section_by_name (dynobj, ".gnu.version_r");
+  BFD_ASSERT (verref_section != NULL);
+  {
+    struct coff_find_verdep_info sinfo;
+
+    sinfo.output_bfd = output_bfd;
+    sinfo.info = info;
+    sinfo.vers = dyn_data (output_bfd)->cverdefs;
+    if (sinfo.vers == 0)
+      sinfo.vers = 1;
+    sinfo.failed = false;
+
+    coff_link_hash_traverse (coff_hash_table (info),
+			    coff_link_find_version_dependencies,
+			    (PTR) &sinfo);
+
+    if (dyn_data (output_bfd)->verref == NULL)
+      {
+	asection **spp;
+
+	/* We don't have any version definitions, so we can just
+	   remove the section.  */
+
+	for (spp = &output_bfd->sections;
+	     *spp != NULL;
+	     spp = &(*spp)->next)
+	  {
+	     if (*spp == verref_section->output_section)
+	       {
+		 *spp = verref_section->output_section->next;
+		 --output_bfd->section_count;
+		 break;
+	       }
+	  }
+      }
+    else
+      {
+	coff_internal_verneed *t;
+	unsigned int size;
+	unsigned int crefs;
+	bfd_byte *p;
+
+	/* Build the version definition section.  */
+	size = 0;
+	crefs = 0;
+	for (t = dyn_data (output_bfd)->verref;
+	     t != NULL;
+	     t = t->vn_nextref)
+	  {
+	    coff_internal_vernaux *a;
+
+	    size += sizeof (coff_external_verneed);
+	    ++crefs;
+	    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	      size += sizeof (coff_external_vernaux);
+	  }
+
+	verref_section->_raw_size = size;
+	verref_section->contents = (bfd_byte *) bfd_alloc (output_bfd, size);
+	if (verref_section->contents == NULL)
+	  return false;
+
+	p = verref_section->contents;
+	for (t = dyn_data (output_bfd)->verref;
+	     t != NULL;
+	     t = t->vn_nextref)
+	  {
+	    unsigned int caux;
+	    coff_internal_vernaux *a;
+	    bfd_size_type indx;
+
+	    caux = 0;
+	    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	      ++caux;
+
+	    t->vn_version = VER_NEED_CURRENT;
+	    t->vn_cnt = caux;
+	    indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+				       t->vn_bfd->filename, true, false);
+	    if (indx == (bfd_size_type) -1)
+	      return false;
+	    t->vn_file = indx;
+	    t->vn_aux = sizeof (coff_external_verneed);
+	    if (t->vn_nextref == NULL)
+	      t->vn_next = 0;
+	    else
+	      t->vn_next = (sizeof (coff_external_verneed)
+			    + caux * sizeof (coff_external_vernaux));
+
+	    bfd_coff_swap_verneed_out (output_bfd, t,
+				       (coff_external_verneed *) p);
+	    p += sizeof (coff_external_verneed);
+
+	    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	      {
+		a->vna_hash = bfd_coff_hash ((const unsigned char *)
+					    a->vna_nodename);
+		indx = _bfd_stringtab_add (coff_hash_table (info)->dynstr,
+					   a->vna_nodename, true, false);
+		if (indx == (bfd_size_type) -1)
+		  return false;
+		a->vna_name = indx;
+		if (a->vna_nextptr == NULL)
+		  a->vna_next = 0;
+		else
+		  a->vna_next = sizeof (coff_external_vernaux);
+
+		bfd_coff_swap_vernaux_out (output_bfd, a,
+					   (coff_external_vernaux *) p);
+		p += sizeof (coff_external_vernaux);
+	      }
+	  }
+
+	if (! coff_add_dynamic_entry (info, DT_VERNEED, 0)
+	    || ! coff_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))
+	  return false;
+
+	dyn_data (output_bfd)->cverrefs = crefs;
+      }
+  }
+
+  dynsymcount = coff_hash_table (info)->dynsymcount;
+  /* Work out the size of the symbol version section.  */
+  version_section = bfd_get_section_by_name (dynobj, ".gnu.version");
+  BFD_ASSERT (version_section != NULL);
+  if (dynsymcount == 0
+      || (verdefs == NULL && dyn_data (output_bfd)->verref == NULL))
+    {
+      asection **spp;
+
+      /* We don't need any symbol versions; just discard the
+	 section.  */
+      for (spp = &output_bfd->sections;
+	   *spp != NULL;
+	   spp = &(*spp)->next)
+	{
+	   if (*spp == version_section->output_section)
+	     {
+      		*spp = version_section->output_section->next;
+      		--output_bfd->section_count;
+		break;
+	     }
+	}
+    }
+  else
+    {
+      version_section->_raw_size = dynsymcount * sizeof (coff_external_versym);
+      version_section->contents = (bfd_byte *) bfd_zalloc (output_bfd, version_section->_raw_size);
+      if (version_section->contents == NULL)
+	return false;
+
+      if (! coff_add_dynamic_entry (info, DT_VERSYM, 0))
+	return false;
+    }
+  /* Set the size of the .dynsym and .hash sections.  We counted
+     the number of dynamic symbols in coff_link_add_object_symbols.
+     We will build the contents of .dynsym and .hash when we build
+     the final symbol table, because until then we do not know the
+     correct value to give the symbols.  We built the .dynstr
+     section as we went along in coff_link_add_object_symbols.  */
+  dynsym_section = bfd_get_section_by_name (dynobj, ".dynsym");
+  BFD_ASSERT (dynsym_section != NULL);
+  dynsym_section->_raw_size = dynsymcount * bfd_coff_symesz (output_bfd);
+  dynsym_section->contents = (bfd_byte *) bfd_alloc (output_bfd, dynsym_section->_raw_size);
+  if (dynsym_section->contents == NULL && dynsym_section->_raw_size != 0)
+    return false;
+
+  memset(&isym, 0, sizeof(isym));
+
+  bfd_coff_swap_sym_out (output_bfd, &isym,
+		       (PTR) (struct external_syment *) dynsym_section->contents);
+
+  for (i = 0; coff_buckets[i] != 0; i++)
+    {
+      bucketcount = coff_buckets[i];
+      if (dynsymcount < coff_buckets[i + 1])
+	break;
+    }
+
+  hash_section = bfd_get_section_by_name (dynobj, ".hash");
+  BFD_ASSERT (hash_section != NULL);
+  hash_section->_raw_size = (2 + bucketcount + dynsymcount) * (ARCH_SIZE / 8);
+  hash_section->contents = (bfd_byte *) bfd_alloc (output_bfd, hash_section->_raw_size);
+  if (hash_section->contents == NULL)
+    return false;
+
+  memset (hash_section->contents, 0, (size_t) hash_section->_raw_size);
+
+  bfd_h_put_32 (output_bfd, bucketcount, hash_section->contents);
+  bfd_h_put_32 (output_bfd, dynsymcount, hash_section->contents + (ARCH_SIZE / 8));
+
+  coff_hash_table (info)->bucketcount = bucketcount;
+
+  hash_section = bfd_get_section_by_name (dynobj, ".dynstr");
+  BFD_ASSERT (hash_section != NULL);
+  hash_section->_raw_size = _bfd_stringtab_size (coff_hash_table (info)->dynstr);
+
+  if (! coff_add_dynamic_entry (info, DT_NULL, 0))
+    return false;
+
+  return true;
+}
+
+boolean
+_bfd_coff_create_got_section (abfd, info, gotname, want_got_plt)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     char *gotname;
+     boolean want_got_plt;
+{
+  flagword flags;
+  register asection *s;
+  struct coff_link_hash_entry *h;
+
+  /* This function may be called more than once.  */
+  if (coff_hash_table (info)->sgot != NULL)
+    return true;
+
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
+	   | SEC_LINKER_CREATED | SEC_DATA );
+
+  s = bfd_make_section (abfd, ".got");
+  coff_hash_table (info)->sgot = s;
+  if (s == NULL
+      || !bfd_set_section_flags (abfd, s, flags)
+      || !bfd_set_section_alignment (abfd, s, 2))
+    return false;
+
+  if (want_got_plt)
+  {
+    s = bfd_make_section (abfd, ".got.plt");
+    coff_hash_table (info)->sgotplt = s;
+    if (s == NULL
+	|| !bfd_set_section_flags (abfd, s, flags)
+	|| !bfd_set_section_alignment (abfd, s, 2))
+      return false;
+
+      /* The first three global offset table entries are reserved (which 
+	 actually fall in .got.plt).  */
+      s->_raw_size += 3 * 4;
+
+  }
+
+  /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
+     (or .got.plt) section.  We don't do this in the linker script
+     because we don't want to define the symbol if we are not creating
+     a global offset table.   Since the spelling varies per architecture,
+     it's an argument. */
+  h = NULL;
+  if (!(bfd_coff_link_add_one_symbol
+	(info, abfd, gotname, BSF_GLOBAL, s, (bfd_vma) 0,
+	 (const char *) NULL, 
+	 false, false,
+	 (struct bfd_link_hash_entry **) &h)))
+    return false;
+  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+  h->type = 0;
+
+  if (info->shared
+      && ! _bfd_coff_link_record_dynamic_symbol (info, h))
+    return false;
+
+  coff_hash_table (info)->hgot = h;
+
+  return true;
+}
+
+
+
+
+/* Record a new dynamic symbol.  We record the dynamic symbols as we
+   read the input files, since we need to have a list of all of them
+   before we can determine the final sizes of the output sections.
+   Note that we may actually call this function even though we are not
+   going to output any dynamic symbols; in some cases we know that a
+   symbol should be in the dynamic symbol table, but only if there is
+   one.  */
+
+boolean
+_bfd_coff_link_record_dynamic_symbol (info, h)
+     struct bfd_link_info *info;
+     struct coff_link_hash_entry *h;
+{
+  struct bfd_strtab_hash *dynstr;
+  char *p, *alc;
+  const char *name;
+  boolean copy;
+  bfd_size_type indx;
+
+  /* Nothing to do, don't bother */
+  if (h->dynindx != -1)
+      return true;
+
+  /* We're skipping this one for some outside reason; skip it again */
+  if ((h->coff_link_hash_flags & COFF_LINK_FORCED_LOCAL) != 0)
+      return true;
+
+  if (info->strip == strip_some
+	&& bfd_hash_lookup (info->keep_hash,
+				h->root.root.string,
+				false, false) == NULL)
+  {
+     /* We've been asked to strip this symbol; if we can (and sometimes
+	we can't) we'll treat it as a local symbol.
+        If it's already defined locally, we'll simply not record it;
+	if it isn't defined, flag it for later analysis */
+     if ((h->coff_link_hash_flags & COFF_LINK_HASH_DEF_REGULAR) != 0 )
+       {
+          h->coff_link_hash_flags |= COFF_LINK_FORCED_LOCAL;
+          return true;
+       }
+     else 
+       {
+          h->coff_link_hash_flags |= COFF_LINK_MAYBE_FORCED_LOCAL;
+       }
+  }
+  
+  h->dynindx = coff_hash_table (info)->dynsymcount;
+  ++coff_hash_table (info)->dynsymcount;
+
+  /* If this is a PE weak symbol, we'll have to emit a weak alias AUX
+     entry, so leave space for it here. */
+  if (h->root.type == bfd_link_hash_indirect
+      && h->root.u.i.info.alias)
+    {
+      ++coff_hash_table (info)->dynsymcount;
+    }
+
+  dynstr = coff_hash_table (info)->dynstr;
+  if (dynstr == NULL)
+    {
+      /* Create a strtab to hold the dynamic symbol names.  */
+      coff_hash_table (info)->dynstr = dynstr = _bfd_coff_stringtab_init ();
+      if (dynstr == NULL)
+	return false;
+    }
+
+  /* We don't put any version information in the dynamic string
+     table.  */
+  name = h->root.root.string;
+  p = strchr (name, COFF_VER_CHR);
+  if (p == NULL)
+    {
+      alc = NULL;
+      copy = false;
+    }
+  else
+    {
+      alc = bfd_malloc (p - name + 1);
+      if (alc == NULL)
+	return false;
+      strncpy (alc, name, p - name);
+      alc[p - name] = '\0';
+      name = alc;
+      copy = true;
+    }
+
+  indx = _bfd_stringtab_add (dynstr, name, true, copy);
+
+  if (alc != NULL)
+    free (alc);
+
+  if (indx == (bfd_size_type) -1)
+    return false;
+  h->dynstr_index = indx;
+
+  return true;
+}
+
+/* Add an entry to the .dynamic table.  */
+
+boolean
+coff_add_dynamic_entry (info, tag, val)
+     struct bfd_link_info *info;
+     bfd_vma tag;
+     bfd_vma val;
+{
+  coff_internal_dyn dyn;
+  bfd *dynobj;
+  asection *s;
+  size_t newsize;
+  bfd_byte *newcontents;
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  s = coff_hash_table (info)->dynamic;
+
+  BFD_ASSERT (s != NULL);
+
+  newsize = s->_raw_size + sizeof (coff_external_dyn);
+  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
+  if (newcontents == NULL)
+    return false;
+
+  dyn.d_tag = tag;
+  dyn.d_un.d_val = val;
+  bfd_coff_swap_dyn_out (dynobj, &dyn,
+		    (coff_external_dyn *) (newcontents + s->_raw_size));
+
+  s->_raw_size = newsize;
+  s->contents = newcontents;
+
+  return true;
+}
+
+/* This is a hook for the emulation code in the generic linker to
+   tell the backend linker what file name to use for the DT_NEEDED
+   entry for a dynamic object.  The generic linker passes name as an
+   empty string to indicate that no DT_NEEDED entry should be made.  */
+
+void
+bfd_coff_set_dt_needed_name (abfd, name)
+     bfd *abfd;
+     const char *name;
+{
+  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour
+      && bfd_get_format (abfd) == bfd_object)
+    coff_dt_name (abfd) = name;
+}
+
+/* Get the list of DT_NEEDED entries for a link.  This is a hook for
+   the emulation code.  */
+
+struct bfd_link_needed_list *
+bfd_coff_get_needed_list (abfd, info)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+{
+  if (info->hash->creator->flavour != bfd_target_coff_flavour)
+    return NULL;
+  return coff_hash_table (info)->needed;
+}
+
+/* Get the name actually used for a dynamic object for a link.  This
+   is the SONAME entry if there is one.  Otherwise, it is the string
+   passed to bfd_coff_set_dt_needed_name, or it is the filename.  */
+
+const char *
+bfd_coff_get_dt_soname (abfd)
+     bfd *abfd;
+{
+  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour
+      && bfd_get_format (abfd) == bfd_object
+      && dyn_data(abfd) != NULL)
+    return coff_dt_name (abfd);
+  return NULL;
+}
+#endif /* ] */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/ecoff.c bfd/ecoff.c
--- bfd.pre.dynlink/ecoff.c	Wed Feb  6 10:10:03 2002
+++ bfd/ecoff.c	Wed Feb  6 10:11:27 2002
@@ -1471,11 +1471,12 @@ _bfd_ecoff_bfd_is_local_label_name (abfd
 /* Print information about an ECOFF symbol.  */
 
 void
-_bfd_ecoff_print_symbol (abfd, filep, symbol, how)
+_bfd_ecoff_print_symbol (abfd, filep, symbol, how, ignored)
      bfd *abfd;
      PTR filep;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   const struct ecoff_debug_swap * const debug_swap
     = &ecoff_backend (abfd)->debug_swap;
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/elf-bfd.h bfd/elf-bfd.h
--- bfd.pre.dynlink/elf-bfd.h	Wed Feb  6 10:10:03 2002
+++ bfd/elf-bfd.h	Wed Feb  6 12:54:11 2002
@@ -1152,7 +1152,7 @@ extern boolean _bfd_elf_copy_private_bfd
 extern boolean _bfd_elf_print_private_bfd_data
   PARAMS ((bfd *, PTR));
 extern void bfd_elf_print_symbol
-  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
+  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, asymbol *));
 
 #define elf_string_from_elf_strtab(abfd, strindex) \
   bfd_elf_string_from_elf_section(abfd, elf_elfheader(abfd)->e_shstrndx, \
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/elf.c bfd/elf.c
--- bfd.pre.dynlink/elf.c	Wed Feb  6 10:10:03 2002
+++ bfd/elf.c	Wed Feb  6 10:11:27 2002
@@ -1061,11 +1061,12 @@ _bfd_elf_print_private_bfd_data (abfd, f
 /* Display ELF-specific fields of a symbol.  */
 
 void
-bfd_elf_print_symbol (abfd, filep, symbol, how)
+bfd_elf_print_symbol (abfd, filep, symbol, how, ignored)
      bfd *abfd;
      PTR filep;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   FILE *file = (FILE *) filep;
   switch (how)
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/ieee.c bfd/ieee.c
--- bfd.pre.dynlink/ieee.c	Wed Feb  6 10:10:04 2002
+++ bfd/ieee.c	Wed Feb  6 12:55:13 2002
@@ -1751,11 +1751,12 @@ ieee_get_symbol_info (ignore_abfd, symbo
 }
 
 static void
-ieee_print_symbol (abfd, afile, symbol, how)
+ieee_print_symbol (ignore_abfd, afile, symbol, how, ignored)
      bfd *abfd;
      PTR afile;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   FILE *file = (FILE *) afile;
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/ihex.c bfd/ihex.c
--- bfd.pre.dynlink/ihex.c	Wed Feb  6 10:10:04 2002
+++ bfd/ihex.c	Wed Feb  6 10:11:27 2002
@@ -986,6 +986,7 @@ const bfd_target ihex_vec =
 {
   "ihex",			/* name */
   bfd_target_ihex_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* target byte order */
   BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
   0,				/* object flags */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/libbfd-in.h bfd/libbfd-in.h
--- bfd.pre.dynlink/libbfd-in.h	Wed Feb  6 10:10:04 2002
+++ bfd/libbfd-in.h	Wed Feb  6 10:11:27 2002
@@ -253,7 +253,8 @@ extern boolean _bfd_archive_coff_constru
   ((long (*) PARAMS ((bfd *, asymbol **))) _bfd_n1)
 #define _bfd_nosymbols_make_empty_symbol _bfd_generic_make_empty_symbol
 #define _bfd_nosymbols_print_symbol \
-  ((void (*) PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type))) bfd_void)
+  ((void (*) PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, \
+  asymbol *))) bfd_void)
 #define _bfd_nosymbols_get_symbol_info \
   ((void (*) PARAMS ((bfd *, asymbol *, symbol_info *))) bfd_void)
 #define _bfd_nosymbols_bfd_is_local_label_name \
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/libcoff-in.h bfd/libcoff-in.h
--- bfd.pre.dynlink/libcoff-in.h	Wed Feb  6 10:10:05 2002
+++ bfd/libcoff-in.h	Wed Feb  6 15:47:37 2002
@@ -22,6 +22,9 @@ Foundation, Inc., 59 Temple Place - Suit
 
 #include "bfdlink.h"
 
+#define DYNAMIC_LINKING /* Always defined, but useful as documentation. */
+#define USE_DLLS        /* Ditto */
+
 /* Object file tdata; access macros */
 
 #define coff_data(bfd)		((bfd)->tdata.coff_obj_data)
@@ -104,12 +107,17 @@ typedef struct coff_tdata
   /* The timestamp from the COFF file header.  */
   long timestamp;
 
+  /* list of sections (for quick access) */
+  asection **coff_sec;
+
   /* Copy of some of the f_flags bits in the COFF filehdr structure,
      used by ARM code.  */
   flagword flags;
 
 } coff_data_type;
 
+#define coff_coffsections(bfd)		((bfd)->tdata.coff_obj_data->coff_sec)
+
 /* Tdata for pe image files. */
 typedef struct pe_tdata
 {
@@ -239,6 +247,188 @@ struct pei_section_tdata
 #define pei_section_data(abfd, sec) \
   ((struct pei_section_tdata *) coff_section_data ((abfd), (sec))->tdata)
 
+#ifdef DYNAMIC_LINKING /* [ */
+/* Dynamic section tags */
+
+#define DT_NULL		0
+#define DT_NEEDED	1
+#define DT_PLTRELSZ	2
+#define DT_PLTGOT	3
+#define DT_HASH		4
+#define DT_STRTAB	5
+#define DT_SYMTAB	6
+#define DT_RELA		7
+#define DT_RELASZ	8
+#define DT_RELAENT	9
+#define DT_STRSZ	10
+#define DT_SYMENT	11
+#define DT_INIT		12
+#define DT_FINI		13
+#define DT_SONAME	14
+#define DT_RPATH	15
+#define DT_SYMBOLIC	16
+#define DT_REL		17
+#define DT_RELSZ	18
+#define DT_RELENT	19
+#define DT_PLTREL	20
+#define DT_DEBUG	21
+#define DT_TEXTREL	22
+#define DT_JMPREL	23
+
+/* The next four dynamic tags are used on Solaris.  We support them
+   everywhere.  */
+#define DT_VERDEF	0x6ffffffc
+#define DT_VERDEFNUM	0x6ffffffd
+#define DT_VERNEED	0x6ffffffe
+#define DT_VERNEEDNUM	0x6fffffff
+
+/* These section tags are used on Solaris.  We support them
+   everywhere, and hope they do not conflict.  */
+
+#define DT_AUXILIARY	0x7ffffffd
+#define DT_FILTER	0x7fffffff
+
+/* This tag is a GNU extension to the Solaris version scheme.  */
+#define DT_VERSYM	0x6ffffff0
+
+
+/* External structure definitions */
+typedef struct {
+  unsigned char	d_tag[4];		/* entry tag value */
+  union {
+    unsigned char	d_val[4];
+    unsigned char	d_ptr[4];
+  } d_un;
+} coff_external_dyn;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct {
+  unsigned char		vd_version[2];
+  unsigned char		vd_flags[2];
+  unsigned char		vd_ndx[2];
+  unsigned char		vd_cnt[2];
+  unsigned char		vd_hash[4];
+  unsigned char		vd_aux[4];
+  unsigned char		vd_next[4];
+} coff_external_verdef;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct {
+  unsigned char		vda_name[4];
+  unsigned char		vda_next[4];
+} coff_external_verdaux;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct {
+  unsigned char		vn_version[2];
+  unsigned char		vn_cnt[2];
+  unsigned char		vn_file[4];
+  unsigned char		vn_aux[4];
+  unsigned char		vn_next[4];
+} coff_external_verneed;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct {
+  unsigned char		vna_hash[4];
+  unsigned char		vna_flags[2];
+  unsigned char		vna_other[2];
+  unsigned char		vna_name[4];
+  unsigned char		vna_next[4];
+} coff_external_vernaux;
+
+/* This structure appears in a .gnu.version.r section. */
+
+typedef struct {
+  unsigned char		vs_vers[2];
+} coff_external_versym;
+
+/* Internal structure definitions */
+typedef struct coff_internal_dyn {
+  bfd_vma d_tag;		/* entry tag value */
+  union {
+    bfd_vma	d_val;
+    bfd_vma	d_ptr;
+  } d_un;
+} coff_internal_dyn;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct coff_internal_verdef {
+  unsigned short vd_version;	/* Version number of structure.  */
+  unsigned short vd_flags;	/* Flags (VER_FLG_*).  */
+  unsigned short vd_ndx;	/* Version index.  */
+  unsigned short vd_cnt;	/* Number of verdaux entries.  */
+  unsigned long	 vd_hash;	/* Hash of name.  */
+  unsigned long	 vd_aux;	/* Offset to verdaux entries.  */
+  unsigned long	 vd_next;	/* Offset to next verdef.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  bfd			       *vd_bfd;		/* BFD.  */
+  const char 		       *vd_nodename;	/* Version name.  */
+  struct coff_internal_verdef  *vd_nextdef;	/* vd_next as pointer.  */
+  struct coff_internal_verdaux *vd_auxptr;	/* vd_aux as pointer.  */
+  unsigned int		       vd_exp_refno;	/* Used by the linker.  */
+} coff_internal_verdef;
+
+/* This structure appears in a .gnu.version.d section.  */
+
+typedef struct coff_internal_verdaux {
+  unsigned long vda_name;	/* String table offset of name.  */
+  unsigned long vda_next;	/* Offset to next verdaux.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  const char *vda_nodename;			/* vda_name as pointer.  */
+  struct coff_internal_verdaux *vda_nextptr;	/* vda_next as pointer.  */
+} coff_internal_verdaux;
+ 
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct coff_internal_verneed {
+  unsigned short vn_version;	/* Version number of structure.  */
+  unsigned short vn_cnt;	/* Number of vernaux entries.  */
+  unsigned long	 vn_file;	/* String table offset of library name.  */
+  unsigned long	 vn_aux;	/* Offset to vernaux entries.  */
+  unsigned long	 vn_next;	/* Offset to next verneed.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  bfd			       *vn_bfd;		/* BFD.  */
+  const char                   *vn_filename;	/* vn_file as pointer.  */
+  struct coff_internal_vernaux *vn_auxptr;	/* vn_aux as pointer.  */
+  struct coff_internal_verneed *vn_nextref;	/* vn_nextref as pointer.  */
+} coff_internal_verneed;
+
+/* This structure appears in a .gnu.version.r section.  */
+
+typedef struct coff_internal_vernaux {
+  unsigned long	 vna_hash;	/* Hash of dependency name.  */
+  unsigned short vna_flags;	/* Flags (VER_FLG_*).  */
+  unsigned short vna_other;	/* Unused.  */
+  unsigned long	 vna_name;	/* String table offset to version name.  */
+  unsigned long	 vna_next;	/* Offset to next vernaux.  */
+
+  /* These fields are set up when BFD reads in the structure.  FIXME:
+     It would be cleaner to store these in a different structure.  */
+  const char                  *vna_nodename;	/* vna_name as pointer.  */
+  struct coff_internal_vernaux *vna_nextptr;	/* vna_next as pointer.  */
+} coff_internal_vernaux;
+
+/* This structure appears in a .gnu.version.r section. */
+
+typedef struct coff_internal_versym {
+  unsigned short vs_vers;
+} coff_internal_versym;
+
+#define LOADER_NAME "/usr/lib/ld.so"
+
+#endif /* DYNAMIC_LINKING */ /* ] */
+
 /* COFF linker hash table entries.  */
 
 struct coff_link_hash_entry
@@ -267,7 +457,101 @@ struct coff_link_hash_entry
   /* Flag word; legal values follow.  */
   unsigned short coff_link_hash_flags;
   /* Symbol is a PE section symbol.  */
-#define COFF_LINK_HASH_PE_SECTION_SYMBOL (01)
+#define COFF_LINK_HASH_PE_SECTION_SYMBOL 0x8000
+#ifdef DYNAMIC_LINKING /* [ */
+  /* More flag word values: */
+  /* Symbol is referenced by a non-shared object.  */
+#define COFF_LINK_HASH_REF_REGULAR	0x1
+  /* Symbol is defined by a non-shared object.  */
+#define COFF_LINK_HASH_DEF_REGULAR	0x2
+  /* Symbol is referenced by a shared object.  */
+#define COFF_LINK_HASH_REF_DYNAMIC	0x4
+  /* Symbol is defined by a shared object.  */
+#define COFF_LINK_HASH_DEF_DYNAMIC	0x8
+  /* Dynamic symbol has been adjustd.  */
+#define COFF_LINK_HASH_DYNAMIC_ADJUSTED 0x10
+  /* Symbol needs a copy reloc.  */
+#define COFF_LINK_HASH_NEEDS_COPY	0x20
+  /* Symbol needs a procedure linkage table entry.  */
+#define COFF_LINK_HASH_NEEDS_PLT	0x40
+  /* Symbol appears in a non-COFF input file.  */
+#define COFF_LINK_NON_COFF		0x80
+  /* Symbol should be marked as hidden in the version information.  */
+#define COFF_LINK_HIDDEN		0x100
+  /* Symbol was forced to local scope due to a version script file.  */
+#define COFF_LINK_FORCED_LOCAL		0x200
+  /* We'd like to force this local (via --retain-symbols-file), but don't 
+     know if we can, yet. */
+#define COFF_LINK_MAYBE_FORCED_LOCAL	0x400
+  /* Symbol (subsequently, mostly) found in a DLL library. */
+#define COFF_LINK_HASH_DLL_DEFINED	0x800
+  /* Dynsym has been renumbered.  Set exactly once on all renumbered ents. */
+#define COFF_LINK_HASH_RENUMBERED	0x1000
+  /* Dynsym has been emitted.  Set exactly once on all ents. */
+#define COFF_LINK_HASH_EMITTED                0x2000
+
+#ifdef USE_SIZE
+  /* Symbol size.  */
+  bfd_size_type size;
+#endif
+
+  /* Symbol index as a dynamic symbol.  Initialized to -1, and remains
+     -1 if this is not a dynamic symbol.  */
+  long dynindx;
+
+  /* String table index in .dynstr if this is a dynamic symbol.  */
+  unsigned long dynstr_index;
+
+#ifdef USE_WEAK
+  /* If this is a weak defined symbol from a dynamic object, this
+     field points to a defined symbol with the same value, if there is
+     one.  Otherwise it is NULL.  */
+  struct coff_link_hash_entry *weakdef;
+#endif
+
+  /* If this symbol requires an entry in the global offset table, the
+     processor specific backend uses this field to hold the offset
+     into the .got section.  If this field is -1, then the symbol does
+     not require a global offset table entry.  */
+  bfd_vma got_offset;
+
+  /* If this symbol requires an entry in the procedure linkage table,
+     the processor specific backend uses these two fields to hold the
+     offset into the procedure linkage section and the offset into the
+     .got section.  If plt_offset is -1, then the symbol does not
+     require an entry in the procedure linkage table.  */
+  bfd_vma plt_offset;
+
+  /* The number of DIR32 (etc.) relocation entries for this symbol;
+     used to allocate space in .rel.dyn section.  When linking
+     without COPY relocs, we otherwise would badly overestimate,
+     and it helps a little even for shared.  */
+  int num_long_relocs_needed;
+
+  /* Similarly; under some circumstances we can't know whether relative
+     relocs will be needed when counting, so we count them separately,
+     and apply once we do know. */
+  int num_relative_relocs_needed;
+
+  /* Version information.  */
+  union
+  {
+    /* This field is used for a symbol which is not defined in a
+       regular object.  It points to the version information read in
+       from the dynamic object.  */
+    coff_internal_verdef *verdef;
+
+    /* This field is used for a symbol which is defined in a regular
+       object.  It is set up in size_dynamic_sections.  It points to
+       the version information we should write out for this symbol.
+
+       Since it's already "global" (including in ld) as "elf_version_tree",
+       we'll leave it as "elf", even though it now applies to PE/COFF, too.
+       (Definition in bfdlink.h) */
+    struct bfd_elf_version_tree *vertree;
+
+  } verinfo;
+#endif /* ] */
 };
 
 /* COFF linker hash table.  */
@@ -277,6 +561,47 @@ struct coff_link_hash_table
   struct bfd_link_hash_table root;
   /* A pointer to information used to link stabs in sections.  */
   PTR stab_info;
+
+#ifdef DYNAMIC_LINKING /* [ */
+  /* Whether we have created the special dynamic sections required
+     when linking against or generating a shared object.  */
+  boolean dynamic_sections_created;
+
+  /* The BFD used to hold special sections created by the linker.
+     This will be the first BFD found which requires these sections to
+     be created.  */
+  bfd *dynobj;
+
+  /* The number of symbols found in the link which must be put into
+     the .dynsym section.  */
+  bfd_size_type dynsymcount;
+
+  /* The string table of dynamic symbols, which becomes the .dynstr
+     section.  */
+  struct bfd_strtab_hash *dynstr;
+
+  /* The number of buckets in the hash table in the .hash section.
+     This is based on the number of dynamic symbols.  */
+  bfd_size_type bucketcount;
+
+  /* A linked list of DT_NEEDED names found in dynamic objects
+     included in the link.  */
+  struct bfd_link_needed_list *needed;
+
+  /* The _GLOBAL_OFFSET_TABLE_ symbol.  */
+  struct coff_link_hash_entry *hgot;
+
+  /* Certain dynamic sections which are frequently accessed, to skip
+     by-name lookup. (Apply to special cases hosted dynobj.) */
+  asection *sreloc;		/* .rel.internal */
+  asection *dynamic;		/* .dynamic */
+  asection *sgot;		/* .got */
+  asection *srelgot;		/* .rel.got */
+  asection *splt;		/* .plt */
+  asection *srelplt;		/* .rel.plt */
+  asection *sgotplt;		/* .rel.plt */
+
+#endif /* ] */
 };
 
 /* Look up an entry in a COFF linker hash table.  */
@@ -336,7 +661,7 @@ extern long coff_get_reloc_upper_bound
 extern asymbol *coff_make_empty_symbol
   PARAMS ((bfd *));
 extern void coff_print_symbol
-  PARAMS ((bfd *, PTR filep, asymbol *, bfd_print_symbol_type));
+  PARAMS ((bfd *, PTR filep, asymbol *, bfd_print_symbol_type, asymbol *));
 extern void coff_get_symbol_info
   PARAMS ((bfd *, asymbol *, symbol_info *ret));
 extern boolean _bfd_coff_is_local_label_name
@@ -493,6 +818,17 @@ struct coff_final_link_info
   bfd_byte *external_relocs;
   /* Buffer large enough to hold swapped relocs of any input section.  */
   struct internal_reloc *internal_relocs;
+
+#ifdef DYNAMIC_LINKING
+  /* .dynsym section.  */
+  asection *dynsym_sec;
+
+  /* .hash section.  */
+  asection *hash_sec;
+
+  /* symbol version section (.gnu.version).  */
+  asection *symver_sec;
+#endif
 };
 
 /* Most COFF variants have no way to record the alignment of a
@@ -595,6 +931,124 @@ extern boolean ppc_allocate_toc_section
   PARAMS ((struct bfd_link_info *));
 extern boolean ppc_process_before_allocation
   PARAMS ((bfd *, struct bfd_link_info *));
+
+#ifdef DYNAMIC_LINKING /* [ */
+/* in coffgen.c */
+long coff_get_dynamic_symtab_upper_bound PARAMS((bfd *));
+long coff_canonicalize_dynamic_symtab PARAMS((bfd *, asymbol **));
+long coff_get_dynamic_reloc_upper_bound PARAMS((bfd *));
+struct bfd_strtab_hash * _bfd_coff_stringtab_init PARAMS((void));
+char * bfd_coff_get_str_section PARAMS((bfd *, unsigned int));
+char * bfd_coff_string_from_coff_section 
+    PARAMS((bfd *, unsigned int, unsigned int));
+boolean _bfd_coff_slurp_version_tables PARAMS((bfd *abfd));
+
+/* in cofflink.c */
+boolean _bfd_coff_link_record_dynamic_symbol 
+    PARAMS((struct bfd_link_info *, struct coff_link_hash_entry *h));
+boolean coff_add_dynamic_entry 
+    PARAMS((struct bfd_link_info *, bfd_vma, bfd_vma));
+void bfd_coff_set_dt_needed_name PARAMS((bfd *, const char *));
+struct bfd_link_needed_list * bfd_coff_get_needed_list 
+    PARAMS((bfd *, struct bfd_link_info *));
+const char * bfd_coff_get_dt_soname PARAMS((bfd *));
+boolean _bfd_coff_create_got_section 
+    PARAMS((bfd *, struct bfd_link_info *, char *, boolean));
+
+#define dyn_data(bfd) ((bfd)->dynamic_info)
+
+#define coff_local_got_offsets(bfd) ((bfd) -> local_got_offsets)
+#define coff_dynsymtab(bfd)   (dyn_data(bfd) -> dynsymtab)
+#define coff_dynstrtab(bfd)   (dyn_data(bfd) -> dynstrtab)
+#define coff_dynverdef(bfd)   (dyn_data(bfd) -> dynverdef)
+#define coff_dynverref(bfd)   (dyn_data(bfd) -> dynverref)
+#define coff_dynversym(bfd)   (dyn_data(bfd) -> dynversym)
+#define coff_dynamic(bfd)     (dyn_data(bfd) -> dynamic)
+#define coff_dt_name(bfd)     (dyn_data(bfd) -> dt_name)
+
+
+/* A cache of additional information if dynamic linking is actually
+   happening. */
+struct dynamic_info
+{
+  /* The "standard" secttions, where they're easy and quick to find */
+  asection *dynsymtab;
+  asection *dynstrtab;
+  asection *dynverdef;
+  asection *dynverref;
+  asection *dynversym;
+  asection *dynamic;
+
+  /* Number of symbol version definitions we are about to emit.  */
+  unsigned int cverdefs;
+
+  /* Number of symbol version references we are about to emit.  */
+  unsigned int cverrefs;
+
+  /* Symbol version definitions in external objects.  */
+  coff_internal_verdef *verdef;
+
+  /* Symbol version references to external objects.  */
+  coff_internal_verneed *verref;
+
+  /* A mapping from local symbols to offsets into the global offset
+     table, used when linking.  This is indexed by the symbol index.  */
+  bfd_vma *local_got_offsets;
+
+  /* The front end needs to let the back end know
+     what filename should be used for a dynamic object if the
+     dynamic object is found using a search.  The front end then
+     sometimes needs to know what name was actually used.  Until the
+     file has been added to the linker symbol table, this field holds
+     the name the linker wants.  After it has been added, it holds the
+     name actually used, which will be the DT_SONAME entry if there is
+     one.  */
+  const char *dt_name;
+
+};
+
+/* These constants are used for the version number of a Verdef structure.  */
+
+#define VER_DEF_NONE		0
+#define VER_DEF_CURRENT		1
+
+/* These constants appear in the vd_flags field of a Verdef structure.  */
+
+#define VER_FLG_BASE		0x1
+#define VER_FLG_WEAK		0x2
+
+/* These special constants can be found in an Versym field.  */
+
+#define VER_NDX_LOCAL		0
+#define VER_NDX_GLOBAL		1
+
+/* These constants are used for the version number of a Verneed structure.  */
+
+#define VER_NEED_NONE		0
+#define VER_NEED_CURRENT	1
+
+/* This flag appears in a Versym structure.  It means that the symbol
+   is hidden, and is only visible with an explicit version number.
+   This is a GNU extension.  */
+
+#define VERSYM_HIDDEN		0x8000
+
+/* This is the mask for the rest of the Versym information.  */
+
+#define VERSYM_VERSION		0x7fff
+
+/* This is a special token which appears as part of a symbol name.  It
+   indictes that the rest of the name is actually the name of a
+   version node, and is not part of the actual name.  This is a GNU
+   extension.  For example, the symbol name `stat%ver2' is taken to
+   mean the symbol `stat' in version `ver2'.  The historical use
+   of "@" doesn't work in PE, because @ is used by the Microsoft
+   tools. */
+#define COFF_VER_CHR '%'
+
+#define ARCH_SIZE 32   /* someday it might be 64 */
+
+#endif /* ] */
 
 /* And more taken from the source .. */
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/libecoff.h bfd/libecoff.h
--- bfd.pre.dynlink/libecoff.h	Wed Feb  6 10:10:05 2002
+++ bfd/libecoff.h	Wed Feb  6 10:11:27 2002
@@ -301,7 +301,7 @@ extern long _bfd_ecoff_get_symtab_upper_
 extern long _bfd_ecoff_get_symtab PARAMS ((bfd *abfd, asymbol **alocation));
 extern asymbol *_bfd_ecoff_make_empty_symbol PARAMS ((bfd *abfd));
 extern void _bfd_ecoff_print_symbol
-  PARAMS ((bfd *, PTR filep, asymbol *, bfd_print_symbol_type));
+  PARAMS ((bfd *, PTR filep, asymbol *, bfd_print_symbol_type, asymbol *));
 extern void _bfd_ecoff_get_symbol_info
   PARAMS ((bfd *, asymbol *, symbol_info *));
 extern boolean _bfd_ecoff_bfd_is_local_label_name
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/libpei.h bfd/libpei.h
--- bfd.pre.dynlink/libpei.h	Wed Feb  6 10:10:05 2002
+++ bfd/libpei.h	Wed Feb  6 15:48:46 2002
@@ -322,6 +322,62 @@ void _bfd_XX_get_symbol_info PARAMS ((bf
 boolean _bfd_XXi_final_link_postscript
   PARAMS ((bfd *, struct coff_final_link_info *));
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+void pei_swap_dyn_out 
+    PARAMS((bfd *, const coff_internal_dyn *, coff_external_dyn *));
+#define coff_swap_dyn_out pei_swap_dyn_out
+
+void pei_swap_dyn_in PARAMS((bfd *, const PTR, coff_internal_dyn *));
+#define coff_swap_dyn_in pei_swap_dyn_in
+
+void pei_swap_verdef_in 
+    PARAMS((bfd *, const coff_external_verdef *, coff_internal_verdef *));
+#define coff_swap_verdef_in  pei_swap_verdef_in
+
+void pei_swap_verdef_out 
+    PARAMS((bfd *, const coff_internal_verdef *, coff_external_verdef *));
+#define coff_swap_verdef_out pei_swap_verdef_out 
+
+void pei_swap_verdaux_in 
+    PARAMS((bfd *, const coff_external_verdaux *, coff_internal_verdaux *));
+#define coff_swap_verdaux_in pei_swap_verdaux_in 
+
+void pei_swap_verdaux_out 
+    PARAMS((bfd *, const coff_internal_verdaux *, coff_external_verdaux *));
+#define coff_swap_verdaux_out pei_swap_verdaux_out 
+
+void pei_swap_verneed_in 
+    PARAMS((bfd *, const coff_external_verneed *, coff_internal_verneed *));
+#define coff_swap_verneed_in pei_swap_verneed_in 
+
+void pei_swap_verneed_out 
+    PARAMS((bfd *, const coff_internal_verneed *, coff_external_verneed *));
+#define coff_swap_verneed_out pei_swap_verneed_out 
+
+void pei_swap_vernaux_in 
+    PARAMS((bfd *, const coff_external_vernaux *, coff_internal_vernaux *));
+#define coff_swap_vernaux_in pei_swap_vernaux_in 
+
+void pei_swap_vernaux_out 
+    PARAMS((bfd *, const coff_internal_vernaux *, coff_external_vernaux *));
+#define coff_swap_vernaux_out pei_swap_vernaux_out 
+
+void pei_swap_versym_in 
+    PARAMS((bfd *, const coff_external_versym *, coff_internal_versym *));
+#define coff_swap_versym_in pei_swap_versym_in 
+
+void pei_swap_versym_out 
+    PARAMS((bfd *, const coff_internal_versym *, coff_external_versym *));
+#define coff_swap_versym_out pei_swap_versym_out 
+
+/* The #defines for below appear elsewhere. */
+boolean pei_generic_size_dynamic_sections 
+   PARAMS((bfd *, struct bfd_link_info *));
+
+#endif /* ] */
+
+
 #ifndef coff_final_link_postscript
 #define coff_final_link_postscript _bfd_XXi_final_link_postscript
 #endif
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/linker.c bfd/linker.c
--- bfd.pre.dynlink/linker.c	Wed Feb  6 10:10:05 2002
+++ bfd/linker.c	Wed Feb  6 10:11:27 2002
@@ -1397,7 +1397,8 @@ enum link_row
   COMMON_ROW,		/* Common.  */
   INDR_ROW,		/* Indirect.  */
   WARN_ROW,		/* Warning.  */
-  SET_ROW		/* Member of set.  */
+  SET_ROW,		/* Member of set.  */
+  ALIAS_ROW,		/* Weak alias.  */
 };
 
 /* apparently needed for Hitachi 3050R(HI-UX/WE2)? */
@@ -1434,8 +1435,8 @@ enum link_action
 /* The state table itself.  The first index is a link_row and the
    second index is a bfd_link_hash_type.  */
 
-static const enum link_action link_action[8][8] =
-{
+static const enum link_action link_action[9][8] =
+{
   /* current\prev    new    undef  undefw def    defw   com    indr   warn  */
   /* UNDEF_ROW 	*/  {UND,   NOACT, UND,   REF,   REF,   NOACT, REFC,  WARNC },
   /* UNDEFW_ROW	*/  {WEAK,  NOACT, NOACT, REF,   REF,   NOACT, REFC,  WARNC },
@@ -1444,7 +1445,8 @@ static const enum link_action link_actio
   /* COMMON_ROW	*/  {COM,   COM,   COM,   CREF,  COM,   BIG,   REFC,  WARNC },
   /* INDR_ROW	*/  {IND,   IND,   IND,   MDEF,  IND,   CIND,  MIND,  CYCLE },
   /* WARN_ROW   */  {MWARN, WARN,  WARN,  CWARN, CWARN, WARN,  CWARN, NOACT },
-  /* SET_ROW	*/  {SET,   SET,   SET,   SET,   SET,   SET,   CYCLE, CYCLE }
+  /* SET_ROW	*/  {SET,   SET,   SET,   SET,   SET,   SET,   CYCLE, CYCLE },
+  /* ALIAS_ROW 	*/  {IND,   IND,   IND,   NOACT, NOACT, NOACT, NOACT, CYCLE },
 };
 
 /* Most of the entries in the LINK_ACTION table are straightforward,
@@ -1529,10 +1531,17 @@ _bfd_generic_link_add_one_symbol (info, 
   enum link_row row;
   struct bfd_link_hash_entry *h;
   boolean cycle;
-
+  enum bfd_link_hash_type active_old_sym_type;
+
   if (bfd_is_ind_section (section)
       || (flags & BSF_INDIRECT) != 0)
-    row = INDR_ROW;
+    {
+      /* Check for a weak alias */
+      if ((flags & BSF_WEAK) != 0)
+	row = ALIAS_ROW;
+      else
+	row = INDR_ROW;
+    }
   else if ((flags & BSF_WARNING) != 0)
     row = WARN_ROW;
   else if ((flags & BSF_CONSTRUCTOR) != 0)
@@ -1580,12 +1589,21 @@ _bfd_generic_link_add_one_symbol (info, 
   if (hashp != (struct bfd_link_hash_entry **) NULL)
     *hashp = h;
 
+  /* Allow the symbol type for the old symbol to be changed for search
+     without actually having to change it. */
+  active_old_sym_type = h->type;
+
+  /* If it's an alias, pretend it's a weak def. */
+  if (active_old_sym_type == bfd_link_hash_indirect
+      && h->u.i.info.alias)
+    active_old_sym_type = bfd_link_hash_defweak;
+
   do
     {
       enum link_action action;
 
       cycle = false;
-      action = link_action[(int) row][(int) h->type];
+      action = link_action[(int) row][(int) active_old_sym_type];
       switch (action)
 	{
 	case FAIL:
@@ -1893,6 +1911,7 @@ _bfd_generic_link_add_one_symbol (info, 
 
 	    h->type = bfd_link_hash_indirect;
 	    h->u.i.link = inh;
+	    h->u.i.info.alias = (flags & BSF_WEAK) != 0;
 	  }
 	  break;
 
@@ -1905,15 +1924,15 @@ _bfd_generic_link_add_one_symbol (info, 
 
 	case WARNC:
 	  /* Issue a warning and cycle.  */
-	  if (h->u.i.warning != NULL)
+	  if (h->u.i.info.warning != NULL)
 	    {
-	      if (! (*info->callbacks->warning) (info, h->u.i.warning,
+	      if (! (*info->callbacks->warning) (info, h->u.i.info.warning,
 						 h->root.string, abfd,
 						 (asection *) NULL,
 						 (bfd_vma) 0))
 		return false;
 	      /* Only issue a warning once.  */
-	      h->u.i.warning = NULL;
+	      h->u.i.info.warning = NULL;
 	    }
 	  /* Fall through.  */
 	case CYCLE:
@@ -1970,7 +1989,7 @@ _bfd_generic_link_add_one_symbol (info, 
 	    sub->type = bfd_link_hash_warning;
 	    sub->u.i.link = h;
 	    if (! copy)
-	      sub->u.i.warning = string;
+	      sub->u.i.info.warning = string;
 	    else
 	      {
 		char *w;
@@ -1980,7 +1999,7 @@ _bfd_generic_link_add_one_symbol (info, 
 		if (w == NULL)
 		  return false;
 		memcpy (w, string, len);
-		sub->u.i.warning = w;
+		sub->u.i.info.warning = w;
 	      }
 
 	    bfd_hash_replace (&info->hash->table,
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/mmo.c bfd/mmo.c
--- bfd.pre.dynlink/mmo.c	Wed Feb  6 10:10:05 2002
+++ bfd/mmo.c	Wed Feb  6 16:27:08 2002
@@ -360,7 +360,7 @@ static void mmo_find_sec_w_addr_grow PAR
 static asection *mmo_make_section PARAMS ((bfd *, CONST char *));
 static void mmo_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
 static void mmo_print_symbol
- PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
+ PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, asymbol*));
 static void mmo_init PARAMS ((void));
 static boolean mmo_mkobject PARAMS ((bfd *));
 static boolean mmo_scan PARAMS ((bfd *));
@@ -2192,12 +2192,13 @@ mmo_get_symbol_info (ignore_abfd, symbol
      bfd *ignore_abfd ATTRIBUTE_UNUSED;
      asymbol *symbol;
      symbol_info *ret;
-{
+     asymbol *ignored ATTRIBUTE_UNUSED;
+{
   bfd_symbol_info (symbol, ret);
 }
 
 static void
-mmo_print_symbol (abfd, afile, symbol, how)
+mmo_print_symbol (abfd, afile, symbol, how, ignored)
      bfd *abfd;
      PTR afile;
      asymbol *symbol;
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/nlmcode.h bfd/nlmcode.h
--- bfd.pre.dynlink/nlmcode.h	Wed Feb  6 10:10:05 2002
+++ bfd/nlmcode.h	Wed Feb  6 13:15:10 2002
@@ -977,11 +977,12 @@ nlm_get_symbol_info (ignore_abfd, symbol
 /* Print symbol information.  */
 
 void
-nlm_print_symbol (abfd, afile, symbol, how)
+nlm_print_symbol (abfd, afile, symbol, how, ignored)
      bfd *abfd;
      PTR afile;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   FILE *file = (FILE *) afile;
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/oasys.c bfd/oasys.c
--- bfd.pre.dynlink/oasys.c	Wed Feb  6 10:10:05 2002
+++ bfd/oasys.c	Wed Feb  6 16:27:55 2002
@@ -44,7 +44,7 @@ static boolean oasys_mkobject PARAMS ((b
 static const bfd_target *oasys_object_p PARAMS ((bfd *));
 static void oasys_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
 static void oasys_print_symbol
-  PARAMS ((bfd *, void *, asymbol *, bfd_print_symbol_type));
+  PARAMS ((bfd *, void *, asymbol *, bfd_print_symbol_type, asymbol *));
 static boolean oasys_new_section_hook PARAMS ((bfd *, asection *));
 static long int oasys_get_reloc_upper_bound PARAMS ((bfd *, sec_ptr));
 static boolean oasys_get_section_contents
@@ -543,11 +543,12 @@ oasys_get_symbol_info (ignore_abfd, symb
 }
 
 static void
-oasys_print_symbol (abfd, afile, symbol, how)
+oasys_print_symbol (ignore_abfd, afile, symbol, how, ignored)
      bfd *abfd;
      PTR afile;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   FILE *file = (FILE *) afile;
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/pdp11.c bfd/pdp11.c
--- bfd.pre.dynlink/pdp11.c	Wed Feb  6 10:10:05 2002
+++ bfd/pdp11.c	Wed Feb  6 13:15:32 2002
@@ -2473,11 +2473,12 @@ NAME(aout,get_symbol_info) (abfd, symbol
 
 /*ARGSUSED*/
 void
-NAME(aout,print_symbol) (abfd, afile, symbol, how)
+NAME(aout,print_symbol) (abfd, afile, symbol, how, ignored)
      bfd * abfd;
      PTR afile;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   FILE *file = (FILE *)afile;
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/peXXigen.c bfd/peXXigen.c
--- bfd.pre.dynlink/peXXigen.c	Wed Feb  6 10:10:05 2002
+++ bfd/peXXigen.c	Wed Feb  6 12:58:48 2002
@@ -362,6 +362,14 @@ _bfd_XXi_swap_aux_out (abfd, inp, type, 
 	  return AUXESZ;
 	}
       break;
+  case C_NT_WEAK:
+    bfd_h_put_32(abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
+    /* --- MAKE MORE PORTABLE or del below */
+    BFD_ASSERT (in->x_sym.x_misc.x_fsize == 3);
+    bfd_h_put_32 (abfd, in->x_sym.x_misc.x_fsize,
+	     (bfd_byte *)  ext->x_sym.x_misc.x_fsize);
+    return AUXESZ;
+    
     }
 
   H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->x_sym.x_tagndx);
@@ -940,6 +948,171 @@ _bfd_XXi_swap_scnhdr_out (abfd, in, out)
   return ret;
 }
 
+#ifdef DYNAMIC_LINKING /* [ */
+void
+pei_swap_dyn_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_dyn *src;
+     coff_external_dyn *dst;
+{
+  bfd_h_put_32 (abfd, src->d_tag, dst->d_tag);
+  bfd_h_put_32 (abfd, src->d_un.d_val, dst->d_un.d_val);
+}
+
+void
+pei_swap_dyn_in (abfd, p, dst)
+     bfd *abfd;
+     const PTR p;
+     coff_internal_dyn *dst;
+{
+  const coff_external_dyn *src = (const coff_external_dyn *) p;
+
+  dst->d_tag = bfd_h_get_32 (abfd, src->d_tag);
+  dst->d_un.d_val = bfd_h_get_32 (abfd, src->d_un.d_val);
+}
+
+/* Swap in a Verdef structure.  */
+
+void
+pei_swap_verdef_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_verdef *src;
+     coff_internal_verdef *dst;
+{
+  dst->vd_version = bfd_h_get_16 (abfd, src->vd_version);
+  dst->vd_flags   = bfd_h_get_16 (abfd, src->vd_flags);
+  dst->vd_ndx     = bfd_h_get_16 (abfd, src->vd_ndx);
+  dst->vd_cnt     = bfd_h_get_16 (abfd, src->vd_cnt);
+  dst->vd_hash    = bfd_h_get_32 (abfd, src->vd_hash);
+  dst->vd_aux     = bfd_h_get_32 (abfd, src->vd_aux);
+  dst->vd_next    = bfd_h_get_32 (abfd, src->vd_next);
+}
+
+/* Swap out a Verdef structure.  */
+
+void
+pei_swap_verdef_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_verdef *src;
+     coff_external_verdef *dst;
+{
+  bfd_h_put_16 (abfd, src->vd_version, dst->vd_version);
+  bfd_h_put_16 (abfd, src->vd_flags, dst->vd_flags);
+  bfd_h_put_16 (abfd, src->vd_ndx, dst->vd_ndx);
+  bfd_h_put_16 (abfd, src->vd_cnt, dst->vd_cnt);
+  bfd_h_put_32 (abfd, src->vd_hash, dst->vd_hash);
+  bfd_h_put_32 (abfd, src->vd_aux, dst->vd_aux);
+  bfd_h_put_32 (abfd, src->vd_next, dst->vd_next);
+}
+
+/* Swap in a Verdaux structure.  */
+
+void
+pei_swap_verdaux_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_verdaux *src;
+     coff_internal_verdaux *dst;
+{
+  dst->vda_name = bfd_h_get_32 (abfd, src->vda_name);
+  dst->vda_next = bfd_h_get_32 (abfd, src->vda_next);
+}
+
+/* Swap out a Verdaux structure.  */
+
+void
+pei_swap_verdaux_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_verdaux *src;
+     coff_external_verdaux *dst;
+{
+  bfd_h_put_32 (abfd, src->vda_name, dst->vda_name);
+  bfd_h_put_32 (abfd, src->vda_next, dst->vda_next);
+}
+
+/* Swap in a Verneed structure.  */
+
+void
+pei_swap_verneed_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_verneed *src;
+     coff_internal_verneed *dst;
+{
+  dst->vn_version = bfd_h_get_16 (abfd, src->vn_version);
+  dst->vn_cnt     = bfd_h_get_16 (abfd, src->vn_cnt);
+  dst->vn_file    = bfd_h_get_32 (abfd, src->vn_file);
+  dst->vn_aux     = bfd_h_get_32 (abfd, src->vn_aux);
+  dst->vn_next    = bfd_h_get_32 (abfd, src->vn_next);
+}
+
+/* Swap out a Verneed structure.  */
+
+void
+pei_swap_verneed_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_verneed *src;
+     coff_external_verneed *dst;
+{
+  bfd_h_put_16 (abfd, src->vn_version, dst->vn_version);
+  bfd_h_put_16 (abfd, src->vn_cnt, dst->vn_cnt);
+  bfd_h_put_32 (abfd, src->vn_file, dst->vn_file);
+  bfd_h_put_32 (abfd, src->vn_aux, dst->vn_aux);
+  bfd_h_put_32 (abfd, src->vn_next, dst->vn_next);
+}
+
+/* Swap in a Vernaux structure.  */
+
+void
+pei_swap_vernaux_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_vernaux *src;
+     coff_internal_vernaux *dst;
+{
+  dst->vna_hash  = bfd_h_get_32 (abfd, src->vna_hash);
+  dst->vna_flags = bfd_h_get_16 (abfd, src->vna_flags);
+  dst->vna_other = bfd_h_get_16 (abfd, src->vna_other);
+  dst->vna_name  = bfd_h_get_32 (abfd, src->vna_name);
+  dst->vna_next  = bfd_h_get_32 (abfd, src->vna_next);
+}
+
+/* Swap out a Vernaux structure.  */
+
+void
+pei_swap_vernaux_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_vernaux *src;
+     coff_external_vernaux *dst;
+{
+  bfd_h_put_32 (abfd, src->vna_hash, dst->vna_hash);
+  bfd_h_put_16 (abfd, src->vna_flags, dst->vna_flags);
+  bfd_h_put_16 (abfd, src->vna_other, dst->vna_other);
+  bfd_h_put_32 (abfd, src->vna_name, dst->vna_name);
+  bfd_h_put_32 (abfd, src->vna_next, dst->vna_next);
+}
+
+/* Swap in a Versym structure.  */
+
+void
+pei_swap_versym_in (abfd, src, dst)
+     bfd *abfd;
+     const coff_external_versym *src;
+     coff_internal_versym *dst;
+{
+  dst->vs_vers = bfd_h_get_16 (abfd, src->vs_vers);
+}
+
+/* Swap out a Versym structure.  */
+
+void
+pei_swap_versym_out (abfd, src, dst)
+     bfd *abfd;
+     const coff_internal_versym *src;
+     coff_external_versym *dst;
+{
+  bfd_h_put_16 (abfd, src->vs_vers, dst->vs_vers);
+}
+
+#endif /* ] */
+
 static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] =
   {
     N_("Export Directory [.edata (or where ever we found it)]"),
@@ -1681,6 +1854,163 @@ pe_print_reloc (abfd, vfile)
   return true;
 }
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+static boolean pe_print_dynamic PARAMS((bfd *, PTR));
+static boolean
+pe_print_dynamic (abfd, vfile)
+     bfd *abfd;
+     PTR vfile;
+{
+  FILE *f = (FILE *) vfile;
+  asection *s;
+  bfd_byte *dynbuf = NULL;
+
+  if ((abfd->flags & DYNAMIC) == 0)
+      return true;
+
+  s = coff_dynamic(abfd);
+  if (s != NULL)
+    {
+      unsigned long link;
+      coff_external_dyn *extdyn, *extdynend;
+
+      fprintf (f, _("\nDynamic (.so) Section:\n"));
+
+      dynbuf = (bfd_byte *) bfd_malloc (s->_raw_size);
+      if (dynbuf == NULL)
+	return false;
+      if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
+				      s->_raw_size))
+	return false;
+
+      link = s->link_index;
+
+      extdyn = (coff_external_dyn *)dynbuf;
+      extdynend = extdyn + s->_raw_size / sizeof (coff_external_dyn);
+
+      for (; extdyn < extdynend; extdyn++)
+	{
+	  coff_internal_dyn dyn;
+	  const char *name;
+	  char ab[20];
+	  boolean stringp;
+
+	  bfd_coff_swap_dyn_in (abfd, (PTR) extdyn, &dyn);
+
+	  if (dyn.d_tag == DT_NULL)
+	    break;
+
+	  stringp = false;
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      sprintf (ab, "0x%lx", (unsigned long) dyn.d_tag);
+	      name = ab;
+	      break;
+
+	    case DT_NEEDED: name = "NEEDED"; stringp = true; break;
+	    case DT_PLTRELSZ: name = "PLTRELSZ"; break;
+	    case DT_PLTGOT: name = "PLTGOT"; break;
+	    case DT_HASH: name = "HASH"; break;
+	    case DT_STRTAB: name = "STRTAB"; break;
+	    case DT_SYMTAB: name = "SYMTAB"; break;
+	    case DT_RELA: name = "RELA"; break;
+	    case DT_RELASZ: name = "RELASZ"; break;
+	    case DT_RELAENT: name = "RELAENT"; break;
+	    case DT_STRSZ: name = "STRSZ"; break;
+	    case DT_SYMENT: name = "SYMENT"; break;
+	    case DT_INIT: name = "INIT"; break;
+	    case DT_FINI: name = "FINI"; break;
+	    case DT_SONAME: name = "SONAME"; stringp = true; break;
+	    case DT_RPATH: name = "RPATH"; stringp = true; break;
+	    case DT_SYMBOLIC: name = "SYMBOLIC"; break;
+	    case DT_REL: name = "REL"; break;
+	    case DT_RELSZ: name = "RELSZ"; break;
+	    case DT_RELENT: name = "RELENT"; break;
+	    case DT_PLTREL: name = "PLTREL"; break;
+	    case DT_DEBUG: name = "DEBUG"; break;
+	    case DT_TEXTREL: name = "TEXTREL"; break;
+	    case DT_JMPREL: name = "JMPREL"; break;
+	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = true; break;
+	    case DT_FILTER: name = "FILTER"; stringp = true; break;
+	    case DT_VERSYM: name = "VERSYM"; break;
+	    case DT_VERDEF: name = "VERDEF"; break;
+	    case DT_VERDEFNUM: name = "VERDEFNUM"; break;
+	    case DT_VERNEED: name = "VERNEED"; break;
+	    case DT_VERNEEDNUM: name = "VERNEEDNUM"; break;
+	    }
+
+	  fprintf (f, "  %-11s ", name);
+	  if (! stringp)
+	    fprintf (f, "0x%lx", (unsigned long) dyn.d_un.d_val);
+	  else
+	    {
+	      const char *string;
+
+	      string = bfd_coff_string_from_coff_section (abfd, link,
+							dyn.d_un.d_val);
+	      if (string == NULL)
+		 string = "<BAD STRING>";
+	      fprintf (f, "%s", string);
+	    }
+	  fprintf (f, "\n");
+	}
+
+      free (dynbuf);
+      dynbuf = NULL;
+    }
+
+  if ((coff_dynverdef (abfd) != 0 && dyn_data(abfd)->verdef == NULL)
+      || (coff_dynverref (abfd) != 0 && dyn_data(abfd)->verref == NULL))
+    {
+      if (! _bfd_coff_slurp_version_tables (abfd))
+	return false;
+    }
+
+  if (coff_dynverdef (abfd) != 0)
+    {
+      coff_internal_verdef *t;
+
+      fprintf (f, _("\nVersion definitions:\n"));
+      for (t = dyn_data(abfd)->verdef; t != NULL; t = t->vd_nextdef)
+	{
+	  fprintf (f, "%d 0x%2.2x 0x%8.8lx %s\n", t->vd_ndx,
+		   t->vd_flags, t->vd_hash, t->vd_nodename);
+	  if (t->vd_auxptr->vda_nextptr != NULL)
+	    {
+	      coff_internal_verdaux *a;
+
+	      fprintf (f, "\t");
+	      for (a = t->vd_auxptr->vda_nextptr;
+		   a != NULL;
+		   a = a->vda_nextptr)
+		fprintf (f, "%s ", a->vda_nodename);
+	      fprintf (f, "\n");
+	    }
+	}
+    }
+
+  if (coff_dynverref (abfd) != 0)
+    {
+      coff_internal_verneed *t;
+
+      fprintf (f, _("\nVersion References:\n"));
+      for (t = dyn_data(abfd)->verref; t != NULL; t = t->vn_nextref)
+	{
+	  coff_internal_vernaux *a;
+
+	  fprintf (f, _("  required from %s:\n"), t->vn_filename);
+	  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
+	    fprintf (f, "    0x%8.8lx 0x%2.2x %2.2d %s\n", a->vna_hash,
+		     a->vna_flags, a->vna_other, a->vna_nodename);
+	}
+    }
+    return true;
+}
+
+#endif /* ] */
+
 /* Print out the program headers.  */
 
 boolean
@@ -1791,6 +2121,9 @@ _bfd_XX_print_private_bfd_data_common (a
 
   pe_print_idata (abfd, vfile);
   pe_print_edata (abfd, vfile);
+#ifdef DYNAMIC_LINKING
+  pe_print_dynamic (abfd, vfile);
+#endif
   pe_print_pdata (abfd, vfile);
   pe_print_reloc (abfd, vfile);
 
@@ -1859,7 +2192,11 @@ _bfd_XX_bfd_copy_private_section_data (i
       pei_section_data (obfd, osec)->pe_flags =
 	pei_section_data (ibfd, isec)->pe_flags;
     }
-
+#ifdef DYNAMIC_LINKING
+    osec->info_r = isec->info_r;
+    osec->info_l = isec->info_l;
+#endif
+
   return true;
 }
 
@@ -1944,3 +2281,225 @@ bfd_vma bfd_getImageBase (abfd)
   return 0;
 }
 
+#ifdef DYNAMIC_LINKING /* [ */
+
+#define LOADER_SYM "__LOADER_NAME"
+
+boolean
+pei_generic_size_dynamic_sections (output_bfd, info)
+     bfd *output_bfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+{
+  bfd *dynobj;
+  asection *s;
+  boolean plt;
+  boolean relocs;
+  boolean reltext;
+
+  dynobj = coff_hash_table (info)->dynobj;
+
+  /* We can get here because we're looking to see if any PIC modules
+     got in a static main program.  If none did, dynobj will be null,
+     and we're done.  */
+  if (dynobj == 0)
+      return true;
+
+  if (coff_hash_table (info)->dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (! info->shared)
+	{
+          struct coff_link_hash_entry *h = NULL;
+
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->_raw_size = sizeof LOADER_NAME;
+	  s->contents = (unsigned char *) LOADER_NAME;
+
+	  /* Define the symbol __LOADER_NAME_ at the start of the
+	     .plt section.  */
+	  if (! (bfd_coff_link_add_one_symbol
+		 (info, dynobj, 
+		  &LOADER_SYM[bfd_get_symbol_leading_char(dynobj)=='_'?0:1],
+		  BSF_GLOBAL, s,
+		  (bfd_vma) 0, (const char *) NULL, 
+		  false, false,
+		  (struct bfd_link_hash_entry **) &h)))
+	    return false;
+	  h->coff_link_hash_flags |= COFF_LINK_HASH_DEF_REGULAR;
+	  h->type = 0;
+	}
+    }
+  else
+    {
+      /* We may have created entries in the .rel.got section.
+         However, if we are not creating the dynamic sections, we will
+         not actually use these entries.  Reset the size of .rel.got,
+         which will cause it to get stripped from the output file
+         below.  */
+      s = bfd_get_section_by_name (dynobj, ".rel.got");
+      if (s != NULL)
+	s->_raw_size = 0;
+    }
+
+  /* The check_relocs and adjust_dynamic_symbol entry points have
+     determined the sizes of the various dynamic sections.  Allocate
+     memory for them.  */
+  plt = false;
+  relocs = false;
+  reltext = false;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      const char *name;
+      boolean strip;
+
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      /* It's OK to base decisions on the section name, because none
+	 of the dynobj section names depend upon the input files.  */
+      name = bfd_get_section_name (dynobj, s);
+
+      strip = false;
+
+      if (strcmp (name, ".plt") == 0)
+	{
+	  if (s->_raw_size == 0)
+	    {
+	      /* Strip this section if we don't need it; see the
+                 comment below.  */
+	      strip = true;
+	    }
+	  else
+	    {
+	      /* Remember whether there is a PLT.  */
+	      plt = true;
+	    }
+	}
+      else if (strncmp (name, ".rel", 4) == 0)
+	{
+	  if (s->_raw_size == 0)
+	    {
+	      /* If we don't need this section, strip it from the
+		 output file.  This is mostly to handle .rel.bss and
+		 .rel.plt.  We must create both sections in
+		 create_dynamic_sections, because they must be created
+		 before the linker maps input sections to output
+		 sections.  The linker does that before
+		 adjust_dynamic_symbol is called, and it is that
+		 function which decides whether anything needs to go
+		 into these sections.  */
+	      strip = true;
+	    }
+	  else
+	    {
+	      /* Remember whether there are any reloc sections other
+                 than .rel.plt.  */
+	      if (strcmp (name, ".rel.plt") != 0)
+		{
+		  relocs = true;
+
+		  /* We're left with .rel.internal and .rel.got.
+		     If there is a GOT (there may not be), it is
+		     by definition already read-write.  That leaves
+		     rel.internal to reflect relocations in all other
+		     sections; if it exists (and is non-zero size) then
+		     there are relocations that will (probably) cause 
+		     the text section to be written. It would be nice
+		     to be more accurate in this estimation.  That would
+		     speed up runtime startup. */
+		     
+	          if (strcmp (name, ".rel.internal") == 0)
+		    reltext = true;
+		}
+
+	      /* We use the reloc_count field as a counter if we need
+		 to copy relocs into the output file.  */
+	      s->reloc_count = 0;
+	    }
+	}
+      else if (strncmp (name, ".got", 4) != 0)
+	{
+	  /* It's not one of our sections, so don't allocate space.  */
+	  continue;
+	}
+
+      if (strip && strcmp(s->output_section->name,s->name)==0)
+	{
+	  asection **spp;
+
+	  for (spp = &s->output_section->owner->sections;
+	       *spp != s->output_section;
+	       spp = &(*spp)->next)
+	    ;
+	  *spp = s->output_section->next;
+	  --s->output_section->owner->section_count;
+
+	  continue;
+	}
+
+      /* Allocate memory for the section contents.  */
+      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
+      if (s->contents == NULL && s->_raw_size != 0)
+	return false;
+    }
+
+  if (coff_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in coff_i386_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+      if (! info->shared)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_DEBUG, 0))
+	    return false;
+	}
+
+      if (plt)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_PLTGOT, 0)
+	      || ! coff_add_dynamic_entry (info, DT_PLTRELSZ, 0)
+	      || ! coff_add_dynamic_entry (info, DT_PLTREL, DT_REL)
+	      || ! coff_add_dynamic_entry (info, DT_JMPREL, 0))
+	    return false;
+	}
+
+      if (relocs)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_REL, 0)
+	      || ! coff_add_dynamic_entry (info, DT_RELSZ, 0)
+	      || ! coff_add_dynamic_entry (info, DT_RELENT, RELSZ))
+	    return false;
+	}
+
+      if (reltext)
+	{
+	  if (! coff_add_dynamic_entry (info, DT_TEXTREL, 0))
+	    return false;
+	}
+    }
+
+  return true;
+}
+
+
+/* Used in the final link pass to sort relocations; since the relocations
+   have been swapped out, it's somewhat target dependent. */
+int reloc_compar(const void *av, const void *bv);
+
+int
+reloc_compar(const void *av, const void *bv)
+{
+    struct external_reloc *a = (struct external_reloc *)av;
+    struct external_reloc *b = (struct external_reloc *)bv;
+
+    if (((*(int *)&a->r_symndx)&0xffffff) < ((*(int *)&b->r_symndx)&0xffffff))
+       return -1;
+    if (((*(int *)&a->r_symndx)&0xffffff) > ((*(int *)&b->r_symndx)&0xffffff))
+       return 1;
+    return 0;
+}
+
+#endif /* ] */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/pei-i386.c bfd/pei-i386.c
--- bfd.pre.dynlink/pei-i386.c	Wed Feb  6 10:10:05 2002
+++ bfd/pei-i386.c	Wed Feb  6 10:11:27 2002
@@ -28,6 +28,7 @@ Foundation, Inc., 59 Temple Place - Suit
 #define TARGET_UNDERSCORE '_'
 #define COFF_LONG_SECTION_NAMES
 #define COFF_LONG_FILENAMES
+#define INPUT_FORMAT i386pe_vec
 
 #define COFF_SECTION_ALIGNMENT_ENTRIES \
 { COFF_SECTION_NAME_PARTIAL_MATCH (".idata"), \
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/peicode.h bfd/peicode.h
--- bfd.pre.dynlink/peicode.h	Wed Feb  6 10:10:05 2002
+++ bfd/peicode.h	Wed Feb  6 13:05:42 2002
@@ -203,6 +203,8 @@ coff_swap_reloc_out (abfd, src, dst)
 #define FILHDR struct external_PEI_IMAGE_hdr
 #endif
 
+static void coff_swap_filehdr_in PARAMS((bfd*, PTR, PTR));
+
 static void
 coff_swap_filehdr_in (abfd, src, dst)
      bfd            *abfd;
@@ -224,7 +226,7 @@ coff_swap_filehdr_in (abfd, src, dst)
   if (filehdr_dst->f_nsyms != 0 && filehdr_dst->f_symptr == 0)
     {
       filehdr_dst->f_nsyms = 0;
-      filehdr_dst->f_flags |= F_LSYMS;
+      filehdr_dst->f_flags |= F_LSYMS;  // THIS LOOKS WRONG!!!!
     }
 
   filehdr_dst->f_opthdr = H_GET_16 (abfd, filehdr_src-> f_opthdr);
@@ -257,6 +259,20 @@ coff_swap_scnhdr_in (abfd, ext, in)
   /* MS handles overflow of line numbers by carrying into the reloc
      field (it appears).  Since it's supposed to be zero for PE
      *IMAGE* format, that's safe.  This is still a bit iffy.  */
+#if defined(COFF_IMAGE_WITH_PE) && defined(DYNAMIC_LINKING)
+  if ((abfd->flags & DYNAMIC) == 0 &&
+     strcmp(scnhdr_int->s_name,".text") == 0)
+    {
+      scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
+			     + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
+      scnhdr_int->s_nreloc = 0;
+    }
+  else
+    {
+      scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
+      scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
+    }
+#else
 #ifdef COFF_IMAGE_WITH_PE
   scnhdr_int->s_nlnno = (H_GET_16 (abfd, scnhdr_ext->s_nlnno)
 			 + (H_GET_16 (abfd, scnhdr_ext->s_nreloc) << 16));
@@ -265,6 +281,7 @@ coff_swap_scnhdr_in (abfd, ext, in)
   scnhdr_int->s_nreloc = H_GET_16 (abfd, scnhdr_ext->s_nreloc);
   scnhdr_int->s_nlnno = H_GET_16 (abfd, scnhdr_ext->s_nlnno);
 #endif
+#endif
 
 #ifdef COFF_IMAGE_WITH_PE
 #ifndef COFF_NO_HACK_SCNHDR_SIZE
@@ -355,6 +372,13 @@ pe_mkobject_hook (abfd, filehdr, aouthdr
 #ifdef COFF_IMAGE_WITH_PE
   if (aouthdr)
     pe->pe_opthdr = ((struct internal_aouthdr *)aouthdr)->pe;
+#ifdef DYNAMIC_LINKING
+  if ((pe->pe_opthdr.DllCharacteristics & 0x0001) != 0)
+    abfd->flags |= DYNAMIC;
+
+  if ((pe->pe_opthdr.DllCharacteristics & 0x0002) != 0)
+    abfd->flags |= NO_LINK;
+#endif
 #endif
 
 #ifdef ARM
@@ -868,7 +892,10 @@ pe_ILF_build_a_bfd (bfd *           abfd
   asection_ptr             id4, id5, id6 = NULL, text = NULL;
   coff_symbol_type **      imp_sym;
   unsigned int             imp_index;
-
+#ifdef DYNAMIC_LINKING
+  asection_ptr             secp;
+#endif
+
   /* Decode and verify the types field of the ILF structure.  */
   import_type = types & 0x3;
   import_name_type = (types & 0x1c) >> 2;
@@ -1247,6 +1274,19 @@ pe_ILF_build_a_bfd (bfd *           abfd
 
   obj_coff_strings (abfd) = vars.string_table;
   obj_coff_keep_strings (abfd) = true;
+
+#ifdef DYNAMIC_LINKING
+  /* Image the section lookup stuff used elsewhere. */
+  coff_coffsections(abfd) =
+     (asection **)bfd_alloc(abfd, sizeof(asection *) * abfd->section_count);
+
+  secp = abfd->sections;
+  while (secp)
+    {
+      coff_coffsections(abfd)[secp->index] = secp;
+      secp = secp->next;
+    }
+#endif
 
   abfd->flags |= HAS_SYMS;
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/section.c bfd/section.c
--- bfd.pre.dynlink/section.c	Wed Feb  6 10:10:06 2002
+++ bfd/section.c	Wed Feb  6 10:11:28 2002
@@ -451,6 +451,23 @@ CODE_FRAGMENT
 .  {* File position of line data.  *}
 .  file_ptr line_filepos;
 .
+.{* #ifdef DYNAMIC_LINKING *}
+.  {* Certain sections need counts, which we overload into the
+.     coff number of relocs and/or number of line numbers fields,
+.     but carrying those in the same fields here is asking for 
+.     trouble, so the overloaded ones live here. *}
+.
+.  unsigned int info_r;
+.  unsigned int info_l;
+.
+.  {* There are multiple string tables possible when dynamically
+.     linking; this is the section number for the string table
+.     for this section *}
+.
+.  int link_index;
+.
+.{* #endif *}
+.
 .  {* Pointer to data for applications.  *}
 .  PTR userdata;
 .
@@ -605,8 +622,14 @@ static const asymbol global_syms[] =
     /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */	\
        NULL,       NULL,        0,           0,       0,		\
 									\
-    /* line_filepos, userdata, contents, lineno, lineno_count,       */	\
-       0,            NULL,     NULL,     NULL,   0,			\
+    /* line_filepos, */ /* // Pretty this up when permanent */          \
+       0,                                                               \
+   									\
+    /* info_r, info_l, link_index */					\
+       0,      0,      0,						\
+    									\
+    /* userdata, contents, lineno, lineno_count,       */	        \
+       NULL,     NULL,     NULL,   0,			                \
 									\
     /* entsize, comdat, moving_line_filepos,                         */	\
        0,       NULL,   0,						\
@@ -695,6 +718,12 @@ bfd_section_init (abfd, newsect)
   newsect->symbol->value = 0;
   newsect->symbol->section = newsect;
   newsect->symbol->flags = BSF_SECTION_SYM;
+#ifdef DYNAMIC_LINKING
+  newsect->info_r = newsect->info_l = 0;
+#endif
+#ifdef DYNAMIC_LINKING
+  newsect->info_r = newsect->info_l = 0;
+#endif
 
   newsect->symbol_ptr_ptr = &newsect->symbol;
 
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/som.c bfd/som.c
--- bfd.pre.dynlink/som.c	Wed Feb  6 10:10:06 2002
+++ bfd/som.c	Wed Feb  6 13:06:22 2002
@@ -172,7 +172,8 @@ static boolean som_slurp_reloc_table PAR
 static long som_get_symtab PARAMS ((bfd *, asymbol **));
 static asymbol * som_make_empty_symbol PARAMS ((bfd *));
 static void som_print_symbol PARAMS ((bfd *, PTR,
-				      asymbol *, bfd_print_symbol_type));
+				      asymbol *, bfd_print_symbol_type, 
+				      asection *));
 static boolean som_new_section_hook PARAMS ((bfd *, asection *));
 static boolean som_bfd_copy_private_symbol_data PARAMS ((bfd *, asymbol *,
 							  bfd *, asymbol *));
@@ -4539,11 +4540,12 @@ som_make_empty_symbol (abfd)
 /* Print symbol information.  */
 
 static void
-som_print_symbol (abfd, afile, symbol, how)
+som_print_symbol (ignore_abfd, afile, symbol, how, ignored)
      bfd *abfd;
      PTR afile;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   FILE *file = (FILE *) afile;
   switch (how)
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/srec.c bfd/srec.c
--- bfd.pre.dynlink/srec.c	Wed Feb  6 10:10:06 2002
+++ bfd/srec.c	Wed Feb  6 15:37:47 2002
@@ -112,7 +112,7 @@ DESCRIPTION
 
 static void srec_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
 static void srec_print_symbol
- PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
+ PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, asymbol *));
 static void srec_init PARAMS ((void));
 static boolean srec_mkobject PARAMS ((bfd *));
 static int srec_get_byte PARAMS ((bfd *, boolean *));
@@ -1210,12 +1210,13 @@ srec_get_symbol_info (ignore_abfd, symbo
 }
 
 static void
-srec_print_symbol (abfd, afile, symbol, how)
+srec_print_symbol (abfd, afile, symbol, how, ignored)
      bfd *abfd;
      PTR afile;
      asymbol *symbol;
      bfd_print_symbol_type how;
-{
+     asymbol *ignored ATTRIBUTE_UNUSED;
+{
   FILE *file = (FILE *) afile;
   switch (how)
     {
@@ -1266,6 +1267,7 @@ const bfd_target srec_vec =
 {
   "srec",			/* name */
   bfd_target_srec_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* target byte order */
   BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
   (HAS_RELOC | EXEC_P |		/* object flags */
@@ -1321,6 +1323,7 @@ const bfd_target symbolsrec_vec =
 {
   "symbolsrec",			/* name */
   bfd_target_srec_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* target byte order */
   BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
   (HAS_RELOC | EXEC_P |		/* object flags */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/targets.c bfd/targets.c
--- bfd.pre.dynlink/targets.c	Wed Feb  6 10:10:06 2002
+++ bfd/targets.c	Wed Feb  6 13:09:19 2002
@@ -172,6 +172,12 @@ DESCRIPTION
 .    the contents of a file.  *}
 .  enum bfd_flavour flavour;
 .
+. {* Input format: if the file format for input to the linker is not the same
+.    as the output format, then a pointer to the input format type goes here
+.    in the output format's record.  (This happens for PE/PEI, at least.) *}
+.
+.  const struct bfd_target *input_format;
+.
 .  {* The order of bytes within the data area of a file.  *}
 .  enum bfd_endian byteorder;
 .
@@ -341,8 +347,9 @@ the tokens.
 .           (*_bfd_make_empty_symbol) PARAMS ((bfd *));
 .  void     (*_bfd_print_symbol) PARAMS ((bfd *, PTR,
 .                                         struct symbol_cache_entry *,
-.                                         bfd_print_symbol_type));
-.#define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
+.                                      bfd_print_symbol_type,
+.				       struct symbol_cache_entry *));
+.#define bfd_print_symbol(b,p,s,e,r) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e,r))
 .  void     (*_bfd_get_symbol_info) PARAMS ((bfd *,
 .                                            struct symbol_cache_entry *,
 .                                            symbol_info *));
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/tekhex.c bfd/tekhex.c
--- bfd.pre.dynlink/tekhex.c	Wed Feb  6 10:10:06 2002
+++ bfd/tekhex.c	Wed Feb  6 15:38:13 2002
@@ -101,7 +101,7 @@ static char sum_block[256];
 static void tekhex_init PARAMS ((void));
 static bfd_vma getvalue PARAMS ((char **));
 static void tekhex_print_symbol
- PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
+ PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, asymbol*));
 static void tekhex_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
 static asymbol *tekhex_make_empty_symbol PARAMS ((bfd *));
 static int tekhex_sizeof_headers PARAMS ((bfd *, boolean));
@@ -960,12 +960,13 @@ tekhex_get_symbol_info (ignore_abfd, sym
 }
 
 static void
-tekhex_print_symbol (abfd, filep, symbol, how)
+tekhex_print_symbol (abfd, filep, symbol, how, ignored)
      bfd *abfd;
      PTR filep;
      asymbol *symbol;
      bfd_print_symbol_type how;
-{
+     asymbol *ignored ATTRIBUTE_UNUSED;
+{
   FILE *file = (FILE *) filep;
 
   switch (how)
@@ -1017,6 +1018,7 @@ const bfd_target tekhex_vec =
 {
   "tekhex",			/* name */
   bfd_target_tekhex_flavour,
+  NULL,				/* only self is acceptable for link */
   BFD_ENDIAN_UNKNOWN,		/* target byte order */
   BFD_ENDIAN_UNKNOWN,		/* target headers byte order */
   (EXEC_P |			/* object flags */
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/versados.c bfd/versados.c
--- bfd.pre.dynlink/versados.c	Wed Feb  6 10:10:06 2002
+++ bfd/versados.c	Wed Feb  6 16:30:31 2002
@@ -61,7 +61,7 @@ static long int versados_get_symtab PARA
 static void versados_get_symbol_info
   PARAMS ((bfd *, asymbol *, symbol_info *));
 static void versados_print_symbol
-  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
+  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type, asymbol *));
 static long versados_get_reloc_upper_bound
   PARAMS ((bfd *, sec_ptr));
 static long versados_canonicalize_reloc
@@ -767,11 +767,12 @@ versados_get_symbol_info (ignore_abfd, s
 }
 
 static void
-versados_print_symbol (abfd, afile, symbol, how)
+versados_print_symbol (ignore_abfd, afile, symbol, how, ignored)
      bfd *abfd;
      PTR afile;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
   FILE *file = (FILE *) afile;
   switch (how)
diff -drupP --exclude-from=/dev/fs/M/donn/diffs/exclude.files bfd.pre.dynlink/vms.c bfd/vms.c
--- bfd.pre.dynlink/vms.c	Wed Feb  6 10:10:06 2002
+++ bfd/vms.c	Wed Feb  6 13:11:13 2002
@@ -75,7 +75,8 @@ static int vms_generic_stat_arch_elt PAR
 static long vms_get_symtab_upper_bound PARAMS ((bfd *abfd));
 static long vms_get_symtab PARAMS ((bfd *abfd, asymbol **symbols));
 static void vms_print_symbol
-  PARAMS ((bfd *abfd, PTR file, asymbol *symbol, bfd_print_symbol_type how));
+  PARAMS ((bfd *abfd, PTR file, asymbol *symbol, bfd_print_symbol_type how,
+  asection *));
 static void vms_get_symbol_info
   PARAMS ((bfd *abfd, asymbol *symbol, symbol_info *ret));
 static boolean vms_bfd_is_local_label_name PARAMS ((bfd *abfd, const char *));
@@ -1148,11 +1149,12 @@ vms_get_symtab (abfd, symbols)
    bfd_print_symbol_all	print all we know, which is not much right now :-)  */
 
 static void
-vms_print_symbol (abfd, file, symbol, how)
+vms_print_symbol (abfd, file, symbol, how, ignored)
      bfd *abfd;
      PTR file;
      asymbol *symbol;
      bfd_print_symbol_type how;
+     asymbol *ignored ATTRIBUTE_UNUSED;
 {
 #if VMS_DEBUG
   vms_debug (1, "vms_print_symbol(%p, %p, %p, %d)\n", abfd, file, symbol, how);
