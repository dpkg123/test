/*=============================================================================
	LandscapeVertexFactory.usf: Landscape vertex factory.
	Copyright 1998-2011 Epic Games, Inc. All Rights Reserved.
=============================================================================*/


#define TERRAIN_ZSCALE				(1.0f/128.0f)

float4x4	LocalToWorld;
float4x4	PreviousLocalToWorld;
float3x3	WorldToLocal;

float4 HeightmapUVScaleBias;
float4 WeightmapUVScaleBias;
float HeightmapLodBias;
float4 LandscapeLightmapScaleBias;
float4 LightmapCoordinateScaleBias;
float4 ShadowmapCoordinateScaleBias;

/* x = LOD
   y = convert current LOD coordinates into highest LOD coordinates
   z = convert highest LOD coordinates into next LOD coordinates.
   w = convert next LOD coordinates into highest LOD coordinates.
*/
float4 LodValues;

/* x = Camera X in local space
   y = Camera Y in local space 
   z = Distance from camera for current LOD
   w = Distance from camera to next LOD.
*/
float4 LodDistancesValues;

/* x = SectionSizeQuads
   y = 1/SectionSizeQuads
   z = LayerUVPan.u
   w = LayerUVPan.w
  */
float4 SectionSizeQuadsLayerUVPan;

sampler2D HeightmapTexture;

struct FVertexFactoryInput
{
	float2 Position: POSITION;
#if PS3
	float4 PS3Height : BLENDWEIGHT0;	
#endif
};

struct FVertexFactoryInterpolantsVSToPS
{
	float3	LayerTexCoord			: TEXCOORD0;
	float4	HeightWeightMapTexCoord	: TEXCOORD1;
#if NEEDS_LIGHTMAP_COORDINATE
	float2	LightMapCoordinate		: TEXCOORD2;
#endif
};

struct FLandscapeTexCoords
{
	float3	LayerTexCoord;
	float4	HeightWeightMapTexCoord;
#if NEEDS_LIGHTMAP_COORDINATE
	float2	LightMapCoordinate;
#endif
};

struct FVertexFactoryInterpolantsVSToDS
{
	FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
	
#if USING_SM5_TESSELATION
	// Interpolated normal for DS use
	// _centroid is needed to get better quality with MSAA

	// The D3D shader compiler combines _centroid and non controid. Using float3 would results in a internal
	// shader compiler error. This block is using float4 to prevent that.
	float4 WorldNormal		: TEXCOORD10_centroid;
#endif
};

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryInterpolantsVSToDS Input)
{
	return Input.InterpolantsVSToPS;
}

struct FVertexFactoryIntermediates
{
	float3 LocalPosition;
#if USING_SM5_TESSELATION
	float3 WorldNormal;
#endif
};

/** Calculate the texture coordinates generated by Landscape */
FLandscapeTexCoords GetLandscapeTexCoords(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	FLandscapeTexCoords Result;

	Result.LayerTexCoord				= float3(Intermediates.LocalPosition.xy + SectionSizeQuadsLayerUVPan.zw,0);
	Result.HeightWeightMapTexCoord.xy	= Intermediates.LocalPosition.xy * HeightmapUVScaleBias.xy + HeightmapUVScaleBias.zw + 0.5*HeightmapUVScaleBias.xy;
	Result.HeightWeightMapTexCoord.zw	= Intermediates.LocalPosition.xy * WeightmapUVScaleBias.xy + WeightmapUVScaleBias.zw;

#if NEEDS_LIGHTMAP_COORDINATE
	Result.LightMapCoordinate.xy		= (Intermediates.LocalPosition.xy * LandscapeLightmapScaleBias.xy + LandscapeLightmapScaleBias.wz) * LightmapCoordinateScaleBias.xy + LightmapCoordinateScaleBias.wz;
#endif

	return Result;
}

float3x3 CalcTangentBasisFromWorldNormal(float3 Normal)
{
	float3 LocalTangentX = normalize(float3(Normal.z, 0, -Normal.x));
	float3 LocalTangentY = cross(Normal, LocalTangentX);

	float3x3 LocalToTangent = float3x3(LocalTangentX,LocalTangentY,Normal);

	return LocalToTangent;
}

/** Lookup per-pixel tangent basis from heightmap texture */
float3x3 VertexFactoryGetPerPixelTangentBasis(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	float4 SampleValue = tex2D(HeightmapTexture, Interpolants.HeightWeightMapTexCoord.xy);
	float2 SampleNormal = float2(SampleValue.b, SampleValue.a) * float2(2.0,2.0) - float2(1.0,1.0);
	float3 WorldNormal = float3( SampleNormal, sqrt(1.0-dot(SampleNormal,SampleNormal)) );

	return CalcTangentBasisFromWorldNormal(WorldNormal);
}

/** Converts from vertex factory specific interpolants to a FMaterialTessellationParameters, which is used by material inputs. */
FMaterialTessellationParameters GetMaterialTessellationParameters(FVertexFactoryInterpolantsVSToDS Interpolants, float3 CameraLocalWorldPosition)
{
	FMaterialTessellationParameters	Result;

#if NUM_MATERIAL_TEXCOORDS
	Result.TexCoords[0] = Interpolants.InterpolantsVSToPS.HeightWeightMapTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 1
	Result.TexCoords[1] = Interpolants.InterpolantsVSToPS.HeightWeightMapTexCoord.zw;
#if NUM_MATERIAL_TEXCOORDS > 2
	#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = Interpolants.InterpolantsVSToPS.LightMapCoordinate;
	#else
		Result.TexCoords[2] = float2(0,0);
	#endif
#if NUM_MATERIAL_TEXCOORDS > 3
	Result.TexCoords[3] = Interpolants.InterpolantsVSToPS.LayerTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 4
	Result.TexCoords[4] = Interpolants.InterpolantsVSToPS.LayerTexCoord.xz;
#if NUM_MATERIAL_TEXCOORDS > 5
	Result.TexCoords[5] = Interpolants.InterpolantsVSToPS.LayerTexCoord.yz;
#if NUM_MATERIAL_TEXCOORDS > 6
	UNROLL
	for(int CoordinateIndex = 6;CoordinateIndex < NUM_MATERIAL_TEXCOORDS;CoordinateIndex ++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
	}
#endif	// >6
#endif	// >5
#endif	// >4
#endif	// >3
#endif	// >2
#endif	// >1
#endif

	// Use interpolated normal from VS.
#if USING_SM5_TESSELATION
	Result.TangentToWorld = CalcTangentBasisFromWorldNormal( Interpolants.WorldNormal.xyz );
#endif

	Result.WorldPosition = CameraLocalWorldPosition + CameraWorldPos.xyz;

	return Result;
}

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	FMaterialPixelParameters	Result;

#if NUM_MATERIAL_TEXCOORDS
	Result.TexCoords[0] = Interpolants.HeightWeightMapTexCoord.xy;		// Heightmap
	UNROLL
	for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
	{
		Result.SampleTexCoords[SampleIndex][0] = EvaluateAttributeAtSample(Interpolants.HeightWeightMapTexCoord.xy,SampleIndex);
	}
#if NUM_MATERIAL_TEXCOORDS > 1
	Result.TexCoords[1] = Interpolants.HeightWeightMapTexCoord.zw;		// Weightmap
	UNROLL
	for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
	{
		Result.SampleTexCoords[SampleIndex][1] = EvaluateAttributeAtSample(Interpolants.HeightWeightMapTexCoord.zw,SampleIndex);
	}
#if NUM_MATERIAL_TEXCOORDS > 2
	#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = Interpolants.LightMapCoordinate;			// Lightmap
		UNROLL
		for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
		{
			Result.SampleTexCoords[SampleIndex][2] = EvaluateAttributeAtSample(Interpolants.LightMapCoordinate,SampleIndex);
		}
	#else	//#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = float2(0,0);
		UNROLL
		for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
		{
			Result.SampleTexCoords[SampleIndex][2] = float2(0,0);
		}
	#endif	//#if NEEDS_LIGHTMAP_COORDINATE
#if NUM_MATERIAL_TEXCOORDS > 3
	Result.TexCoords[3] = Interpolants.LayerTexCoord.xy;				// XY layer
	UNROLL
	for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
	{
		Result.SampleTexCoords[SampleIndex][3] = EvaluateAttributeAtSample(Interpolants.LayerTexCoord.xy,SampleIndex);
	}
#if NUM_MATERIAL_TEXCOORDS > 4
	Result.TexCoords[4] = Interpolants.LayerTexCoord.xz;				// XZ layer
	UNROLL
	for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
	{
		Result.SampleTexCoords[SampleIndex][4] = EvaluateAttributeAtSample(Interpolants.LayerTexCoord.xz,SampleIndex);
	}
#if NUM_MATERIAL_TEXCOORDS > 5
	Result.TexCoords[5] = Interpolants.LayerTexCoord.yz;				// YZ layer
	UNROLL
	for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
	{
		Result.SampleTexCoords[SampleIndex][5] = EvaluateAttributeAtSample(Interpolants.LayerTexCoord.yz,SampleIndex);
	}
#if NUM_MATERIAL_TEXCOORDS > 6
	UNROLL
	for(int CoordinateIndex = 6;CoordinateIndex < NUM_MATERIAL_TEXCOORDS;CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
		UNROLL
		for(uint SampleIndex = 0;SampleIndex < NUM_TEXCOORD_SAMPLES;++SampleIndex)
		{
			Result.SampleTexCoords[SampleIndex][CoordinateIndex] = float2(0,0);
		}
	}
#endif // 6
#endif // 5
#endif // 4
#endif // 3
#endif // 2 
#endif // 1
#endif // 0

#if WORLD_COORDS
	// Calculate LocalToTangent directly from normal map texture.
	float3x3 LocalToTangent = VertexFactoryGetPerPixelTangentBasis(Interpolants);
	// The inverse of LocalToTangent is just the transpose because it is an orthonormal basis
	float3x3 TangentToLocal = transpose(LocalToTangent);
	// LocalToWorldMatrix is bound by Material.usf if WORLD_COORDS
	Result.TangentToWorld = mul(transpose((float3x3)LocalToWorldMatrix), TangentToLocal); 
	Result.UnMirrored = 1;
#endif

	Result.VertexColor = 1;

	Result.TangentNormal = 0;
	Result.TangentCameraVector = 0;
	Result.TangentReflectionVector = 0;
	Result.ScreenPosition = 0;
	Result.TangentLightVector = 0;

#if LIGHTMAP_UV_ACCESS
#if NEEDS_LIGHTMAP_COORDINATE	//TEXTURE_LIGHTMAP || SIMPLE_TEXTURE_LIGHTMAP
	Result.LightmapUVs = Interpolants.LightMapCoordinate.xy;
#else
	Result.LightmapUVs = float2(0, 0);
#endif
#endif

	Result.TwoSidedSign = 1;
	return Result;
}

// When we're using instancing on Xbox, the vertex attributes are in the FVertexFactoryIntermediates, rather than the VertexFactoryInput struct.
#define VertexAttributes	Input


float4 VertexFactoryGetVertexColor(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float4(1,1,1,1);
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, float3x3 TangentBasis )
{
	FMaterialVertexParameters Result;
	Result.WorldPosition = WorldPosition - PreViewTranslation.xyz;
	Result.VertexColor = VertexFactoryGetVertexColor(Input, Intermediates);

	float3x3 TangentToLocal = transpose(TangentBasis);

	#if PS3
		float3x3 TangentToWorld = mul(transpose((float3x3)LocalToWorld), TangentToLocal); 
	#else
		// does not handle instancing!
		float3x3 TangentToWorld = mul((float3x3)LocalToWorld, TangentToLocal); 
	#endif

	Result.TangentToWorld = TangentToWorld;

	FLandscapeTexCoords LandscapeTexCoords = GetLandscapeTexCoords(Input, Intermediates);

#if NUM_MATERIAL_TEXCOORDS
	Result.TexCoords[0] = LandscapeTexCoords.HeightWeightMapTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 1
	Result.TexCoords[1] = LandscapeTexCoords.HeightWeightMapTexCoord.zw;
#if NUM_MATERIAL_TEXCOORDS > 2
	#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = LandscapeTexCoords.LightMapCoordinate;
	#else
		Result.TexCoords[2] = float2(0,0);
	#endif
#if NUM_MATERIAL_TEXCOORDS > 3
	Result.TexCoords[3] = LandscapeTexCoords.LayerTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 4
	Result.TexCoords[4] = LandscapeTexCoords.LayerTexCoord.xz;
#if NUM_MATERIAL_TEXCOORDS > 5
	Result.TexCoords[5] = LandscapeTexCoords.LayerTexCoord.yz;
#if NUM_MATERIAL_TEXCOORDS > 6
	UNROLL
	for(int CoordinateIndex = 6;CoordinateIndex < NUM_MATERIAL_TEXCOORDS;CoordinateIndex ++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
	}
#endif	// >6
#endif	// >5
#endif	// >4
#endif	// >3
#endif	// >2
#endif	// >1
#endif

	return Result;
}

#if NEEDS_LIGHTMAP_COORDINATE
float2 GetLightMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.LightMapCoordinate.xy;
}

#if NEEDS_SHADOWMAP_COORDINATE
float2 GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.LightMapCoordinate.xy * ShadowmapCoordinateScaleBias.xy + ShadowmapCoordinateScaleBias.zw;
}
#endif
#endif

#if NEEDS_VERTEX_LIGHTMAP
void VertexFactoryGetVertexLightMap(FVertexFactoryInput Input,out float4 LightMapA,out float4 LightMapB)
{
	LightMapA = 1;
	LightMapB = 1;
}
#elif NEEDS_SIMPLE_VERTEX_LIGHTMAP
void VertexFactoryGetSimpleVertexLightMap(FVertexFactoryInput Input,out float4 LightMapA)
{
	LightMapA = 1;
}
#endif

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates;

	// Position for current LOD in base LOD units
	float2 InputPositionLODAdjusted = Input.Position.xy * LodValues.y;

	// Position for next LOD in base LOD units
	float2 NextLODCoordsInt = floor( InputPositionLODAdjusted * LodValues.z + float2(0.5,0.5) );
	float2 InputPositionNextLOD = NextLODCoordsInt * LodValues.w;

	// calculate amount of morphing based on LOD.
	float LodDistance = length(LodDistancesValues.xy - InputPositionLODAdjusted);
	float MorphAlpha = clamp( (LodDistance - LodDistancesValues.z) / (LodDistancesValues.w - LodDistancesValues.z), 0.0, 1.0 );

#if PS3

	// Get the height and normal XY straight out of the SPU-generated stream.
	float Height = ((Input.PS3Height.z * 256.0 + Input.PS3Height.w) - 32768.0) * TERRAIN_ZSCALE;
	Intermediates.LocalPosition = lerp( float3(InputPositionLODAdjusted, Height), float3(InputPositionNextLOD, Height), MorphAlpha );
#else

	// Get the height and normal XY for current and next LOD out of the textures
	float4 SampleCoords = float4(InputPositionLODAdjusted * HeightmapUVScaleBias.xy + HeightmapUVScaleBias.zw + 0.5*HeightmapUVScaleBias.xy, 0, LodValues.x-HeightmapLodBias);
	float4 SampleValue = tex2Dlod( HeightmapTexture, SampleCoords );
	float Height = ((SampleValue.r * 255.0 * 256.0 + SampleValue.g * 255.0) - 32768.0) * TERRAIN_ZSCALE;

	float4 SampleCoordsNextLOD = float4(InputPositionNextLOD * HeightmapUVScaleBias.xy + HeightmapUVScaleBias.zw + 0.5*HeightmapUVScaleBias.xy, 0, LodValues.x+1-HeightmapLodBias);
	float4 SampleValueNextLOD = tex2Dlod( HeightmapTexture, SampleCoordsNextLOD );
	float HeightNextLOD = ((SampleValueNextLOD.r * 255.0 * 256.0 + SampleValueNextLOD.g * 255.0) - 32768.0) * TERRAIN_ZSCALE;

	Intermediates.LocalPosition = lerp( float3(InputPositionLODAdjusted, Height), float3(InputPositionNextLOD, HeightNextLOD), MorphAlpha );

#if USING_SM5_TESSELATION
	float2 Normal = float2(SampleValue.b, SampleValue.a);
	float2 NormalNextLOD = float2(SampleValueNextLOD.b, SampleValueNextLOD.a);
	float2 InterpNormal = lerp( Normal, NormalNextLOD, MorphAlpha ) * float2(2.0,2.0) - float2(1.0,1.0);
	Intermediates.WorldNormal = float3( InterpNormal, sqrt(1.0-dot(InterpNormal,InterpNormal)) );
#endif

#endif

	return Intermediates;
}

/**
* Get the 3x3 tangent basis vectors for this vertex factory
* this vertex factory will calculate the binormal on-the-fly
*
* @param Input - vertex input stream structure
* @return 3x3 matrix
*/
float3x3 VertexFactoryGetTangentBasis( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates )
{
	return float3x3(float3(1,0,0),float3(0,1,0),float3(0,0,1));
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return MulMatrix(LocalToWorld,float4(Intermediates.LocalPosition,1));
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	FVertexFactoryInterpolantsVSToPS Interpolants;

	FLandscapeTexCoords LandscapeTexCoords = GetLandscapeTexCoords(Input, Intermediates);

	Interpolants.LayerTexCoord				= LandscapeTexCoords.LayerTexCoord;
	Interpolants.HeightWeightMapTexCoord	= LandscapeTexCoords.HeightWeightMapTexCoord;

#if NEEDS_LIGHTMAP_COORDINATE
	Interpolants.LightMapCoordinate			= LandscapeTexCoords.LightMapCoordinate;
#endif

	return Interpolants;
}

FVertexFactoryInterpolantsVSToDS VertexFactoryGetInterpolantsVSToDS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	FVertexFactoryInterpolantsVSToDS Interpolants;
	
	Interpolants.InterpolantsVSToPS = VertexFactoryGetInterpolantsVSToPS(Input, Intermediates);

#if USING_SM5_TESSELATION
	Interpolants.WorldNormal		= float4(Intermediates.WorldNormal,0);
#endif

	return Interpolants;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return MulMatrix(PreviousLocalToWorld,float4(Intermediates.LocalPosition,1));
}

/**
* Transform a vector from world space to tangent space
*
* @param Input - vertex input stream structure
* @param TangentBasis - 3x3 matrix to transform to tangent space
* @param WorldVector - vector in world space to transform 
* @return vector in tangent space
*/
float3 VertexFactoryWorldToTangentSpace( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3x3 TangentBasis, float3 WorldVector )
{
	return mul(TangentBasis, MulMatrix(WorldToLocal,WorldVector));
}

half3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	/* This function is used only by HitMaskVertexShader, which is not supported with LandscapeVertexFactory */
	return float3(0,0,1);
}

FVertexFactoryInterpolantsVSToDS VertexFactoryInterpolate(FVertexFactoryInterpolantsVSToDS a, float aInterp, FVertexFactoryInterpolantsVSToDS b, float bInterp)
{
	FVertexFactoryInterpolantsVSToDS O;
	
#if NEEDS_LIGHTMAP_COORDINATE
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.LightMapCoordinate);
#endif

	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.LayerTexCoord);
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.HeightWeightMapTexCoord);

#if USING_SM5_TESSELATION
	TESSELLATION_INTERPOLATE_MEMBER(WorldNormal);
#endif

	return O;
}

float4 VertexFactoryGetWorldNormal(FVertexFactoryInterpolantsVSToDS Interpolants)
{
#if USING_SM5_TESSELATION
	return Interpolants.WorldNormal;
#else
	return float4(0,0,1,0);
#endif
}
