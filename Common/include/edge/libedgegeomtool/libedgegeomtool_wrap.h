/* SCE CONFIDENTIAL
 * PlayStation(R)Edge 1.2.0
 * Copyright (C) 2007 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

#if !defined(LIBEDGEGEOMTOOL_WRAP_H)
#define LIBEDGEGEOMTOOL_WRAP_H

#include "edge/libedgegeomtool/libedgegeomtool.h"

///
/// This file contains structures and functions which can be used as a higher-level wrapper around
/// the libedgegeomtool API.  This is an "open" wrapper; all functions defined in this file are
/// implemented in terms of the lower-level public libedgeom API, with no behind-the-scenes magic.
///

/// Describes the format of the segment data generated by the tools, and the operations which the
/// operations which the SPU runtime will be performing on said segments.
/// The caller is responsible for allocating and freeing all pointer members in this structure.
struct EdgeGeomSegmentFormat
{
	// Formats for the main SPU input vertex streams.  The first entry is required to be non-NULL.
	// The second stream is optional (it's useful for instancing certain vertex attributes, or
	// splitting position values into their own stream for a depth-only pass) -- it can be NULL if unused.
	EdgeGeomSpuVertexFormat *m_spuInputVertexFormats[2];
	// Optional blend shape vertex delta stream format.  Must only contain attributes that are present in
	// the SPU input streams, though possibly with different attribute types.  Can be NULL if the scene
	// has no blend shapes.
	EdgeGeomSpuVertexFormat *m_spuInputVertexDeltaFormat;
	// Required SPU output format.  Must only contain attributes that are present in the input streams,
	// though possibly with different attribute types.
	EdgeGeomRsxVertexFormat *m_spuOutputVertexFormat;
	// Optional format for a vertex stream that does not need to be passed through the SPUs for Edge
	// processing, but which needs to be kept in the same order as the Edge attributes (e.g. texture
	// coordinates, lighting coefficients). Can be NULL if all of the scene's attributes must go through the SPU.
	EdgeGeomRsxVertexFormat *m_rsxOnlyVertexFormat; 

	EdgeGeomSkinningFlavor m_skinType;
	EdgeGeomIndexesFlavor m_indexesType;
	EdgeGeomMatrixFormat m_skinMatrixFormat;
};

/// Container for the relevant geometry data from the input scene, which will be partitioned into SPU-sized
/// geometry segments.
/// The user is responsible for allocating and freeing all pointer members in this structure.
struct EdgeGeomScene
{
	// Scene triangle data.
	uint32_t m_numTriangles;
	uint32_t *m_triangles; // Has 3 * m_numTriangles entries
	int32_t *m_materialIdPerTriangle; // Has m_numTriangles entries

	// Main vertex attribute data.
	// The indexes and IDs can appear in any order (not necessarily strictly ascending), so long as
	// they both use the same ordering.
	uint32_t m_numVertexes;
	uint32_t m_numFloatsPerVertex;
	float *m_vertexes; // Has m_numVertexes * m_numFloatsPerVertex entries
	uint8_t m_numVertexAttributes;
	uint16_t *m_vertexAttributeIndexes; // Index of the start of each attribute within a single vertex.  Has m_numVertexAttributes entries
	EdgeGeomAttributeId *m_vertexAttributeIds; // Has m_numVertexAttributes entries

	// Scene blend shape data.
	// For simplicity, blend shapes data is stored as one giant flat array of vertex deltas.
	// The m_vertexDeltas array has (m_numBlendShapes * m_numVertexes * m_numFloatsPerDelta).
	// The deltas for every vertex in the scene for blend shape #1 come first, followed by all
	// the deltas for shape #2, and so on.
	uint32_t m_numBlendShapes; // Must be zero if there are no blend shapes in the scene
	uint32_t m_numFloatsPerDelta;
	float *m_vertexDeltas; // Can be NULL if m_numBlendShapes is 0.
	uint8_t m_numBlendedAttributes; // Must be zero if there are no blend shapes in the scene
	uint16_t *m_blendedAttributeIndexes; // Index of the start of each attribute within a single vertex delta.  has m_numBlendedAttributes entries
	EdgeGeomAttributeId *m_blendedAttributeIds; // has m_numBlendedAttributes entries. Can be NULL if m_numBlendShapes is 0.

	// Scene skinning data.  These pointers can be NULL if the scene is unskinned (though the skinning flavor
	// *must* be set to kSkinNone in that case).
	int32_t *m_matrixIndexesPerVertex; // Has kEdgeGeomNumInputBonesPerVertex * m_numVertexes entries.  Unused elements must be set to -1.
	float *m_skinningWeightsPerVertex; // Has kEdgeGeomNumInputBonesPerVertex * m_numVertexes entries.  Unused elements must be set to 0.
};


/// Provides a convenient container to bundle all the data for a single geometry segment together,
/// in its final, big-endian form, ready to be written to disk or processed immediately by the SPUs.
/// The user is responsible for calling edgeGeomFree() on all the data buffers in this structure.
struct EdgeGeomSegment
{
	// Copied from the EdgeGeomScene.  Provided only for bookkeeping purposes, so that a mapping
	// can be created from batches to geometry segments.
	uint32_t m_materialId;

	// Filled by edgeGeomMakeSpuConfigInfo
	uint8_t *m_spuConfigInfo;
	
	// Filled by edgeGeomMakeIndexBuffer
	uint8_t *m_indexes;
	uint16_t m_indexesSizes[2]; // Size of index DMA tags, in bytes.

	// Filled by edgeGeomMakeSpuVertexBuffer
	uint8_t *m_spuVertexes[2]; // One pointer for each input vertex stream (the second stream is optional)
	uint16_t m_spuVertexesSizes[6]; // Sizes of vertex DMA tags, in bytes.  First three sizes are for first input stream, second three for secondary input stream
	uint32_t m_fixedOffsetsSize[2]; // Sizes in bytes. Two sets of offsets, one for each input vertex stream
	uint32_t *m_fixedOffsetPtrs[2]; // Pointers to tables of fixed point offsets, one table per SPU input vertex stream.

	// Filled by edgeGeomMakeRsxVertexBuffer
	uint8_t *m_rsxOnlyVertexes; // Optional vertex stream for this segment that should be sent directly to the RSX.  Can be NULL.
	uint32_t m_rsxOnlyVertexesSize; // Size of m_rsxOnlyVertexes, in bytes.

	// Filled by edgeGeomMake*StreamDescription
	uint8_t *m_spuInputStreamDescriptions[2]; // one stream description each for primary & secondary input vertex streams
	uint16_t m_spuInputStreamDescriptionSizes[2]; // sizes in bytes
	uint8_t *m_spuOutputStreamDescription;
	uint16_t m_spuOutputStreamDescriptionSize; // size in bytes
	uint8_t *m_rsxOnlyStreamDescription; // stream description for the optional RSX-only vertex stream.  Will always be present if m_rsxVertexes is non-NULL.
	uint16_t m_rsxOnlyStreamDescriptionSize; // size in bytes

	// Filled by edgeGeomMakeSkinningBuffers
	uint16_t m_skinMatricesByteOffsets[2]; // Byte offsets of the start of the two matrix ranges to upload with this segment's job data
	uint16_t m_skinMatricesSizes[2]; // size (in bytes) of the two matrix ranges to upload with this segment's job data
	uint8_t *m_skinIndexesAndWeights;
	uint16_t m_skinIndexesAndWeightsSizes[2]; // sizes in bytes of skinning index/weights DMA tags.

	// Comes from the partitioner
	uint32_t m_ioBufferSize; // size in bytes
	// A function of the total input attribute count, the culling flavor, and the number of unique vertexes
	uint32_t m_scratchSize; // in 16-byte qwords
	
	// Filled by edgeGeomMakeBlendShapeBuffer
	uint32_t m_numBlendShapes;
	uint16_t *m_blendShapeSizes; // size of each blend shape buffer, in bytes.  Has m_numBlendShapes entries.
	uint8_t **m_blendShapes; // array of pointers to blend shape buffers.  Has m_numBlendShapes entries.
};

//-------------------

/// The polygons array should be CCW ordered polygon indexes, terminated with a -1 after each 
/// polygon.  Terminate the array with an additional -1.  
/// Each polygon should have a single entry in the materialIdPerPolygon that indicates what 
/// material it uses.  This is necessary because each triangle generated will also need to know 
/// what material to use when rendering.
///
/// Following example shows two triangles with the same material, followed by a quad with a different material.
/// polygons:              |a|b|c|-1|a|c|d|-1|a|b|f|g|-1|-1|
/// materialIdPerPolygon:  |0|0|1|
void edgeGeomTriangulatePolygons(const int32_t *polygons, const int32_t *materialIdPerPolygon,
								   uint32_t **outTriangles, int32_t **outMaterialIdPerTriangle, uint32_t *outNumTriangles);

/// Iterate over the vertexes in an Edge scene, identifying vertexes that are identical to each other.
/// The actual vertex data is not modified; instead, the triangle list is rewritten to not refer to
/// duplicate vertexes.
/// Returns the number of vertexes eliminated due to duplication.
uint32_t edgeGeomMergeIdenticalVertexes(EdgeGeomScene &edgeScene);

// Performs all end-to-end processing necessary to convert an input scene into a list of geometry segments.
// This includes:
// - partitioning the scene into batches (collections of triangles sharing a single material ID and skinning
//   algorithm)
// - invoking the Edge partitioner on each batch
// - creating all necessary output data buffers for each geometry segment
// - running the kcache optimizer on all partitioner triangle lists, for optimum pre-transform cache performance
//   on the RSX.
void edgeGeomPartitionSceneIntoSegments(const EdgeGeomScene &edgeScene, const EdgeGeomSegmentFormat &edgeFormat,
										  EdgeGeomSegment **outSegments, uint32_t *outNumSegments,
										  EdgeGeomCustomPartitionDataSizeFunc partitionDataSizeFunc = NULL,
										  EdgeGeomCustomCommandBufferHoleSizeFunc commandBufferHoleSizeFunc = NULL);

// Helper function that simply calls edgeGeomFree() on all of an EdgeGeomSegment's pointer members.
// It is highly recommended that users use this function instead of manually freeing the structure's members
// themselves, as this will prevent problems if additional members are added/removed in future releases.
void edgeGeomFreeSegmentData(EdgeGeomSegment &segment);

#endif // !defined(LIBEDGEGEOMTOOL_WRAP_H)
